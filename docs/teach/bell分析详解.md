# Bell æ€åˆ†æè¯¦è§£ - é‡å­çº ç¼ çš„éªŒè¯ä¸é‡åŒ–

> æ·±å…¥ç†è§£ Bell æ€ä¿çœŸåº¦åˆ†æï¼šç‰©ç†æ„ä¹‰ã€æ•°å­¦æ¨å¯¼ã€å·¥ç¨‹å®ç°ä¸åº”ç”¨åœºæ™¯

---

## ğŸ“‹ ç›®å½•

1. [Bell æ€çš„ç‰©ç†æ„ä¹‰](#bellæ€çš„ç‰©ç†æ„ä¹‰)
2. [ä¿çœŸåº¦çš„æ•°å­¦å®šä¹‰](#ä¿çœŸåº¦çš„æ•°å­¦å®šä¹‰)
3. [å¹¿ä¹‰ Bell æ€åŸºçŸ¢ç”Ÿæˆ](#å¹¿ä¹‰bellæ€åŸºçŸ¢ç”Ÿæˆ)
4. [å·¥ç¨‹å®ç°è¯¦è§£](#å·¥ç¨‹å®ç°è¯¦è§£)
5. [ä¸ç³»ç»Ÿæ¶æ„çš„é›†æˆ](#ä¸ç³»ç»Ÿæ¶æ„çš„é›†æˆ)
6. [åº”ç”¨åœºæ™¯ä¸æ¡ˆä¾‹](#åº”ç”¨åœºæ™¯ä¸æ¡ˆä¾‹)
7. [å¸¸è§é—®é¢˜è§£ç­”](#å¸¸è§é—®é¢˜è§£ç­”)

---

## Bellæ€çš„ç‰©ç†æ„ä¹‰

### ğŸŒŒ ä»€ä¹ˆæ˜¯ Bell æ€ï¼Ÿ

Bell æ€æ˜¯é‡å­åŠ›å­¦ä¸­æœ€é‡è¦çš„**æœ€å¤§çº ç¼ æ€**ï¼Œä»¥ç‰©ç†å­¦å®¶ John Bell çš„åå­—å‘½åã€‚å®ƒæ˜¯ä¸¤ä¸ªï¼ˆæˆ–å¤šä¸ªï¼‰é‡å­ç³»ç»Ÿä¹‹é—´çº ç¼ çš„æ ‡å‡†å½¢å¼ã€‚

---

### ğŸ“ 2-qubit Bell æ€ï¼ˆæ ‡å‡†å½¢å¼ï¼‰

å¯¹äºä¸¤ä¸ª qubit ç³»ç»Ÿï¼ˆæ¯ä¸ª qubit çš„å±€åŸŸç»´åº¦ \(d=2\)ï¼‰ï¼Œæœ‰ **4 ä¸ªæ ‡å‡† Bell æ€**ï¼š

\[
\begin{aligned}
|\Phi^+\rangle &= \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle) \\
|\Phi^-\rangle &= \frac{1}{\sqrt{2}} (|00\rangle - |11\rangle) \\
|\Psi^+\rangle &= \frac{1}{\sqrt{2}} (|01\rangle + |10\rangle) \\
|\Psi^-\rangle &= \frac{1}{\sqrt{2}} (|01\rangle - |10\rangle)
\end{aligned}
\]

---

### ğŸ”¬ ç‰©ç†ç‰¹æ€§

| ç‰¹æ€§ | è¯´æ˜ | æ•°å­¦è¡¨è¾¾ |
|-----|------|----------|
| **æœ€å¤§çº ç¼ ** | ä¸¤ä¸ªå­ç³»ç»Ÿå®Œå…¨å…³è”ï¼Œæ— æ³•ç‹¬ç«‹æè¿° | çº¯åº¦ = 1 |
| **éå±€åŸŸæ€§** | è¿å Bell ä¸ç­‰å¼ | CHSH å€¼ > 2 |
| **å®Œå¤‡æ€§** | 4 ä¸ª Bell æ€æ„æˆ 4 ç»´å¸Œå°”ä¼¯ç‰¹ç©ºé—´çš„å®Œå¤‡æ­£äº¤åŸº | \(\sum_i \|\Phi_i\rangle\langle\Phi_i\| = I\) |
| **çº ç¼ ç†µ** | çº¦åŒ–å¯†åº¦çŸ©é˜µçš„å†¯Â·è¯ºä¾æ›¼ç†µè¾¾åˆ°æœ€å¤§ | \(S = \log_2 d\) |

---

### ğŸ§ª å®éªŒæ„ä¹‰

åœ¨é‡å­å…‰å­¦/é‡å­ä¿¡æ¯å®éªŒä¸­ï¼ŒBell æ€åˆ†æç”¨äºï¼š

1. **éªŒè¯çº ç¼ æ€åˆ¶å¤‡è´¨é‡**ï¼šæµ‹é‡å®é™…åˆ¶å¤‡çš„æ€ä¸ç†æƒ³ Bell æ€çš„æ¥è¿‘ç¨‹åº¦
2. **è¯†åˆ«ä¸»å¯¼çš„çº ç¼ æ¨¡å¼**ï¼šç¡®å®šå®é™…åˆ¶å¤‡çš„æ˜¯å“ªä¸ª Bell æ€
3. **é‡åŒ–çº ç¼ èµ„æº**ï¼šè¯„ä¼°æ€çš„çº ç¼ ç¨‹åº¦ï¼ˆä¿çœŸåº¦è¶Šé«˜ï¼Œçº ç¼ è¶Šå¥½ï¼‰
4. **è¯Šæ–­å®éªŒè¯¯å·®**ï¼šé€šè¿‡ä¿çœŸåº¦ä¸‹é™å®šä½é—®é¢˜ï¼ˆå…‰å­¦å¯¹é½ã€å™ªå£°ã€ç›¸ä½æ¼‚ç§»ç­‰ï¼‰

**ä¸¾ä¾‹**ï¼šå¦‚æœä½ åœ¨å®éªŒä¸­å°è¯•åˆ¶å¤‡ \(|\Phi^+\rangle\)ï¼Œé‡æ„å‡ºçš„å¯†åº¦çŸ©é˜µ \(\rho\) ä¸ \(|\Phi^+\rangle\langle\Phi^+|\) çš„ä¿çœŸåº¦åº”è¯¥æ¥è¿‘ 1ã€‚å¦‚æœåªæœ‰ 0.8ï¼Œè¯´æ˜å­˜åœ¨é€€ç›¸å¹²æˆ–åˆ¶å¤‡è¯¯å·®ã€‚

---

## ä¿çœŸåº¦çš„æ•°å­¦å®šä¹‰

### ğŸ“Š ä¿çœŸåº¦ï¼ˆFidelityï¼‰

ç»™å®šä¸€ä¸ªå¯†åº¦çŸ©é˜µ \(\rho\)ï¼ˆé‡æ„å‡ºçš„å®é™…æ€ï¼‰å’Œä¸€ä¸ªç›®æ ‡çº¯æ€ \(|\psi\rangle\)ï¼ˆç†æƒ³ Bell æ€ï¼‰ï¼Œ**ä¿çœŸåº¦** å®šä¹‰ä¸ºï¼š

\[
F(\rho, |\psi\rangle) = \langle\psi|\rho|\psi\rangle
\]

---

### ğŸ¯ ç‰©ç†æ„ä¹‰

- **æ•°å€¼èŒƒå›´**ï¼š\(0 \leq F \leq 1\)
- **æœ€å¤§å€¼**ï¼š\(F = 1\) è¡¨ç¤º \(\rho = |\psi\rangle\langle\psi|\)ï¼ˆå®Œå…¨åŒ¹é…ï¼‰
- **æœ€å°å€¼**ï¼š\(F = 0\) è¡¨ç¤º \(\rho\) ä¸ \(|\psi\rangle\) æ­£äº¤
- **å…¸å‹å€¼**ï¼š
  - \(F > 0.9\)ï¼šé«˜è´¨é‡çº ç¼ æ€
  - \(0.7 < F < 0.9\)ï¼šä¸­ç­‰è´¨é‡
  - \(F < 0.7\)ï¼šä½è´¨é‡æˆ–éçº ç¼ æ€

---

### ğŸ§® è®¡ç®—å…¬å¼

å¯¹äºçº¯æ€ \(|\psi\rangle\) å’Œå¯†åº¦çŸ©é˜µ \(\rho\)ï¼š

\[
F = \langle\psi|\rho|\psi\rangle = \sum_{i,j} \psi^*_i \rho_{ij} \psi_j
\]

**Python å®ç°**ï¼š

```python
def fidelity(rho: np.ndarray, psi: np.ndarray) -> float:
    """è®¡ç®—ä¿çœŸåº¦ F = âŸ¨Ïˆ|Ï|ÏˆâŸ©"""
    return np.real(np.vdot(psi, rho @ psi))
```

**éªŒè¯**ï¼š
- \(\rho\) æ˜¯åŠæ­£å®šçŸ©é˜µï¼ˆå¯†åº¦çŸ©é˜µçš„ç‰©ç†è¦æ±‚ï¼‰
- \(|\psi\rangle\) æ˜¯å½’ä¸€åŒ–çš„æ€çŸ¢é‡ï¼ˆ\(\langle\psi|\psi\rangle = 1\)ï¼‰
- å› æ­¤ \(F\) æ€»æ˜¯å®æ•°ä¸” \(0 \leq F \leq 1\)

---

### ğŸ“ˆ ä¿çœŸåº¦ vs. çº¯åº¦

| æŒ‡æ ‡ | å®šä¹‰ | ç‰©ç†æ„ä¹‰ |
|-----|------|----------|
| **çº¯åº¦** | \(\text{Tr}(\rho^2)\) | é‡åŒ–æ€çš„"çº¯å‡€ç¨‹åº¦"ï¼ˆçº¯æ€ vs. æ··æ€ï¼‰ |
| **ä¿çœŸåº¦** | \(\langle\psi\|\rho\|\psi\rangle\) | é‡åŒ–æ€ä¸ç›®æ ‡æ€çš„"æ¥è¿‘ç¨‹åº¦" |

**åŒºåˆ«ç¤ºä¾‹**ï¼š
- \(\rho = I/d\)ï¼ˆæœ€å¤§æ··æ€ï¼‰ï¼šçº¯åº¦ = \(1/d\)ï¼Œä¸ä»»ä½• Bell æ€çš„ä¿çœŸåº¦ = \(1/d\)
- \(\rho = 0.9|\Phi^+\rangle\langle\Phi^+| + 0.1 I/4\)ï¼šçº¯åº¦ â‰ˆ 0.83ï¼Œä¸ \(|\Phi^+\rangle\) çš„ä¿çœŸåº¦ = 0.925

---

## å¹¿ä¹‰Bellæ€åŸºçŸ¢ç”Ÿæˆ

### ğŸŒ ä» 2-qubit åˆ°ä»»æ„ qudit

æ ‡å‡† Bell æ€ï¼ˆ2-qubitï¼‰å¯æ¨å¹¿åˆ°ä»»æ„å±€åŸŸç»´åº¦ \(d\) çš„ **å¹¿ä¹‰ Bell æ€**ã€‚

---

### ğŸ“ å¹¿ä¹‰ Bell æ€å®šä¹‰

å¯¹äºä¸¤ä¸ª \(d\) ç»´ç³»ç»Ÿï¼ˆquditï¼‰ï¼Œå¹¿ä¹‰ Bell æ€å®šä¹‰ä¸ºï¼š

\[
|\Phi_{m,n}\rangle = \frac{1}{\sqrt{d}} \sum_{k=0}^{d-1} \omega^{mk} |k, (k+n) \bmod d\rangle
\]

å…¶ä¸­ï¼š
- \(m, n \in \{0, 1, \ldots, d-1\}\)ï¼ˆå…± \(d^2\) ä¸ªæ€ï¼‰
- \(\omega = e^{2\pi i / d}\)ï¼ˆ\(d\) æ¬¡å•ä½æ ¹ï¼‰
- \(|k, j\rangle\) è¡¨ç¤ºç¬¬ä¸€ä¸ªç³»ç»Ÿå¤„äºæ€ \(k\)ï¼Œç¬¬äºŒä¸ªç³»ç»Ÿå¤„äºæ€ \(j\)

---

### ğŸ”¢ å…·ä½“ä¾‹å­

#### ä¾‹ 1ï¼š\(d=2\)ï¼ˆæ ‡å‡† Bell æ€ï¼‰

\[
\begin{aligned}
|\Phi_{0,0}\rangle &= \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle) = |\Phi^+\rangle \\
|\Phi_{0,1}\rangle &= \frac{1}{\sqrt{2}} (|01\rangle + |10\rangle) = |\Psi^+\rangle \\
|\Phi_{1,0}\rangle &= \frac{1}{\sqrt{2}} (|00\rangle - |11\rangle) = |\Phi^-\rangle \\
|\Phi_{1,1}\rangle &= \frac{1}{\sqrt{2}} (|01\rangle - |10\rangle) = |\Psi^-\rangle
\end{aligned}
\]

#### ä¾‹ 2ï¼š\(d=3\)ï¼ˆqutrit Bell æ€ï¼‰

å¯¹äº \(\omega = e^{2\pi i/3}\)ï¼š

\[
|\Phi_{0,0}\rangle = \frac{1}{\sqrt{3}} (|00\rangle + |11\rangle + |22\rangle)
\]

\[
|\Phi_{1,0}\rangle = \frac{1}{\sqrt{3}} (|00\rangle + \omega|11\rangle + \omega^2|22\rangle)
\]

å…± \(3^2 = 9\) ä¸ªå¹¿ä¹‰ Bell æ€ã€‚

---

### ğŸ’» Python å®ç°

#### æ ¸å¿ƒå‡½æ•°ï¼š`generate_generalized_bell_states`

```python
def generate_generalized_bell_states(local_dimension: int) -> list[np.ndarray]:
    """ç”Ÿæˆå¹¿ä¹‰ Bell æ€åŸºçŸ¢ã€‚
    
    å‚æ•°:
        local_dimension: å±€åŸŸç»´åº¦ dï¼ˆä¾‹å¦‚ d=2 è¡¨ç¤º qubitï¼Œd=3 è¡¨ç¤º qutritï¼‰
    
    è¿”å›:
        é•¿åº¦ä¸º dÂ² çš„åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå½’ä¸€åŒ–çš„æ€çŸ¢é‡ï¼ˆé•¿åº¦ dÂ²ï¼‰
    
    æ•°å­¦å…¬å¼:
        |Î¦_mnâŸ© = (1/âˆšd) Î£_k Ï‰^(mk) |k, (k+n) mod dâŸ©
        å…¶ä¸­ Ï‰ = exp(2Ï€i/d)
    """
    if local_dimension < 2:
        raise ValueError("local_dimension must be >= 2")
    
    d = local_dimension
    omega = np.exp(2j * np.pi / d)  # d æ¬¡å•ä½æ ¹
    basis_states: list[np.ndarray] = []
    
    # éå† m, n âˆˆ {0, 1, ..., d-1}
    for m in range(d):
        for n in range(d):
            # åˆ›å»ºé›¶å‘é‡ï¼ˆé•¿åº¦ dÂ²ï¼‰
            state = np.zeros(d * d, dtype=complex)
            
            # æ„å»ºæ€çŸ¢é‡çš„ç³»æ•°
            for k in range(d):
                i = k                  # ç¬¬ä¸€ä¸ªç³»ç»Ÿçš„ç´¢å¼•
                j = (k + n) % d        # ç¬¬äºŒä¸ªç³»ç»Ÿçš„ç´¢å¼•ï¼ˆå¾ªç¯ç§»ä½ï¼‰
                idx = i * d + j        # å¤åˆç³»ç»Ÿçš„ç´¢å¼•ï¼ˆæŒ‰è¡Œä¼˜å…ˆï¼‰
                state[idx] += omega ** (m * k)  # æ·»åŠ ç›¸ä½å› å­
            
            # å½’ä¸€åŒ–
            state /= np.sqrt(d)
            basis_states.append(state)
    
    return basis_states
```

---

### ğŸ§ª éªŒè¯ï¼šæ­£äº¤å½’ä¸€æ€§

å¹¿ä¹‰ Bell æ€æ„æˆæ­£äº¤å½’ä¸€åŸºï¼š

\[
\langle\Phi_{m,n}|\Phi_{m',n'}\rangle = \delta_{mm'} \delta_{nn'}
\]

**Python éªŒè¯ä»£ç **ï¼š

```python
def verify_orthonormality(local_dimension: int):
    """éªŒè¯å¹¿ä¹‰ Bell æ€çš„æ­£äº¤å½’ä¸€æ€§"""
    states = generate_generalized_bell_states(local_dimension)
    d2 = local_dimension ** 2
    
    # æ„å»º Gram çŸ©é˜µ
    gram = np.zeros((d2, d2), dtype=complex)
    for i, psi_i in enumerate(states):
        for j, psi_j in enumerate(states):
            gram[i, j] = np.vdot(psi_i, psi_j)
    
    # åº”è¯¥æ¥è¿‘å•ä½çŸ©é˜µ
    identity = np.eye(d2)
    error = np.linalg.norm(gram - identity)
    
    print(f"æ­£äº¤å½’ä¸€æ€§è¯¯å·®ï¼š{error:.2e}")
    assert error < 1e-10, "Bell æ€ä¸æ­£äº¤å½’ä¸€ï¼"
```

---

### ğŸ“Š Bell æ€ç´¢å¼•å¯¹ç…§è¡¨

å¯¹äº \(d=2\)ï¼ˆä¸¤ä¸ª qubitï¼‰ï¼ŒBell æ€ç´¢å¼•ä¸ç‰©ç†æ€çš„å¯¹åº”å…³ç³»ï¼š

| ç´¢å¼• | \((m, n)\) | æ€çŸ¢é‡ | ç‰©ç†åç§° |
|------|-----------|--------|----------|
| 0 | (0, 0) | \(\frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle)\) | \(\|\Phi^+\rangle\) |
| 1 | (0, 1) | \(\frac{1}{\sqrt{2}}(\|01\rangle + \|10\rangle)\) | \(\|\Psi^+\rangle\) |
| 2 | (1, 0) | \(\frac{1}{\sqrt{2}}(\|00\rangle - \|11\rangle)\) | \(\|\Phi^-\rangle\) |
| 3 | (1, 1) | \(\frac{1}{\sqrt{2}}(\|01\rangle - \|10\rangle)\) | \(\|\Psi^-\rangle\) |

**ä½¿ç”¨æ–¹æ³•**ï¼š

```python
# ç”Ÿæˆ Bell åŸºçŸ¢
basis = generate_bell_basis(local_dimension=2)  # shape: (4, 4)

# è®¿é—®ç‰¹å®š Bell æ€
phi_plus = basis[0]   # |Î¦âºâŸ©
psi_minus = basis[3]  # |Î¨â»âŸ©

# è®¡ç®—ä¿çœŸåº¦
fidelity_phi_plus = np.real(np.vdot(phi_plus, rho @ phi_plus))
```

---

## å·¥ç¨‹å®ç°è¯¦è§£

### ğŸ—ï¸ æ¨¡å—ç»“æ„

```
qtomography/analysis/bell.py
â”œâ”€â”€ BellAnalysisResult        # æ•°æ®ç±»ï¼šå­˜å‚¨åˆ†æç»“æœ
â”œâ”€â”€ analyze_density_matrix    # ä¸»å‡½æ•°ï¼šåˆ†æå•ä¸ªå¯†åº¦çŸ©é˜µ
â”œâ”€â”€ analyze_record            # å°è£…ï¼šåˆ†æ ReconstructionRecord
â”œâ”€â”€ analyze_records           # æ‰¹é‡ï¼šåˆ†æå¤šä¸ªè®°å½• â†’ DataFrame
â”œâ”€â”€ generate_bell_basis       # ç”Ÿæˆ Bell åŸºçŸ¢çŸ©é˜µ
â”œâ”€â”€ generate_generalized_bell_states  # æ ¸å¿ƒï¼šç”Ÿæˆå¹¿ä¹‰ Bell æ€
â”œâ”€â”€ _compute_fidelities       # ç§æœ‰ï¼šè®¡ç®—ä¿çœŸåº¦å‘é‡
â””â”€â”€ _infer_local_dimension    # ç§æœ‰ï¼šæ¨æ–­å±€åŸŸç»´åº¦
```

---

### ğŸ” æ ¸å¿ƒå‡½æ•° 1ï¼š`analyze_density_matrix`

```python
def analyze_density_matrix(
    density: DensityMatrix | np.ndarray,
    *,
    dimension: Optional[int] = None,
) -> BellAnalysisResult:
    """è®¡ç®—é‡æ„å¯†åº¦çŸ©é˜µçš„ Bell æ€ä¿çœŸåº¦ã€‚
    
    å‚æ•°:
        density: å¯†åº¦çŸ©é˜µï¼ˆDensityMatrix å¯¹è±¡æˆ– numpy æ•°ç»„ï¼‰
        dimension: å¸Œå°”ä¼¯ç‰¹ç©ºé—´ç»´åº¦ï¼ˆå¯é€‰ï¼Œä»çŸ©é˜µå½¢çŠ¶æ¨æ–­ï¼‰
    
    è¿”å›:
        BellAnalysisResult å¯¹è±¡ï¼ŒåŒ…å«ï¼š
        - dimension: æ€»ç»´åº¦ï¼ˆdÂ²ï¼‰
        - local_dimension: å±€åŸŸç»´åº¦ï¼ˆdï¼‰
        - fidelities: ä¸æ‰€æœ‰ Bell æ€çš„ä¿çœŸåº¦ï¼ˆé•¿åº¦ dÂ²ï¼‰
    
    æµç¨‹:
        [1] æå–/éªŒè¯å¯†åº¦çŸ©é˜µ
        [2] æ¨æ–­å±€åŸŸç»´åº¦ dï¼ˆè¦æ±‚ dimension æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼‰
        [3] ç”Ÿæˆå¹¿ä¹‰ Bell åŸºçŸ¢
        [4] è®¡ç®—ä¸æ¯ä¸ª Bell æ€çš„ä¿çœŸåº¦
        [5] è¿”å›ç»“æ„åŒ–ç»“æœ
    """
    # [1] æå–å¯†åº¦çŸ©é˜µ
    if isinstance(density, DensityMatrix):
        rho = density.matrix
    else:
        rho = np.array(density, dtype=complex)
    
    # éªŒè¯çŸ©é˜µå½¢çŠ¶
    if rho.ndim != 2 or rho.shape[0] != rho.shape[1]:
        raise ValueError("rho must be a square matrix")
    
    dim = rho.shape[0]
    if dimension is not None:
        if dimension != dim:
            raise ValueError("Provided dimension does not match matrix shape")
    
    # [2] æ¨æ–­å±€åŸŸç»´åº¦
    local_dim = _infer_local_dimension(dim)  # dim = local_dimÂ²
    
    # [3] ç”Ÿæˆ Bell åŸºçŸ¢
    basis = generate_bell_basis(local_dim)  # shape: (dim, dim)
    
    # [4] è®¡ç®—ä¿çœŸåº¦
    fidelities = _compute_fidelities(rho, basis)  # shape: (dim,)
    
    # [5] è¿”å›ç»“æœ
    return BellAnalysisResult(
        dimension=dim,
        local_dimension=local_dim,
        fidelities=fidelities
    )
```

---

### ğŸ“¦ æ•°æ®ç±»ï¼š`BellAnalysisResult`

```python
@dataclass
class BellAnalysisResult:
    """Bell æ€ä¿çœŸåº¦åˆ†æç»“æœã€‚
    
    å±æ€§:
        dimension: æ€»ç»´åº¦ï¼ˆdÂ²ï¼‰
        local_dimension: å±€åŸŸç»´åº¦ï¼ˆdï¼‰
        fidelities: ä¸æ‰€æœ‰ Bell æ€çš„ä¿çœŸåº¦æ•°ç»„ï¼ˆé•¿åº¦ dÂ²ï¼‰
    """
    dimension: int
    local_dimension: int
    fidelities: np.ndarray  # shape: (dÂ²,)
    
    def to_dict(self) -> dict:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼ï¼ˆç”¨äº JSON åºåˆ—åŒ–ï¼‰ã€‚
        
        è¿”å›:
            {
                "dimension": æ€»ç»´åº¦,
                "local_dimension": å±€åŸŸç»´åº¦,
                "max_fidelity": æœ€å¤§ä¿çœŸåº¦,
                "min_fidelity": æœ€å°ä¿çœŸåº¦,
                "avg_fidelity": å¹³å‡ä¿çœŸåº¦,
                "dominant_index": ä¸»å¯¼ Bell æ€çš„ç´¢å¼•
            }
        """
        values = self.fidelities
        return {
            "dimension": self.dimension,
            "local_dimension": self.local_dimension,
            "max_fidelity": float(np.max(values)) if values.size else float("nan"),
            "min_fidelity": float(np.min(values)) if values.size else float("nan"),
            "avg_fidelity": float(np.mean(values)) if values.size else float("nan"),
            "dominant_index": int(np.argmax(values)) if values.size else -1,
        }
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```python
# æ‰§è¡Œåˆ†æ
result = analyze_density_matrix(rho)

# è·å–æŒ‡æ ‡
metrics = result.to_dict()
print(f"æœ€å¤§ä¿çœŸåº¦ï¼š{metrics['max_fidelity']:.4f}")
print(f"ä¸»å¯¼ Bell æ€ï¼šç´¢å¼• {metrics['dominant_index']}")

# ä¿å­˜åˆ° JSON
with open("bell_result.json", "w") as f:
    json.dump(metrics, f, indent=2)
```

---

### ğŸ§® ç§æœ‰å‡½æ•°ï¼š`_compute_fidelities`

```python
def _compute_fidelities(rho: np.ndarray, basis: np.ndarray) -> np.ndarray:
    """è®¡ç®—å¯†åº¦çŸ©é˜µä¸æ‰€æœ‰åŸºçŸ¢çš„ä¿çœŸåº¦ã€‚
    
    å‚æ•°:
        rho: å¯†åº¦çŸ©é˜µï¼ˆshape: (dÂ², dÂ²)ï¼‰
        basis: Bell åŸºçŸ¢çŸ©é˜µï¼ˆshape: (dÂ², dÂ²)ï¼‰
    
    è¿”å›:
        ä¿çœŸåº¦æ•°ç»„ï¼ˆshape: (dÂ²,)ï¼‰
    
    æ•°å­¦å…¬å¼:
        F_i = âŸ¨Ïˆ_i|Ï|Ïˆ_iâŸ© = Ïˆ_iâ€  Ï Ïˆ_i
    
    å®ç°ç»†èŠ‚:
        - ä½¿ç”¨ np.vdot(psi, rho @ psi) é«˜æ•ˆè®¡ç®—
        - np.real_if_close å¤„ç†æµ®ç‚¹è¯¯å·®ï¼ˆåº”ä¸ºå®æ•°ï¼‰
        - å¼ºåˆ¶è½¬æ¢ä¸º floatï¼ˆç¡®ä¿å®æ•°è¾“å‡ºï¼‰
    """
    values = []
    for psi in basis:
        # è®¡ç®— âŸ¨Ïˆ|Ï|ÏˆâŸ©
        fidelity = np.real_if_close(np.vdot(psi, rho @ psi))
        values.append(float(np.real(fidelity)))
    return np.array(values, dtype=float)
```

**æ€§èƒ½ä¼˜åŒ–**ï¼š

```python
# å‘é‡åŒ–ç‰ˆæœ¬ï¼ˆæ›´å¿«ï¼‰
def _compute_fidelities_vectorized(rho: np.ndarray, basis: np.ndarray) -> np.ndarray:
    """å‘é‡åŒ–ç‰ˆæœ¬ï¼Œé¿å… Python å¾ªç¯"""
    # basis: (dÂ², dÂ²)ï¼Œæ¯è¡Œæ˜¯ä¸€ä¸ªæ€çŸ¢é‡
    # rho @ basis.T: (dÂ², dÂ²)
    # basis.conj() * (rho @ basis.T).T: é€å…ƒç´ ä¹˜ç§¯
    # æŒ‰åˆ—æ±‚å’Œå¾—åˆ°ä¿çœŸåº¦
    fidelities = np.real(np.einsum('ij,ji->i', basis.conj(), rho @ basis.T))
    return fidelities
```

---

### ğŸ” ç§æœ‰å‡½æ•°ï¼š`_infer_local_dimension`

```python
def _infer_local_dimension(dimension: int) -> int:
    """ä»æ€»ç»´åº¦æ¨æ–­å±€åŸŸç»´åº¦ã€‚
    
    å‚æ•°:
        dimension: æ€»ç»´åº¦ï¼ˆåº”ä¸ºå®Œå…¨å¹³æ–¹æ•°ï¼‰
    
    è¿”å›:
        å±€åŸŸç»´åº¦ dï¼ˆæ»¡è¶³ dÂ² = dimensionï¼‰
    
    å¼‚å¸¸:
        ValueError: å¦‚æœ dimension ä¸æ˜¯å®Œå…¨å¹³æ–¹æ•°
    
    ç¤ºä¾‹:
        _infer_local_dimension(4)  â†’ 2  (2-qubit)
        _infer_local_dimension(9)  â†’ 3  (2-qutrit)
        _infer_local_dimension(16) â†’ 4  (2-ququart æˆ– 4-qubit)
        _infer_local_dimension(6)  â†’ ValueErrorï¼ˆä¸æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼‰
    """
    local_dim = int(round(np.sqrt(dimension)))
    if local_dim * local_dim != dimension:
        raise ValueError(
            f"Bell analysis requires a perfect-square dimension; got {dimension}"
        )
    return local_dim
```

**ä¸ºä»€ä¹ˆè¦æ±‚å®Œå…¨å¹³æ–¹æ•°ï¼Ÿ**

Bell æ€åˆ†æå‡è®¾ç³»ç»Ÿæ˜¯**ä¸¤ä¸ªç›¸åŒç»´åº¦çš„å­ç³»ç»Ÿçš„å¼ é‡ç§¯**ï¼š
- æ€»ç»´åº¦ = \(d \times d = d^2\)
- å¦‚æœç»´åº¦ä¸æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼ˆä¾‹å¦‚ 6ï¼‰ï¼Œæ— æ³•åˆ†è§£ä¸ºä¸¤ä¸ªç›¸åŒç»´åº¦çš„å­ç³»ç»Ÿ

**è¾¹ç•Œæƒ…å†µ**ï¼š
- å¯¹äºå¤šä½“ç³»ç»Ÿï¼ˆä¾‹å¦‚ 3-qubitï¼Œ\(d=8=2^3\)ï¼‰ï¼Œå‡½æ•°ä¼šå°è¯•åˆ†è§£ä¸º \(d=2\sqrt{2}\)ï¼ˆéæ•´æ•°ï¼‰ï¼ŒæŠ›å‡ºå¼‚å¸¸
- å¦‚éœ€æ”¯æŒå¤šä½“ç³»ç»Ÿï¼Œéœ€è¦æ‰©å±•ä¸ºå¤šä½“ Bell æ€åˆ†æï¼ˆæœªå®ç°ï¼‰

---

### ğŸ“Š æ‰¹é‡åˆ†æï¼š`analyze_records`

```python
def analyze_records(
    records: Sequence[ReconstructionRecord],
) -> pd.DataFrame:
    """å¯¹å¤šä¸ªé‡æ„è®°å½•æ‰§è¡Œæ‰¹é‡ Bell åˆ†æã€‚
    
    å‚æ•°:
        records: ReconstructionRecord åˆ—è¡¨
    
    è¿”å›:
        pandas DataFrameï¼ŒåŒ…å«åˆ—ï¼š
        - sample: æ ·æœ¬ç´¢å¼•
        - method: é‡æ„æ–¹æ³•
        - bell_dimension: æ€»ç»´åº¦
        - bell_local_dimension: å±€åŸŸç»´åº¦
        - bell_max_fidelity: æœ€å¤§ä¿çœŸåº¦
        - bell_min_fidelity: æœ€å°ä¿çœŸåº¦
        - bell_avg_fidelity: å¹³å‡ä¿çœŸåº¦
        - bell_dominant_index: ä¸»å¯¼ Bell æ€ç´¢å¼•
    
    ç”¨é€”:
        - CLI å­å‘½ä»¤ 'bell-analyze' çš„åç«¯
        - æ‰¹é‡å®éªŒæ•°æ®çš„ Bell æ€åˆ†æ
    """
    rows = []
    for record in records:
        # åˆ†æå•ä¸ªè®°å½•
        result = analyze_record(record)
        metrics = result.to_dict()
        
        # æå–å…ƒæ•°æ®
        sample_index = record.metadata.get("sample_index", "?") if record.metadata else "?"
        
        # æ„å»ºè¡Œæ•°æ®
        row = {
            "sample": sample_index,
            "method": record.method,
            "bell_dimension": metrics["dimension"],
            "bell_local_dimension": metrics["local_dimension"],
            "bell_max_fidelity": metrics["max_fidelity"],
            "bell_min_fidelity": metrics["min_fidelity"],
            "bell_avg_fidelity": metrics["avg_fidelity"],
            "bell_dominant_index": metrics["dominant_index"],
        }
        rows.append(row)
    
    return pd.DataFrame(rows)
```

**è¾“å‡ºç¤ºä¾‹**ï¼š

```
   sample   method  bell_dimension  bell_local_dimension  bell_max_fidelity  bell_dominant_index
0       0   linear               4                     2           0.982145                    0
1       0      mle               4                     2           0.995678                    0
2       1   linear               4                     2           0.945321                    1
3       1      mle               4                     2           0.987654                    1
```

---

## ä¸ç³»ç»Ÿæ¶æ„çš„é›†æˆ

### ğŸ—ï¸ åœ¨åˆ†å±‚æ¶æ„ä¸­çš„ä½ç½®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ã€é¢†åŸŸå±‚ - Domain Layerã€‘                â”‚
â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ é‡æ„ç®—æ³•        â”‚  â”‚ æ•°æ®ç»“æ„        â”‚â”‚
â”‚  â”‚ - Linear        â”‚  â”‚ - DensityMatrix â”‚â”‚
â”‚  â”‚ - MLE           â”‚  â”‚ - ProjectorSet  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ åˆ†æå±‚ (Analysis Sub-layer)           â”‚â”‚
â”‚  â”‚ - BellAnalysis â† å½“å‰æ¨¡å—             â”‚â”‚
â”‚  â”‚   - analyze_density_matrix            â”‚â”‚
â”‚  â”‚   - generate_generalized_bell_states  â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘ è¢«è°ƒç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ã€åº”ç”¨å±‚ - Application Layerã€‘           â”‚
â”‚  - ReconstructionController              â”‚
â”‚    - åœ¨ run_batch ä¸­å¯é€‰è°ƒç”¨ Bell åˆ†æ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘ è¢«è°ƒç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ã€æ¥å£å±‚ - Interface Layerã€‘             â”‚
â”‚  - CLI: --bell å‚æ•°è§¦å‘åˆ†æ              â”‚
â”‚  - CLI: bell-analyze å­å‘½ä»¤              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ”— é›†æˆç‚¹ 1ï¼š`controller.py`

```python
@dataclass
class ReconstructionConfig:
    """é‡æ„é…ç½®å¯¹è±¡"""
    ...
    analyze_bell: bool = False  # â† Bell åˆ†æå¼€å…³
    ...

def run_batch(config: ReconstructionConfig) -> SummaryResult:
    """æ‰¹å¤„ç†ä¸»å‡½æ•°"""
    for sample_index, probs in enumerate(probability_columns):
        # ... æ‰§è¡Œé‡æ„ï¼ˆLinear / MLEï¼‰...
        
        # [å¯é€‰] æ‰§è¡Œ Bell æ€åˆ†æ
        if config.analyze_bell:
            try:
                from qtomography.analysis.bell import analyze_density_matrix
                bell_result = analyze_density_matrix(density)
                bell_metrics = bell_result.to_dict()
                
                # åˆå¹¶åˆ°æŒ‡æ ‡å­—å…¸
                record_metadata.update(bell_metrics)
                
                logger.info(
                    f"ğŸ”” Bell åˆ†æ: æœ€å¤§ä¿çœŸåº¦={bell_metrics['max_fidelity']:.4f}, "
                    f"ä¸»å¯¼æ€={bell_metrics['dominant_index']}"
                )
            except Exception as e:
                logger.warning(f"âš ï¸ Bell åˆ†æå¤±è´¥: {e}")
                # å¤±è´¥ä¸å½±å“é‡æ„æµç¨‹ï¼ˆå®¹é”™è®¾è®¡ï¼‰
        
        # ... ä¿å­˜è®°å½• ...
```

---

### ğŸ”— é›†æˆç‚¹ 2ï¼š`main.py` (CLI)

```python
def build_parser():
    # å­å‘½ä»¤ 1: reconstruct
    reconstruct.add_argument(
        "--bell",
        action="store_true",
        help="æ‰§è¡Œ Bell æ€ä¿çœŸåº¦åˆ†æ"
    )
    
    # å­å‘½ä»¤ 3: bell-analyzeï¼ˆæ–°å¢ï¼‰
    bell_analyze = subparsers.add_parser(
        "bell-analyze",
        help="å¯¹å·²æœ‰é‡æ„è®°å½•æ‰§è¡Œ Bell æ€åˆ†æ"
    )
    bell_analyze.add_argument("records_dir", type=Path, help="è®°å½•ç›®å½•")
    bell_analyze.add_argument("--output", type=Path, help="è¾“å‡º CSV è·¯å¾„")
    bell_analyze.set_defaults(func=_cmd_bell_analyze)

def _cmd_bell_analyze(args):
    """bell-analyze å­å‘½ä»¤å¤„ç†å‡½æ•°"""
    records_dir = args.records_dir
    repo = ResultRepository(records_dir, fmt="json")
    records = list(repo.load_all())
    
    # æ‰¹é‡åˆ†æ
    from qtomography.analysis.bell import analyze_records
    df = analyze_records(records)
    
    # ä¿å­˜ç»“æœ
    output_path = args.output or (records_dir / "bell_summary.csv")
    df.to_csv(output_path, index=False)
    print(f"ğŸ”” Bell æ€åˆ†æç»“æœå·²ä¿å­˜è‡³ï¼š{output_path}")
```

---

### ğŸ“ˆ æ•°æ®æµ

```
ç”¨æˆ·å‘½ä»¤è¡Œè¾“å…¥
    â†“
qtomography reconstruct data.csv --bell
    â†“
CLI è§£æå‚æ•° (main.py)
    â†“
ReconstructionConfig(analyze_bell=True)
    â†“
Controller.run_batch(config)
    â†“
å¯¹æ¯ä¸ªæ ·æœ¬ï¼š
    [1] é‡æ„å¯†åº¦çŸ©é˜µ (Linear/MLE)
    [2] å¦‚æœ analyze_bell=True:
        analyze_density_matrix(density)
    [3] åˆå¹¶ Bell æŒ‡æ ‡åˆ° metadata
    [4] ä¿å­˜ JSON è®°å½•
    â†“
ç”Ÿæˆ summary.csvï¼ˆåŒ…å« bell_max_fidelity ç­‰åˆ—ï¼‰
    â†“
è¾“å‡ºåˆ°ç”¨æˆ·
```

---

## åº”ç”¨åœºæ™¯ä¸æ¡ˆä¾‹

### åœºæ™¯ 1ï¼šçº ç¼ æ€åˆ¶å¤‡è´¨é‡éªŒè¯

**å®éªŒç›®æ ‡**ï¼šåˆ¶å¤‡ \(|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)\) Bell æ€

```bash
# é‡æ„ + Bell åˆ†æ
qtomography reconstruct bell_preparation.csv --dimension 4 --method mle --bell

# æŸ¥çœ‹ç»“æœ
qtomography summarize results/summary.csv --metrics bell_max_fidelity bell_dominant_index
```

**ç†æƒ³ç»“æœ**ï¼š
- `bell_max_fidelity` â‰ˆ 0.99ï¼ˆé«˜ä¿çœŸåº¦ï¼‰
- `bell_dominant_index` = 0ï¼ˆå¯¹åº” \(|\Phi^+\rangle\)ï¼‰

**é—®é¢˜è¯Šæ–­**ï¼š
- ä¿çœŸåº¦ < 0.9ï¼šæ£€æŸ¥å…‰å­¦å¯¹é½ã€ç›¸ä½ç¨³å®šæ€§
- ä¸»å¯¼ç´¢å¼•é”™è¯¯ï¼šæ£€æŸ¥æµ‹é‡åŸºé€‰æ‹©ã€ç›¸ä½æ ¡å‡†

---

### åœºæ™¯ 2ï¼šæ¯”è¾ƒ Linear vs. MLE çš„çº ç¼ æ€é‡æ„

```python
# Python è„šæœ¬
from qtomography.cli.main import main

# åŒæ—¶è¿è¡Œä¸¤ç§æ–¹æ³•
main([
    'reconstruct',
    'entangled_data.csv',
    '--method', 'both',
    '--bell',
    '--output-dir', 'comparison/'
])

# è¯»å–ç»“æœ
import pandas as pd
df = pd.read_csv('comparison/summary.csv')

# åˆ†ç»„æ¯”è¾ƒ
grouped = df.groupby('method')['bell_max_fidelity'].agg(['mean', 'std'])
print(grouped)

# è¾“å‡ºç¤ºä¾‹ï¼š
#          mean       std
# method
# linear  0.9456  0.0234
# mle     0.9812  0.0087  â† MLE æ›´æ¥è¿‘ç†æƒ³å€¼
```

---

### åœºæ™¯ 3ï¼šå†å²æ•°æ®çš„ Bell æ€åˆ†æ

**èƒŒæ™¯**ï¼šä¹‹å‰è¿è¡Œé‡æ„æ—¶æ²¡æœ‰ä½¿ç”¨ `--bell`ï¼Œç°åœ¨éœ€è¦è¡¥å……åˆ†æ

```bash
# å¯¹å·²æœ‰è®°å½•æ‰§è¡Œ Bell åˆ†æ
qtomography bell-analyze results/experiment1/records/ \
    --output bell_analysis.csv

# æŸ¥çœ‹åˆ†å¸ƒ
python -c "
import pandas as pd
df = pd.read_csv('bell_analysis.csv')
print(df['bell_dominant_index'].value_counts())
"

# è¾“å‡ºç¤ºä¾‹ï¼š
# 0    45  â† 45 ä¸ªæ ·æœ¬æœ€æ¥è¿‘ |Î¦âºâŸ©
# 1    30  â† 30 ä¸ªæ ·æœ¬æœ€æ¥è¿‘ |Î¨âºâŸ©
# 2    15
# 3    10
```

---

### åœºæ™¯ 4ï¼šå¤šä½“çº ç¼ æ€çš„å±€é™æ€§

```python
# å°è¯•åˆ†æ 3-qubit æ€ï¼ˆç»´åº¦ 8ï¼‰
try:
    result = analyze_density_matrix(rho_8d)
except ValueError as e:
    print(e)
    # è¾“å‡ºï¼šBell analysis requires a perfect-square dimension; got 8

# è§£é‡Šï¼š8 ä¸æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œæ— æ³•åˆ†è§£ä¸ºä¸¤ä¸ªç›¸åŒç»´åº¦çš„å­ç³»ç»Ÿ
# éœ€è¦æ‰©å±•ä¸ºå¤šä½“ Bell æ€åˆ†æï¼ˆæœªå®ç°ï¼‰
```

**è§£å†³æ–¹æ¡ˆ**ï¼ˆæœªæ¥æ‰©å±•ï¼‰ï¼š
- å®ç° GHZ æ€ä¿çœŸåº¦åˆ†æï¼ˆå¤šä½“çº ç¼ çš„æ ‡å‡†å½¢å¼ï¼‰
- å®ç° W æ€ä¿çœŸåº¦åˆ†æ
- å®ç°çº ç¼ ç†µè®¡ç®—ï¼ˆæ›´é€šç”¨çš„çº ç¼ åº¦é‡ï¼‰

---

## å¸¸è§é—®é¢˜è§£ç­”

### â“ Q1: ä¸ºä»€ä¹ˆè¦æ±‚ç»´åº¦æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Ÿ

**A**: Bell æ€åˆ†æå‡è®¾ç³»ç»Ÿæ˜¯**ä¸¤ä¸ªç›¸åŒç»´åº¦å­ç³»ç»Ÿçš„å¼ é‡ç§¯**ã€‚ä¾‹å¦‚ï¼š
- 2-qubitï¼š\(d = 2 \times 2 = 4\) âœ…
- 2-qutritï¼š\(d = 3 \times 3 = 9\) âœ…
- 3-qubitï¼š\(d = 2 \times 2 \times 2 = 8\) âŒï¼ˆä¸æ˜¯ä¸¤ä¸ªå­ç³»ç»Ÿï¼‰

å¯¹äºéå®Œå…¨å¹³æ–¹æ•°ï¼Œéœ€è¦å…¶ä»–åˆ†ææ–¹æ³•ï¼ˆä¾‹å¦‚å¤šä½“çº ç¼ åº¦é‡ï¼‰ã€‚

---

### â“ Q2: `bell_dominant_index` çš„ç‰©ç†æ„ä¹‰ï¼Ÿ

**A**: å®ƒè¡¨ç¤º**æœ€æ¥è¿‘çš„ Bell æ€çš„ç´¢å¼•**ã€‚ä¾‹å¦‚ï¼š
- `dominant_index = 0`ï¼šæœ€æ¥è¿‘ \(|\Phi^+\rangle\)
- `dominant_index = 3`ï¼šæœ€æ¥è¿‘ \(|\Psi^-\rangle\)

è¿™å¯ä»¥ç”¨äºï¼š
- éªŒè¯åˆ¶å¤‡çš„æ˜¯å“ªä¸ª Bell æ€
- è¯†åˆ«å®éªŒä¸­çš„ç›¸ä½é”™è¯¯ï¼ˆä¾‹å¦‚æœ¬åº”æ˜¯ 0 ä½†å¾—åˆ° 2ï¼Œè¯´æ˜ç›¸ä½åäº†ï¼‰

---

### â“ Q3: ä¿çœŸåº¦ä½äº 0.5 æ„å‘³ç€ä»€ä¹ˆï¼Ÿ

**A**: 
- \(F < 0.5\)ï¼šæ€ä¸ç›®æ ‡ Bell æ€**éå¸¸ä¸åŒ**ï¼Œå¯èƒ½æ ¹æœ¬ä¸æ˜¯çº ç¼ æ€
- \(F \approx 0.25\)ï¼ˆå¯¹äº \(d=4\)ï¼‰ï¼šæ¥è¿‘æœ€å¤§æ··æ€ \(I/4\)ï¼ˆå®Œå…¨éšæœºï¼‰
- \(F \approx 0\)ï¼šæ€ä¸ç›®æ ‡ Bell æ€**æ­£äº¤**

**è¯Šæ–­å»ºè®®**ï¼š
1. æ£€æŸ¥æµ‹é‡è®¾ç½®æ˜¯å¦æ­£ç¡®
2. æ£€æŸ¥å¯†åº¦çŸ©é˜µé‡æ„æ˜¯å¦æ”¶æ•›
3. æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç³»ç»Ÿè¯¯å·®ï¼ˆä¾‹å¦‚æ¢æµ‹å™¨æ•ˆç‡ä¸åŒ¹é…ï¼‰

---

### â“ Q4: ä¸ºä»€ä¹ˆä½¿ç”¨ `np.real_if_close`ï¼Ÿ

**A**: ç†è®ºä¸Šä¿çœŸåº¦ \(F = \langle\psi|\rho|\psi\rangle\) æ˜¯å®æ•°ï¼Œä½†ç”±äºæµ®ç‚¹è¯¯å·®å¯èƒ½æœ‰å¾®å°è™šéƒ¨ï¼š

```python
# ç†è®ºå€¼ï¼š0.95
# å®é™…è®¡ç®—ï¼š0.95 + 1e-16j

fidelity = np.vdot(psi, rho @ psi)
print(fidelity)  # (0.95+1e-16j) â† è™šéƒ¨æ˜¯æ•°å€¼è¯¯å·®

# ä½¿ç”¨ np.real_if_close è‡ªåŠ¨å»é™¤å°è™šéƒ¨
fidelity = np.real_if_close(fidelity)
print(fidelity)  # 0.95 â† çº¯å®æ•°
```

---

### â“ Q5: å¦‚ä½•è§£é‡Šæ‰€æœ‰ä¿çœŸåº¦éƒ½å¾ˆä½ï¼Ÿ

**å¯èƒ½åŸå› **ï¼š
1. **é‡æ„å¤±è´¥**ï¼šå¯†åº¦çŸ©é˜µæœ¬èº«ä¸æ­£ç¡®ï¼ˆæ£€æŸ¥æ”¶æ•›æ€§ã€æ­£åˆ™åŒ–å‚æ•°ï¼‰
2. **éçº ç¼ æ€**ï¼šå®é™…åˆ¶å¤‡çš„æ€ä¸æ˜¯ Bell æ€
3. **ç»´åº¦é”™è¯¯**ï¼šåˆ†æç»´åº¦ä¸å®é™…æ€ä¸åŒ¹é…
4. **å™ªå£°è¿‡å¤§**ï¼šé€€ç›¸å¹²ä¸¥é‡ï¼Œçº¯åº¦å¾ˆä½

**è¯Šæ–­æ­¥éª¤**ï¼š
```python
# æ£€æŸ¥çº¯åº¦
purity = np.trace(rho @ rho)
print(f"çº¯åº¦: {purity:.4f}")  # åº”æ¥è¿‘ 1

# æ£€æŸ¥æ‰€æœ‰ä¿çœŸåº¦
result = analyze_density_matrix(rho)
print(f"æœ€å¤§ä¿çœŸåº¦: {result.to_dict()['max_fidelity']:.4f}")
print(f"å¹³å‡ä¿çœŸåº¦: {result.to_dict()['avg_fidelity']:.4f}")

# å¦‚æœçº¯åº¦é«˜ä½†ä¿çœŸåº¦ä½ï¼Œå¯èƒ½æ˜¯é Bell æ€
# å¦‚æœçº¯åº¦ä¹Ÿä½ï¼Œè¯´æ˜æ€æœ¬èº«è´¨é‡å·®
```

---

### â“ Q6: èƒ½å¦åˆ†æéƒ¨åˆ† Bell æ€ï¼Ÿ

**A**: å½“å‰å®ç°ä¼šè®¡ç®—ä¸**æ‰€æœ‰ \(d^2\) ä¸ª Bell æ€**çš„ä¿çœŸåº¦ã€‚å¦‚æœåªå…³å¿ƒç‰¹å®š Bell æ€ï¼Œå¯ä»¥ï¼š

```python
# æ–¹æ³• 1ï¼šä»å®Œæ•´ç»“æœä¸­æå–
result = analyze_density_matrix(rho)
phi_plus_fidelity = result.fidelities[0]  # åªå–ç´¢å¼• 0

# æ–¹æ³• 2ï¼šç›´æ¥è®¡ç®—ï¼ˆæ›´é«˜æ•ˆï¼‰
from qtomography.analysis.bell import generate_bell_basis
basis = generate_bell_basis(local_dimension=2)
phi_plus = basis[0]
fidelity = np.real(np.vdot(phi_plus, rho @ phi_plus))
```

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

| ç»´åº¦ | è¦ç‚¹ |
|-----|------|
| **ç‰©ç†æ„ä¹‰** | Bell æ€æ˜¯æœ€å¤§çº ç¼ æ€ï¼Œä¿çœŸåº¦é‡åŒ–ä¸ç†æƒ³æ€çš„æ¥è¿‘ç¨‹åº¦ |
| **æ•°å­¦å®šä¹‰** | \(F = \langle\psi\|\rho\|\psi\rangle\)ï¼ŒèŒƒå›´ [0, 1] |
| **å¹¿ä¹‰åŒ–** | ä» 2-qubit æ¨å¹¿åˆ°ä»»æ„ quditï¼š\(\|\Phi_{m,n}\rangle\) |
| **å·¥ç¨‹å®ç°** | æ¨¡å—åŒ–è®¾è®¡ã€å®¹é”™å¤„ç†ã€æ‰¹é‡åˆ†ææ”¯æŒ |
| **æ¶æ„é›†æˆ** | é¢†åŸŸå±‚åˆ†ææ¨¡å—ï¼Œå¯é€‰åœ°è¢«åº”ç”¨å±‚è°ƒç”¨ |
| **åº”ç”¨åœºæ™¯** | çº ç¼ æ€éªŒè¯ã€æ–¹æ³•å¯¹æ¯”ã€å†å²æ•°æ®åˆ†æ |

---

### å…³é”®å…¬å¼

```
[1] å¹¿ä¹‰ Bell æ€å®šä¹‰
    |Î¦_mnâŸ© = (1/âˆšd) Î£_k Ï‰^(mk) |k, (k+n) mod dâŸ©
    
[2] ä¿çœŸåº¦è®¡ç®—
    F(Ï, |ÏˆâŸ©) = âŸ¨Ïˆ|Ï|ÏˆâŸ© = Tr(Ï |ÏˆâŸ©âŸ¨Ïˆ|)
    
[3] æ­£äº¤å½’ä¸€æ€§
    âŸ¨Î¦_mn|Î¦_m'n'âŸ© = Î´_mm' Î´_nn'
    
[4] å®Œå¤‡æ€§
    Î£_(m,n) |Î¦_mnâŸ©âŸ¨Î¦_mn| = I
```

---

### è®¾è®¡äº®ç‚¹

```
âœ… ç‰©ç†æ­£ç¡®æ€§    â†’ ä¸¥æ ¼æŒ‰ç…§é‡å­ä¿¡æ¯ç†è®ºå®šä¹‰
âœ… æ•°å­¦ä¸¥è°¨æ€§    â†’ æ­£äº¤å½’ä¸€æ€§éªŒè¯ã€å®Œå¤‡æ€§ä¿è¯
âœ… å·¥ç¨‹é²æ£’æ€§    â†’ ç»´åº¦æ£€æŸ¥ã€å¼‚å¸¸å¤„ç†ã€å®¹é”™è®¾è®¡
âœ… æ€§èƒ½ä¼˜åŒ–      â†’ å‘é‡åŒ–è®¡ç®—ã€ç¼“å­˜åŸºçŸ¢
âœ… æ¥å£å‹å¥½æ€§    â†’ å¤šå±‚æ¬¡ APIï¼ˆå•ä¸ª/æ‰¹é‡/è®°å½•ï¼‰
âœ… æ¶æ„æ¸…æ™°æ€§    â†’ åˆ†å±‚è®¾è®¡ã€å•ä¸€èŒè´£
```

---

### ä½¿ç”¨å»ºè®®

| åœºæ™¯ | æ¨èæ–¹æ³• |
|-----|----------|
| **æ–°å®éªŒ** | `qtomography reconstruct --bell` |
| **å†å²æ•°æ®** | `qtomography bell-analyze` |
| **Python è„šæœ¬** | `analyze_density_matrix(rho)` |
| **æ‰¹é‡åˆ†æ** | `analyze_records(records)` |
| **è‡ªå®šä¹‰åˆ†æ** | ç›´æ¥ä½¿ç”¨ `generate_bell_basis` |

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ7æ—¥  
**ä½œè€…**: AI Assistant  
**éš¾åº¦ç­‰çº§**: ä¸­çº§åˆ°é«˜çº§

---

## âœ… å­¦ä¹ æ£€æŸ¥æ¸…å•

å­¦å®Œæœ¬æ–‡æ¡£åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] ç†è§£ Bell æ€çš„ç‰©ç†æ„ä¹‰å’Œé‡è¦æ€§
- [ ] æ¨å¯¼å¹¿ä¹‰ Bell æ€çš„æ•°å­¦è¡¨è¾¾å¼
- [ ] è®¡ç®—å¯†åº¦çŸ©é˜µä¸ Bell æ€çš„ä¿çœŸåº¦
- [ ] ä½¿ç”¨ `analyze_density_matrix` å‡½æ•°
- [ ] è§£é‡Š `bell_dominant_index` çš„ç‰©ç†å«ä¹‰
- [ ] åœ¨ CLI ä¸­ä½¿ç”¨ `--bell` å‚æ•°
- [ ] å¯¹å†å²æ•°æ®æ‰§è¡Œ `bell-analyze`
- [ ] è¯Šæ–­ä½ä¿çœŸåº¦çš„å¯èƒ½åŸå› 
- [ ] ç†è§£ Bell åˆ†æåœ¨åˆ†å±‚æ¶æ„ä¸­çš„ä½ç½®
- [ ] æ‰©å±• Bell åˆ†æåˆ°è‡ªå®šä¹‰åœºæ™¯

å¦‚æœä»¥ä¸Šéƒ½èƒ½åšåˆ°ï¼Œæ­å–œä½ å·²ç»æŒæ¡äº† Bell æ€åˆ†æçš„ç†è®ºä¸å®è·µï¼ğŸ‰
