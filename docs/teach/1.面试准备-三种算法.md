æˆ‘æ¥ä¸ºä½ å‡†å¤‡ä¸€ä¸ªå®Œæ•´çš„é¢è¯•æ–‡æ¡£ï¼Œæ¶µç›–ä¸‰ç§é‡å­æ€å±‚æé‡æ„ç­–ç•¥çš„æ ¸å¿ƒå†…å®¹ã€‚


[1 tool called]

# é‡å­æ€å±‚æé‡æ„ç­–ç•¥é¢è¯•æ–‡æ¡£

## ğŸ“‹ æ ¸å¿ƒå…¬å¼é€Ÿè®°è¡¨

### 1. çº¿æ€§é‡æ„
```
ÏÌ‚ = Î£áµ¢â‚Œâ‚â¿Â² (náµ¢/N) Máµ¢
```

### 2. WLS (åŠ æƒæœ€å°äºŒä¹˜)
```
min Î£áµ¢â‚Œâ‚â¿Â² (páµ¢ - pÌ‚áµ¢)Â² / pÌ‚áµ¢
```

### 3. æ ‡å‡†MLE (æœ€å¤§ä¼¼ç„¶ä¼°è®¡)
```
max âˆáµ¢â‚Œâ‚â¿Â² pÌ‚áµ¢â¿â±  â†’  min -Î£áµ¢â‚Œâ‚â¿Â² náµ¢ log(pÌ‚áµ¢)
```

### 4. å…³é”®ç¬¦å·
- `náµ¢`: ç¬¬iä¸ªæµ‹é‡åŸºçš„è§‚æµ‹è®¡æ•°
- `N`: æ€»æµ‹é‡æ¬¡æ•°
- `páµ¢ = náµ¢/N`: è§‚æµ‹æ¦‚ç‡
- `pÌ‚áµ¢ = Tr(ÏMáµ¢)`: ç†è®ºé¢„æµ‹æ¦‚ç‡
- `Máµ¢`: ç¬¬iä¸ªæµ‹é‡åŸºçš„æŠ•å½±ç®—ç¬¦

---

## ğŸ¯ é¢è¯•æ ¸å¿ƒè¦ç‚¹

### 1. çº¿æ€§é‡æ„ (Linear Reconstruction)

**æ ¸å¿ƒæ€æƒ³**ï¼šç›´æ¥è§£çº¿æ€§æ–¹ç¨‹ç»„

**å…¬å¼**ï¼š
```
ÏÌ‚ = Î£áµ¢â‚Œâ‚â¿Â² (náµ¢/N) Máµ¢
```

**æµç¨‹**ï¼š
1. å»ºç«‹çº¿æ€§æ–¹ç¨‹ç»„ï¼š`náµ¢/N = Tr(ÏMáµ¢)`
2. ç›´æ¥æ±‚è§£å¾—åˆ°å¯†åº¦çŸ©é˜µ
3. **ç‰©ç†åŒ–å¤„ç†**ï¼šè£å‰ªè´Ÿç‰¹å¾å€¼ï¼Œé‡æ–°å½’ä¸€åŒ–

**Pythonä»£ç **ï¼š
```python
import numpy as np
from scipy.linalg import eigh

def linear_reconstruction(counts, projectors):
    """
    çº¿æ€§é‡æ„å®ç°
    Args:
        counts: è§‚æµ‹è®¡æ•° [n1, n2, ..., n_n2]
        projectors: æµ‹é‡åŸºæŠ•å½±ç®—ç¬¦ [M1, M2, ..., M_n2]
    Returns:
        rho: é‡æ„çš„å¯†åº¦çŸ©é˜µ
    """
    N = np.sum(counts)  # æ€»æµ‹é‡æ¬¡æ•°
    probabilities = counts / N  # è§‚æµ‹æ¦‚ç‡
    
    # å»ºç«‹çº¿æ€§æ–¹ç¨‹ç»„ A * vec(rho) = b
    d = int(np.sqrt(len(projectors[0])))  # ç³»ç»Ÿç»´åº¦
    A = np.zeros((len(projectors), d**2), dtype=complex)
    b = probabilities
    
    for i, M_i in enumerate(projectors):
        A[i] = M_i.flatten()
    
    # æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„
    rho_vec = np.linalg.pinv(A) @ b
    rho = rho_vec.reshape(d, d)
    
    # ç‰©ç†åŒ–å¤„ç†
    rho = make_physical(rho)
    return rho

def make_physical(rho):
    """ç‰©ç†åŒ–å¤„ç†ï¼šè£å‰ªè´Ÿç‰¹å¾å€¼ï¼Œé‡æ–°å½’ä¸€åŒ–"""
    eigenvals, eigenvecs = eigh(rho)
    # è£å‰ªè´Ÿç‰¹å¾å€¼
    eigenvals = np.maximum(eigenvals, 0)
    # é‡æ–°æ„é€ å¯†åº¦çŸ©é˜µ
    rho_physical = eigenvecs @ np.diag(eigenvals) @ eigenvecs.conj().T
    # å½’ä¸€åŒ–
    rho_physical = rho_physical / np.trace(rho_physical)
    return rho_physical
```

**ä¼˜ç‚¹**ï¼š
- âœ… è®¡ç®—ç®€å•å¿«é€Ÿ
- âœ… æ— ä¼˜åŒ–è¿‡ç¨‹
- âœ… åœ¨æ— å™ªå£°æ—¶å®Œç¾æ‹Ÿåˆ

**ç¼ºç‚¹**ï¼š
- âŒ å¯èƒ½äº§ç”Ÿéç‰©ç†ç»“æœ
- âŒ ç‰©ç†åŒ–æŠ•å½±å¼•å…¥è¯¯å·®
- âŒ å¯¹å™ªå£°æ•æ„Ÿ

**å…³é”®ç‚¹**ï¼šç‰©ç†åŒ–æŠ•å½±æ˜¯**éçº¿æ€§æ“ä½œ**ï¼Œä¼šåç¦»æœ€ä¼˜è§£

---

### 2. WLS (åŠ æƒæœ€å°äºŒä¹˜æ³•)

**æ ¸å¿ƒæ€æƒ³**ï¼šåŠ æƒæœ€å°äºŒä¹˜ä¼˜åŒ–

**å…¬å¼**ï¼š
```
min Î£áµ¢â‚Œâ‚â¿Â² (páµ¢ - pÌ‚áµ¢)Â² / pÌ‚áµ¢
```

**åŠ æƒæœºåˆ¶**ï¼š
- é™¤ä»¥`pÌ‚áµ¢`ä½“ç°**æ³Šæ¾åˆ†å¸ƒç‰¹æ€§**
- å¯¹äºè®¡æ•°æ•°æ®ï¼š`Var(náµ¢) = Npáµ¢`
- æ ‡å‡†åŒ–è¯¯å·®ï¼š`(náµ¢ - Npáµ¢) / âˆš(Npáµ¢)`

**å‚æ•°åŒ–**ï¼š
```
Ï = LLâ€   (Choleskyåˆ†è§£)
```

**æµç¨‹**ï¼š
1. å°†å¯†åº¦çŸ©é˜µå‚æ•°åŒ–ä¸ºå®å‚æ•°
2. ä½¿ç”¨L-BFGS-Bç­‰ä¼˜åŒ–å™¨
3. è‡ªåŠ¨æ»¡è¶³ç‰©ç†çº¦æŸ

**Pythonä»£ç **ï¼š
```python
import numpy as np
from scipy.optimize import minimize

def wls_reconstruction(counts, projectors, max_iter=1000):
    """
    WLSé‡æ„å®ç°
    Args:
        counts: è§‚æµ‹è®¡æ•° [n1, n2, ..., n_n2]
        projectors: æµ‹é‡åŸºæŠ•å½±ç®—ç¬¦ [M1, M2, ..., M_n2]
        max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°
    Returns:
        rho: é‡æ„çš„å¯†åº¦çŸ©é˜µ
    """
    N = np.sum(counts)
    probabilities = counts / N
    d = int(np.sqrt(len(projectors[0])))
    
    # åˆå§‹åŒ–å‚æ•°
    params0 = np.random.randn(d**2) * 0.1
    
    # ä¼˜åŒ–
    result = minimize(
        fun=wls_objective,
        x0=params0,
        args=(probabilities, projectors),
        method='L-BFGS-B',
        options={'maxiter': max_iter}
    )
    
    # è§£ç ä¸ºå¯†åº¦çŸ©é˜µ
    rho = decode_params_to_density(result.x, d)
    return rho

def wls_objective(params, probabilities, projectors):
    """WLSç›®æ ‡å‡½æ•°ï¼šåŠ æƒæœ€å°äºŒä¹˜"""
    d = int(np.sqrt(len(projectors[0])))
    rho = decode_params_to_density(params, d)
    
    # è®¡ç®—ç†è®ºæ¦‚ç‡
    expected = np.array([np.real(np.trace(M @ rho)) for M in projectors])
    expected = np.clip(expected, 1e-12, None)  # é¿å…é™¤é›¶
    
    # åŠ æƒæœ€å°äºŒä¹˜
    diff = probabilities - expected
    chi2 = np.sum((diff ** 2) / expected)
    return chi2

def decode_params_to_density(params, dimension):
    """å°†å‚æ•°è§£ç ä¸ºå¯†åº¦çŸ©é˜µï¼ˆCholeskyåˆ†è§£ï¼‰"""
    params = np.asarray(params, dtype=float)
    if params.size != dimension ** 2:
        raise ValueError(f"å‚æ•°é•¿åº¦åº”ä¸º {dimension ** 2}")
    
    # æ„é€ ä¸‹ä¸‰è§’çŸ©é˜µL
    lower = np.zeros((dimension, dimension), dtype=complex)
    idx = 0
    for i in range(dimension):
        lower[i, i] = np.exp(params[idx])  # å¯¹è§’çº¿å…ƒç´ 
        idx += 1
        for j in range(i):
            real_part = params[idx]
            imag_part = params[idx + 1]
            lower[i, j] = real_part + 1j * imag_part
            idx += 2
    
    # æ„é€ å¯†åº¦çŸ©é˜µ Ï = LLâ€ 
    rho = lower @ lower.conj().T
    # å½’ä¸€åŒ–
    rho = rho / np.trace(rho)
    return rho
```

**ä¼˜ç‚¹**ï¼š
- âœ… ä¿è¯ç‰©ç†çº¦æŸ
- âœ… æ¯”çº¿æ€§é‡æ„æ›´å‡†ç¡®
- âœ… ä½“ç°æ³Šæ¾ç»Ÿè®¡ç‰¹æ€§

**ç¼ºç‚¹**ï¼š
- âŒ ä¸æ˜¯çœŸæ­£çš„MLE
- âŒ ä»åŸºäºæœ€å°äºŒä¹˜æ€æƒ³
- âŒ åœ¨æµ‹é‡æ¬¡æ•°å°‘æ—¶å¯èƒ½ä¸å¤Ÿå‡†ç¡®

**å…³é”®ç‚¹**ï¼šåŠ æƒè®©æ¯ä¸ªæµ‹é‡åŸº**åŒç­‰é‡è¦**ï¼Œä¸æ˜¯åŸºäºå™ªå£°å¤§å°

---

### 3. æ ‡å‡†MLE (æœ€å¤§ä¼¼ç„¶ä¼°è®¡)

**æ ¸å¿ƒæ€æƒ³**ï¼šåŸºäºå¤šé¡¹å¼åˆ†å¸ƒçš„æœ€å¤§ä¼¼ç„¶ä¼°è®¡

**æ¦‚ç‡æ¨¡å‹**ï¼š
```
P(nâ‚,nâ‚‚,...,n_{nÂ²}|Ï) = (N!/(nâ‚!nâ‚‚!...n_{nÂ²}!)) Ã— âˆáµ¢â‚Œâ‚â¿Â² pÌ‚áµ¢â¿â±
```

**ç›®æ ‡å‡½æ•°**ï¼š
```
max L(Ï) = max âˆáµ¢â‚Œâ‚â¿Â² pÌ‚áµ¢â¿â±
ç­‰ä»·äºï¼šmin -log L(Ï) = min -Î£áµ¢â‚Œâ‚â¿Â² náµ¢ log(pÌ‚áµ¢)
```

**çº¦æŸæ¡ä»¶**ï¼š
- `Ï â‰¥ 0` (æ­£å®šæ€§)
- `Tr(Ï) = 1` (å½’ä¸€åŒ–)
- `pÌ‚áµ¢ = Tr(ÏMáµ¢)` (é‡å­åŠ›å­¦çº¦æŸ)

**æµç¨‹**ï¼š
1. å»ºç«‹å¤šé¡¹å¼åˆ†å¸ƒä¼¼ç„¶å‡½æ•°
2. ä½¿ç”¨Choleskyåˆ†è§£å‚æ•°åŒ–
3. æ•°å€¼ä¼˜åŒ–æœ€å¤§åŒ–ä¼¼ç„¶

**Pythonä»£ç **ï¼š
```python
import numpy as np
from scipy.optimize import minimize

def mle_reconstruction(counts, projectors, max_iter=2000):
    """
    æ ‡å‡†MLEé‡æ„å®ç°
    Args:
        counts: è§‚æµ‹è®¡æ•° [n1, n2, ..., n_n2]
        projectors: æµ‹é‡åŸºæŠ•å½±ç®—ç¬¦ [M1, M2, ..., M_n2]
        max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°
    Returns:
        rho: é‡æ„çš„å¯†åº¦çŸ©é˜µ
    """
    d = int(np.sqrt(len(projectors[0])))
    
    # åˆå§‹åŒ–å‚æ•°
    params0 = np.random.randn(d**2) * 0.1
    
    # ä¼˜åŒ–ï¼ˆæœ€å°åŒ–è´Ÿå¯¹æ•°ä¼¼ç„¶ï¼‰
    result = minimize(
        fun=mle_objective,
        x0=params0,
        args=(counts, projectors),
        method='L-BFGS-B',
        options={'maxiter': max_iter}
    )
    
    # è§£ç ä¸ºå¯†åº¦çŸ©é˜µ
    rho = decode_params_to_density(result.x, d)
    return rho

def mle_objective(params, counts, projectors):
    """MLEç›®æ ‡å‡½æ•°ï¼šè´Ÿå¯¹æ•°ä¼¼ç„¶"""
    d = int(np.sqrt(len(projectors[0])))
    rho = decode_params_to_density(params, d)
    
    # è®¡ç®—ç†è®ºæ¦‚ç‡
    expected = np.array([np.real(np.trace(M @ rho)) for M in projectors])
    expected = np.clip(expected, 1e-12, None)  # é¿å…log(0)
    
    # è´Ÿå¯¹æ•°ä¼¼ç„¶
    log_likelihood = np.sum(counts * np.log(expected))
    return -log_likelihood  # æœ€å°åŒ–è´Ÿå¯¹æ•°ä¼¼ç„¶

def decode_params_to_density(params, dimension):
    """å°†å‚æ•°è§£ç ä¸ºå¯†åº¦çŸ©é˜µï¼ˆCholeskyåˆ†è§£ï¼‰"""
    params = np.asarray(params, dtype=float)
    if params.size != dimension ** 2:
        raise ValueError(f"å‚æ•°é•¿åº¦åº”ä¸º {dimension ** 2}")
    
    # æ„é€ ä¸‹ä¸‰è§’çŸ©é˜µL
    lower = np.zeros((dimension, dimension), dtype=complex)
    idx = 0
    for i in range(dimension):
        lower[i, i] = np.exp(params[idx])  # å¯¹è§’çº¿å…ƒç´ 
        idx += 1
        for j in range(i):
            real_part = params[idx]
            imag_part = params[idx + 1]
            lower[i, j] = real_part + 1j * imag_part
            idx += 2
    
    # æ„é€ å¯†åº¦çŸ©é˜µ Ï = LLâ€ 
    rho = lower @ lower.conj().T
    # å½’ä¸€åŒ–
    rho = rho / np.trace(rho)
    return rho

# å¸¦æ­£åˆ™åŒ–çš„MLEç‰ˆæœ¬
def mle_reconstruction_regularized(counts, projectors, lambda_reg=0.01, max_iter=2000):
    """å¸¦æ­£åˆ™åŒ–çš„MLEé‡æ„"""
    d = int(np.sqrt(len(projectors[0])))
    params0 = np.random.randn(d**2) * 0.1
    
    result = minimize(
        fun=lambda params: mle_objective_regularized(params, counts, projectors, lambda_reg),
        x0=params0,
        method='L-BFGS-B',
        options={'maxiter': max_iter}
    )
    
    rho = decode_params_to_density(result.x, d)
    return rho

def mle_objective_regularized(params, counts, projectors, lambda_reg):
    """å¸¦æ­£åˆ™åŒ–çš„MLEç›®æ ‡å‡½æ•°"""
    d = int(np.sqrt(len(projectors[0])))
    rho = decode_params_to_density(params, d)
    
    # è®¡ç®—ç†è®ºæ¦‚ç‡
    expected = np.array([np.real(np.trace(M @ rho)) for M in projectors])
    expected = np.clip(expected, 1e-12, None)
    
    # è´Ÿå¯¹æ•°ä¼¼ç„¶
    log_likelihood = np.sum(counts * np.log(expected))
    
    # L2æ­£åˆ™åŒ–é¡¹
    regularization = lambda_reg * np.sum(params ** 2)
    
    return -log_likelihood + regularization
```

**ä¼˜ç‚¹**ï¼š
- âœ… ç»Ÿè®¡ä¸Šæœ€ä¸¥æ ¼
- âœ… åŸºäºæ­£ç¡®çš„æ¦‚ç‡æ¨¡å‹
- âœ… åœ¨æµ‹é‡æ¬¡æ•°å°‘æ—¶æœ€å‡†ç¡®
- âœ… å¯ä»¥åŠ å…¥æ­£åˆ™åŒ–
- âœ… æä¾›ä¸ç¡®å®šæ€§ä¼°è®¡

**ç¼ºç‚¹**ï¼š
- âŒ è®¡ç®—å¤æ‚åº¦æœ€é«˜
- âŒ éœ€è¦æ•°å€¼ä¼˜åŒ–
- âŒ å¯èƒ½é™·å…¥å±€éƒ¨æœ€ä¼˜

**å…³é”®ç‚¹**ï¼šè¿™æ˜¯**ç»Ÿè®¡æ¨æ–­**ï¼Œä¸æ˜¯ç®€å•çš„æ‹Ÿåˆ

---

## ğŸ“Š ä¸‰ç§æ–¹æ³•å¯¹æ¯”

| ç‰¹å¾ | çº¿æ€§é‡æ„ | WLS | æ ‡å‡†MLE |
|------|----------|-----|---------|
| **ç›®æ ‡å‡½æ•°** | `ÏÌ‚ = Î£áµ¢ (náµ¢/N) Máµ¢` | `min Î£áµ¢ (páµ¢ - pÌ‚áµ¢)Â² / pÌ‚áµ¢` | `max âˆáµ¢ pÌ‚áµ¢â¿â±` |
| **æ¦‚ç‡æ¨¡å‹** | æ—  | å¯å‘å¼ | å¤šé¡¹å¼åˆ†å¸ƒ |
| **æ±‚è§£æ–¹å¼** | ç›´æ¥è®¡ç®— | æ•°å€¼ä¼˜åŒ– | æ•°å€¼ä¼˜åŒ– |
| **ç‰©ç†çº¦æŸ** | åå¤„ç† | å‚æ•°åŒ–ä¿è¯ | å‚æ•°åŒ–ä¿è¯ |
| **è®¡ç®—å¤æ‚åº¦** | O(1) | O(è¿­ä»£æ¬¡æ•°) | O(è¿­ä»£æ¬¡æ•°) |
| **ç»Ÿè®¡æ€§è´¨** | æ— åä½†å¯èƒ½éç‰©ç† | æœ‰åä½†ç‰©ç† | æ— åä¸”ç‰©ç† |
| **æµ‹é‡æ¬¡æ•°å°‘æ—¶** | ç²¾åº¦ä½ | ç²¾åº¦ä¸­ç­‰ | ç²¾åº¦æœ€é«˜ |

---

## ğŸ” è´¨é‡è¯„ä¼°æŒ‡æ ‡

### Ï‡Â²ç»Ÿè®¡é‡
```
Ï‡Â² = Î£áµ¢ (náµ¢ - NpÌ‚áµ¢)Â² / (NpÌ‚áµ¢)
```

**åˆ¤æ–­æ ‡å‡†**ï¼š
- **Ï‡Â² â‰ˆ è‡ªç”±åº¦**ï¼šæ‹Ÿåˆè‰¯å¥½
- **Ï‡Â² << è‡ªç”±åº¦**ï¼šå¯èƒ½æ•°å€¼é—®é¢˜
- **Ï‡Â² >> è‡ªç”±åº¦**ï¼šæ¨¡å‹ä¸åŒ¹é…

**è‡ªç”±åº¦**ï¼š`nÂ² - dÂ²`

### å¯¹æ•°ä¼¼ç„¶
```
log L(Ï) = Î£áµ¢ náµ¢ log(pÌ‚áµ¢)
```
- å€¼è¶Šå¤§è¶Šå¥½
- ç”¨äºæ¯”è¾ƒä¸åŒæ¨¡å‹

**Pythonä»£ç **ï¼š
```python
def evaluate_reconstruction(rho, counts, projectors):
    """
    è¯„ä¼°é‡æ„è´¨é‡
    Args:
        rho: é‡æ„çš„å¯†åº¦çŸ©é˜µ
        counts: è§‚æµ‹è®¡æ•°
        projectors: æµ‹é‡åŸºæŠ•å½±ç®—ç¬¦
    Returns:
        dict: åŒ…å«å„ç§è¯„ä¼°æŒ‡æ ‡
    """
    N = np.sum(counts)
    probabilities = counts / N
    
    # è®¡ç®—ç†è®ºæ¦‚ç‡
    expected = np.array([np.real(np.trace(M @ rho)) for M in projectors])
    expected = np.clip(expected, 1e-12, None)
    
    # Ï‡Â²ç»Ÿè®¡é‡
    chi2 = np.sum((counts - N * expected) ** 2 / (N * expected))
    
    # è‡ªç”±åº¦
    d = int(np.sqrt(len(projectors[0])))
    dof = len(projectors) - d**2
    
    # å¯¹æ•°ä¼¼ç„¶
    log_likelihood = np.sum(counts * np.log(expected))
    
    # æ‹Ÿåˆè´¨é‡åˆ¤æ–­
    if abs(chi2 - dof) < 0.1 * dof:
        fit_quality = "excellent"
    elif chi2 < dof:
        fit_quality = "good (possibly over-regularized)"
    else:
        fit_quality = "poor (model mismatch)"
    
    return {
        'chi2': chi2,
        'dof': dof,
        'chi2_per_dof': chi2 / dof,
        'log_likelihood': log_likelihood,
        'fit_quality': fit_quality,
        'probabilities_obs': probabilities,
        'probabilities_exp': expected
    }

def calculate_chi2(counts, rho, projectors):
    """è®¡ç®—Ï‡Â²ç»Ÿè®¡é‡"""
    N = np.sum(counts)
    expected = np.array([np.real(np.trace(M @ rho)) for M in projectors])
    expected = np.clip(expected, 1e-12, None)
    chi2 = np.sum((counts - N * expected) ** 2 / (N * expected))
    return chi2

def calculate_log_likelihood(counts, rho, projectors):
    """è®¡ç®—å¯¹æ•°ä¼¼ç„¶"""
    expected = np.array([np.real(np.trace(M @ rho)) for M in projectors])
    expected = np.clip(expected, 1e-12, None)
    log_likelihood = np.sum(counts * np.log(expected))
    return log_likelihood
```

---

## ğŸ¯ é¢è¯•å›ç­”æ¨¡æ¿

### é—®é¢˜1ï¼šè¯·ä»‹ç»ä½ çš„é‡å­æ€å±‚æé¡¹ç›®

**å›ç­”**ï¼š
"æˆ‘çš„é¡¹ç›®å®ç°äº†ä¸‰ç§é‡å­æ€å±‚æé‡æ„ç­–ç•¥ã€‚é¦–å…ˆæ˜¯çº¿æ€§é‡æ„ï¼Œç›´æ¥è§£çº¿æ€§æ–¹ç¨‹ç»„å¾—åˆ°å¯†åº¦çŸ©é˜µï¼Œä½†éœ€è¦ç‰©ç†åŒ–å¤„ç†ã€‚ç¬¬äºŒç§æ˜¯WLSï¼Œé€šè¿‡åŠ æƒæœ€å°äºŒä¹˜ä¼˜åŒ–ï¼Œä½“ç°äº†æ³Šæ¾ç»Ÿè®¡ç‰¹æ€§ã€‚ç¬¬ä¸‰ç§æ˜¯æ ‡å‡†MLEï¼ŒåŸºäºå¤šé¡¹å¼åˆ†å¸ƒçš„æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼Œåœ¨æµ‹é‡æ¬¡æ•°å°‘æ—¶æœ€å‡†ç¡®ã€‚"

### é—®é¢˜2ï¼šä¸‰ç§æ–¹æ³•æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**å›ç­”**ï¼š
"çº¿æ€§é‡æ„æœ€ç®€å•ä½†å¯èƒ½ä¸ç‰©ç†ï¼ŒWLSé€šè¿‡åŠ æƒå¤„ç†æ³Šæ¾å™ªå£°ï¼ŒMLEåŸºäºæ­£ç¡®çš„ç»Ÿè®¡æ¨¡å‹ã€‚å…³é”®åŒºåˆ«æ˜¯ï¼šçº¿æ€§é‡æ„æ˜¯ç›´æ¥è®¡ç®—ï¼ŒWLSæ˜¯å¯å‘å¼ä¼˜åŒ–ï¼ŒMLEæ˜¯ç»Ÿè®¡æ¨æ–­ã€‚åœ¨æµ‹é‡æ¬¡æ•°å°‘æ—¶ï¼ŒMLEæœ€å‡†ç¡®ã€‚"

### é—®é¢˜3ï¼šä¸ºä»€ä¹ˆéœ€è¦åŠ æƒï¼Ÿ

**å›ç­”**ï¼š
"åŠ æƒä½“ç°äº†æ³Šæ¾åˆ†å¸ƒç‰¹æ€§ã€‚å¯¹äºè®¡æ•°æ•°æ®ï¼Œæ–¹å·®ç­‰äºå‡å€¼ï¼Œæ‰€ä»¥æ ‡å‡†åŒ–è¯¯å·®æ˜¯(náµ¢ - Npáµ¢)/âˆš(Npáµ¢)ï¼Œå¹³æ–¹åå°±æ˜¯(páµ¢ - pÌ‚áµ¢)Â²/pÌ‚áµ¢ã€‚è¿™æ ·è®©æ¯ä¸ªæµ‹é‡åŸºåŒç­‰é‡è¦ï¼Œä¸æ˜¯åŸºäºå™ªå£°å¤§å°ã€‚"

### é—®é¢˜4ï¼šMLEçš„ä¼˜åŠ¿æ˜¯ä»€ä¹ˆï¼Ÿ

**å›ç­”**ï¼š
"MLEåŸºäºå¤šé¡¹å¼åˆ†å¸ƒçš„ä¸¥æ ¼ç»Ÿè®¡æ¨¡å‹ï¼Œåœ¨æµ‹é‡æ¬¡æ•°å°‘æ—¶ç»Ÿè®¡æœ€ä¼˜ã€‚å®ƒä¸æ˜¯ç®€å•çš„æ‹Ÿåˆï¼Œè€Œæ˜¯ç»Ÿè®¡æ¨æ–­ï¼Œèƒ½æä¾›ä¸ç¡®å®šæ€§ä¼°è®¡ã€‚é€šè¿‡Choleskyåˆ†è§£å‚æ•°åŒ–ï¼Œè‡ªåŠ¨æ»¡è¶³ç‰©ç†çº¦æŸã€‚"

---

## ğŸš€ å¿«é€Ÿè®°å¿†å£è¯€

**çº¿æ€§é‡æ„**ï¼šç›´æ¥æ±‚è§£ï¼Œç‰©ç†åŒ–å¤„ç†
**WLS**ï¼šåŠ æƒä¼˜åŒ–ï¼Œæ³Šæ¾ç‰¹æ€§
**MLE**ï¼šç»Ÿè®¡æ¨æ–­ï¼Œå¤šé¡¹å¼åˆ†å¸ƒ

**å…³é”®å…¬å¼**ï¼š
- çº¿æ€§ï¼š`ÏÌ‚ = Î£áµ¢ (náµ¢/N) Máµ¢`
- WLSï¼š`min Î£áµ¢ (páµ¢ - pÌ‚áµ¢)Â² / pÌ‚áµ¢`
- MLEï¼š`max âˆáµ¢ pÌ‚áµ¢â¿â±`

**åˆ¤æ–­æ ‡å‡†**ï¼šÏ‡Â² â‰ˆ è‡ªç”±åº¦

---

## ğŸ’¡ é¢è¯•æŠ€å·§

1. **å…ˆç”»å…¬å¼**ï¼šåœ¨çº¸ä¸Šå†™å‡ºæ ¸å¿ƒå…¬å¼
2. **è§£é‡Šç‰©ç†æ„ä¹‰**ï¼šæ¯ç§æ–¹æ³•çš„ç‰©ç†èƒŒæ™¯
3. **å¯¹æ¯”åˆ†æ**ï¼šä¸‰ç§æ–¹æ³•çš„ä¼˜ç¼ºç‚¹
4. **å®é™…åº”ç”¨**ï¼šä»€ä¹ˆæƒ…å†µä¸‹ç”¨ä»€ä¹ˆæ–¹æ³•
5. **æŠ€æœ¯ç»†èŠ‚**ï¼šå‚æ•°åŒ–ã€ä¼˜åŒ–ã€çº¦æŸå¤„ç†

**è®°ä½**ï¼šè¿™æ˜¯**ç‰©ç†å‚æ•°ä¼°è®¡**é—®é¢˜ï¼Œä¸æ˜¯æœºå™¨å­¦ä¹ é—®é¢˜ï¼

---

## ğŸš€ å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

```python
import numpy as np

# ç¤ºä¾‹ï¼š2ç»´é‡å­æ€å±‚æ
def demo_quantum_tomography():
    """å®Œæ•´çš„é‡å­æ€å±‚æç¤ºä¾‹"""
    
    # 1. å‡†å¤‡æµ‹é‡åŸºï¼ˆPauliåŸºï¼‰
    def get_pauli_basis():
        """è·å–2ç»´ç³»ç»Ÿçš„Pauliæµ‹é‡åŸº"""
        I = np.array([[1, 0], [0, 1]], dtype=complex)
        X = np.array([[0, 1], [1, 0]], dtype=complex)
        Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
        Z = np.array([[1, 0], [0, -1]], dtype=complex)
        
        # æŠ•å½±ç®—ç¬¦
        projectors = [
            (I + Z) / 2,  # |0âŸ©âŸ¨0|
            (I - Z) / 2,  # |1âŸ©âŸ¨1|
            (I + X) / 2,  # |+âŸ©âŸ¨+|
            (I - X) / 2,  # |-âŸ©âŸ¨-|
        ]
        return projectors
    
    # 2. ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
    def generate_test_data(true_rho, projectors, N=1000):
        """ç”Ÿæˆæµ‹è¯•æ•°æ®"""
        # è®¡ç®—ç†è®ºæ¦‚ç‡
        true_probs = np.array([np.real(np.trace(M @ true_rho)) for M in projectors])
        
        # ç”Ÿæˆæ³Šæ¾åˆ†å¸ƒè®¡æ•°
        counts = np.random.poisson(N * true_probs)
        return counts
    
    # 3. è®¾ç½®çœŸå®å¯†åº¦çŸ©é˜µ
    true_rho = np.array([[0.7, 0.3], [0.3, 0.3]], dtype=complex)
    true_rho = true_rho / np.trace(true_rho)  # å½’ä¸€åŒ–
    
    # 4. è·å–æµ‹é‡åŸºå’Œç”Ÿæˆæ•°æ®
    projectors = get_pauli_basis()
    counts = generate_test_data(true_rho, projectors, N=1000)
    
    print("=== é‡å­æ€å±‚æé‡æ„ç¤ºä¾‹ ===")
    print(f"çœŸå®å¯†åº¦çŸ©é˜µ:\n{true_rho}")
    print(f"è§‚æµ‹è®¡æ•°: {counts}")
    
    # 5. ä¸‰ç§æ–¹æ³•é‡æ„
    print("\n=== çº¿æ€§é‡æ„ ===")
    rho_linear = linear_reconstruction(counts, projectors)
    print(f"çº¿æ€§é‡æ„ç»“æœ:\n{rho_linear}")
    
    print("\n=== WLSé‡æ„ ===")
    rho_wls = wls_reconstruction(counts, projectors)
    print(f"WLSé‡æ„ç»“æœ:\n{rho_wls}")
    
    print("\n=== MLEé‡æ„ ===")
    rho_mle = mle_reconstruction(counts, projectors)
    print(f"MLEé‡æ„ç»“æœ:\n{rho_mle}")
    
    # 6. è´¨é‡è¯„ä¼°
    print("\n=== è´¨é‡è¯„ä¼° ===")
    methods = {
        'Linear': rho_linear,
        'WLS': rho_wls,
        'MLE': rho_mle
    }
    
    for name, rho in methods.items():
        metrics = evaluate_reconstruction(rho, counts, projectors)
        print(f"\n{name}æ–¹æ³•:")
        print(f"  Ï‡Â² = {metrics['chi2']:.3f}")
        print(f"  è‡ªç”±åº¦ = {metrics['dof']}")
        print(f"  Ï‡Â²/è‡ªç”±åº¦ = {metrics['chi2_per_dof']:.3f}")
        print(f"  å¯¹æ•°ä¼¼ç„¶ = {metrics['log_likelihood']:.3f}")
        print(f"  æ‹Ÿåˆè´¨é‡: {metrics['fit_quality']}")
    
    return true_rho, rho_linear, rho_wls, rho_mle

# è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    true_rho, rho_linear, rho_wls, rho_mle = demo_quantum_tomography()
```

**é¢è¯•æ—¶å¯ä»¥ç›´æ¥è¿è¡Œè¿™ä¸ªç¤ºä¾‹æ¥æ¼”ç¤ºä¸‰ç§æ–¹æ³•ï¼**