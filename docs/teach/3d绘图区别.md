现有 Python 里的 3D 图（**ReconstructionVisualizer.plot_real_imag_3d** / **plot_amplitude_phase**）其实和 MATLAB 脚本用的是两套完全不同的数据结构：

| Python 3D 图                                                                                                        | MATLAB plot_amplitude_and_phase.m                                                                   |
| ------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| 输入的是**密度矩阵** **ρ**（二维矩阵，维度 d×d），每个元素是复数                                      | 输入的是**系数向量** **c = r·e^{iφ}**（一维数组，每个条目是复系数）                   |
| X/Y 轴是密度矩阵的行列基索引；每个柱子代表**ρ_{ij}** 的某个属性                                              | X 轴是第几个系数**c_i**；每个柱子只表示一个系数                                               |
| **plot_real_imag_3d**：左图是实部 **Re(ρ_{ij})**，右图是虚部 **Im(ρ_{ij})**；把整个矩阵铺成网格 | 第一幅**bar(r)** 显示模长；第二幅 **bar(mod(φ,2π))** 显示相位（范围 0~2π），只有一维 |
| **plot_amplitude_phase**：第一幅柱图是 `                                                                      | ρ_{ij}                                                                                             |
| 颜色都是固定的（**#1f77b4**、**#ff7f0e**），没有相位环状色条                                            | 典型脚本也只是蓝色柱子，但 y 轴单位是 radians，直接对应**phi**                                |

所以「现有 3D 图」更像是把密度矩阵的所有条目可视化；而 MATLAB 脚本只是对某个向量 **c** 做双柱状图分析（幅度 + 相位），用途不同。

如果你要的就是 MATLAB 那种“针对系数向量的 3D 柱状图”，需要另外写一个函数，先把 **c** 的模/相位算出来，再用 Matplotlib 的 **bar**/**bar3d** 跟 MATLAB 同样的刻度、范围去画；不会直接复用现有的密度矩阵图。
