# 线性重构 (Linear Reconstruction)

> **教学文档**：理解量子态层析中的线性重构算法  
> **适用对象**：需要理解线性重构原理的开发者  
> **前置知识**：线性代数基础、量子力学基础

---

## 📚 概述

线性重构是三种重构方法中**最直观、最基础**的一种。它既不像 RρR 那样关心"最大似然概率"，也不像 WLS 那样关心"最小化卡方误差"。

**核心目标**：把量子层析问题，变回一个我们最熟悉的数学问题：**解方程 $A\vec{x} = \vec{b}$**。

---

## 🎯 核心目标：梦回高中数学——解线性方程组

线性重构的思路是所有方法中最简单直接的。它的目标是：**把量子层析问题，变回一个我们最熟悉的数学问题：解方程 $A\vec{x} = \vec{b}$**。

---

## 📈 如何把"量子问题"变成"线性方程"？

### 1. 未知数 $\vec{x}$ 是什么？

- 我们要找的是 $d \times d$ 的密度矩阵 $\rho$。
- 一个 $d \times d$ 的厄米矩阵可以由 $d^2$ 个实数来唯一确定。
- 我们可以把这个 $\rho$ 矩阵"拉直"（Vectorize），变成一个长长的、包含 $d^2$ 个元素的**未知向量 $\vec{\rho}_{vec}$**。（这就是我们的 $\vec{x}$）
- （在您的代码中，`rho_vec` 就是这个向量）。

### 2. 已知结果 $\vec{b}$ 是什么？

- 这就是我们从实验中测量的**频率（或概率）向量 $P$**。
- （在您的代码中，`probs` 就是这个向量 $\vec{b}$）。

### 3. 系数矩阵 $A$ 是什么？

- 这是最关键的一步。我们需要一个"测量矩阵" $M$ (Measurement Matrix)，它能把"密度矩阵 $\rho$" 和"测量概率 $P$" 联系起来。
- 量子力学告诉我们：$p_j = \text{Tr}(\rho M_j)$。
- 这个 $\text{Tr}$ (Trace，迹) 运算，对于 $\rho$ 来说是一个**线性运算**。
- 因此，我们可以构建一个"大"矩阵 $M$，它的**每一行**都对应于"计算第 $j$ 个概率"这个操作。
- 这个 $M$ 就是我们的系数矩阵 $A$。
- （在您的代码中，`self.projector_set.measurement_matrix` 就是这个矩阵 $A$）。

---

## ⚙️ 算法核心：$M \vec{\rho}_{vec} = P$

现在，我们的量子层析问题被彻底转换成了一个标准的线性代数问题：

$$
M \vec{\rho}_{vec} = P
$$

其中：

- $M$ (Measurement Matrix): **已知**。 (代码中的 `measurement_matrix`)
- $P$ (Probabilities Vector): **已知**。 (代码中的 `probs`)
- $\vec{\rho}_{vec}$ (Density Vector): **未知**。 (代码中的 `rho_vec`)

**我们该如何求解 $\vec{\rho}_{vec}$？**

---

## 🔁 算法执行：`np.linalg.lstsq` (最小二乘法)

这正是 `numpy.linalg.lstsq` (Least Squares) 函数的拿手好戏。

```python
rho_vec = np.linalg.lstsq(M, P)
```

这个函数会找到一个 $\vec{\rho}_{vec}$，使得 $M \vec{\rho}_{vec}$ 的结果与 $P$ 尽可能地接近，即使 $P$ 中充满了实验噪声。它在数学上最小化了误差 $\| M \vec{\rho}_{vec} - P \|^2$。

**特点**：

- **没有迭代**：与 RρR 不同，这是一个"一步到位"的直接解法。
- **没有复杂参数化**：与 WLS 不同，这里不需要 Cholesky 分解。

---

## 🛡️ 正则化 (Regularization)：岭回归

**代码中的"正则化"是什么？**

```python
if self.regularization is not None:
    # 使用岭回归
```

这是 `lstsq` 的一种"更稳定"的版本，称为**岭回归 (Ridge Regression)**。

### 问题

有时候 $M$ 矩阵"条件很差"（ill-conditioned，比如某些行非常相似），导致 `lstsq` 对噪声特别敏感，解出一个"疯了"的 $\rho$。

### 解决方案

我们不去解 $M \vec{\rho}_{vec} = P$，而是解一个稍微修改过的、更稳定的方程：

$$
(M^T M + \lambda I) \vec{\rho}_{vec} = M^T P
$$

其中：

- $\lambda$ (lambda) 就是 `self.regularization` 参数。
- 这只是为了让求解过程在数值上**更稳定**。

---

## 💡 最大的隐患：解是"非物理"的！

线性重构虽然**简单、快速**，但它有一个**致命的缺点**：

**它解出来的 $\rho$ 矩阵（由 `rho_vec` 重塑而来）不保证是一个物理上合法的密度矩阵！**

由于实验噪声 $P$ 的存在，`lstsq` 解出的 `rho_matrix_raw` 很可能：

1. **不满足 $\text{Tr}(\rho) = 1$** （迹不为1）
2. **不满足 $\rho \ge 0$** （可能出现负的特征值）

**WLS 和 RρR 算法是通过它们的设计（Cholesky 和 $R \rho R$ 迭代）来*保证*物理性的。**

而线性重构**完全不保证**物理性。

---

## 🔧 "事后补救"：强行物理化

线性重构是怎么解决这个问题的呢？——**事后补救**。

1. 代码首先解出那个原始的、可能是"非物理"的 `rho_matrix_raw`。
2. 然后，它把这个"坏"矩阵扔给 `DensityMatrix` 类。
3. `DensityMatrix` 类会（根据 `enforce` 设置）**强行**修正它，比如：
   - 找到所有负的特征值，把它们**手动改成 0**。
   - 重新调整所有特征值，让它们的**总和（迹）等于 1**。

这个"先解出非物理态，再强行修正"的过程，就是线性重构的标志。

---

## 📊 算法对比总结

现在我们集齐了三种方法，可以做个对比了：

| 特性 | **1. 线性重构 (Linear)** | **2. 加权最小二乘 (WLS)** | **3. RρR Strict** |
| :--- | :--- | :--- | :--- |
| **哲学** | **线性代数**（解方程） | **数值优化**（最小化误差） | **概率论**（最大化似然） |
| **核心** | $P = M \vec{\rho}_{vec}$ | 最小化 $\chi^2(\text{params})$ | $R \rho R$ 迭代 |
| **物理性** | **不保证** (需"事后补救") | **保证** (通过 Cholesky 参数化) | **保证** (通过 $R \rho R$ 结构) |
| **速度** | **最快** (一步求解) | **快** (依赖高效优化器) | **较慢** (依赖迭代收敛) |
| **场景** | 适合作为*初始猜测* | 优秀的通用算法 | 黄金标准（理论上最好） |

**总结**：

- 线性重构（Linear）是"最天真"的方法
- WLS 是"最实用"的优化方法
- RρR Strict 则是"理论上最完美"的统计方法

---

## 💻 代码实现要点

### 关键代码位置

```python
# qtomography/domain/reconstruction/linear.py

def reconstruct_with_details(self, probabilities):
    # 1. 归一化概率（按组）
    probs = self._normalize_probabilities_grouped(probabilities)
    
    # 2. 获取测量矩阵
    measurement_matrix = self.projector_set.measurement_matrix
    
    # 3. 最小二乘求解或岭回归
    if self.regularization is None:
        rho_vec, residuals, rank, singular_values = np.linalg.lstsq(
            measurement_matrix, probs, rcond=None
        )
    else:
        # 岭回归: (M^T M + λ I) rho_vec = M^T P
        mtm = measurement_matrix.T @ measurement_matrix
        rho_vec = np.linalg.solve(mtm + self.regularization * I, M.T @ probs)
    
    # 4. 重构密度矩阵
    rho_matrix = rho_vec.reshape(self.dimension, self.dimension).conj()
    
    # 5. 物理化处理（事后补救）
    density = DensityMatrix(rho_matrix, tolerance=self.tolerance, ...)
    
    return LinearReconstructionResult(...)
```

### 关键参数

- `regularization`: 可选的正则化系数 $\lambda$，用于岭回归
- `tolerance`: 数值容差，用于物理化处理
- `density_enforce`: 物理化策略（`"within_tol"`, `"project"`, `"none"`）

---

## ⚠️ 注意事项

1. **物理性不保证**：线性重构的结果可能不满足物理约束，需要后续物理化处理。
2. **数值稳定性**：当测量矩阵条件数很大时，建议使用正则化（岭回归）。
3. **适用场景**：适合作为其他算法的初始猜测，或对速度要求极高的场景。

---

## 📖 相关文档

- [WLS算法](./WLS算法.md) - 加权最小二乘重构
- [RρR算法](./RρR算法.md) - RρR Strict重构
- [密度矩阵物理化](../density公式教学.md) - 物理化处理详解
