# é¢è¯•å‡†å¤‡ - é‡å­æ€å±‚æé‡æ„é¡¹ç›®è¯¦è§£ä¸æŠ€æœ¯è¦ç‚¹

> **ç›®æ ‡å²—ä½**ï¼šè½¯ä»¶å¼€å‘å·¥ç¨‹å¸ˆ  
> **é¡¹ç›®åç§°**ï¼šQTomography - é‡å­æ€å±‚æé‡æ„å·¥å…·åŒ…  
> **æŠ€æœ¯æ ˆ**ï¼šPython 3.9+, NumPy, SciPy, Pandas, Matplotlib, Pytest  
> **é¢è¯•æ—¥æœŸ**ï¼š2025-10-10 ğŸ”¥ğŸ”¥ğŸ”¥  
> **æœ€åæ›´æ–°**ï¼š2025-10-08ï¼ˆStage 3 å…¨éƒ¨å®Œæˆï¼‰

---

## â° ç´§æ€¥æé†’ï¼šæ˜å¤©é¢è¯•ï¼

### ä»Šå¤©å¿…é¡»å®Œæˆçš„å‡†å¤‡ï¼ˆ2025-10-09ï¼‰

**ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰**ï¼š
1. **é€šè¯»æœ¬æ–‡æ¡£ 1-2 é**ï¼Œé‡ç‚¹è®°å¿†å…³é”®æ•°å­—å’Œé¡¹ç›®äº®ç‚¹
2. **ç»ƒä¹  3 åˆ†é’Ÿé¡¹ç›®ä»‹ç»**ï¼Œè‡³å°‘ç»ƒä¹  5 éï¼Œç›´åˆ°æµç•…è‡ªç„¶
3. **ç†Ÿè®°å¿«é€Ÿå¤ä¹ å¡ç‰‡**ï¼ˆæ–‡æ¡£æœ«å°¾ï¼‰ï¼Œèƒ½è„±ç¨¿å›ç­”

**ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰**ï¼š
4. **å¤ä¹  Python å…«è‚¡æ–‡**ï¼šGILã€åƒåœ¾å›æ”¶ã€è£…é¥°å™¨ã€æ·±æµ…æ‹·è´
5. **å¤ä¹  OOP å’Œè®¾è®¡æ¨¡å¼**ï¼šSOLID åŸåˆ™ + 4ç§è®¾è®¡æ¨¡å¼çš„é¡¹ç›®ä¾‹å­
6. **å‡†å¤‡è¡Œä¸ºé¢è¯•é—®é¢˜**ï¼šæŠ€æœ¯éš¾ç‚¹ã€å›¢é˜Ÿåä½œã€å­¦ä¹ èƒ½åŠ›

**æ™šä¸Šï¼ˆ2å°æ—¶ï¼‰**ï¼š
7. **æ¨¡æ‹Ÿé¢è¯•**ï¼šå¯¹ç€é•œå­ç»ƒä¹ è‡ªæˆ‘ä»‹ç»å’Œå¸¸è§é—®é¢˜
8. **æœ€åæ£€æŸ¥**ï¼šç¡®è®¤æ‰€æœ‰å…³é”®æ•°å­—ï¼ˆ106æµ‹è¯•ã€90%è¦†ç›–ç‡ã€10å€æå‡ã€1e-10ç²¾åº¦ï¼‰
9. **å‡†å¤‡é—®é¢˜**ï¼šå‡†å¤‡ 2-3 ä¸ªç»™é¢è¯•å®˜çš„é—®é¢˜

### ğŸ¯ æœ€é‡è¦çš„ 5 ä¸ªæ•°å­—ï¼ˆå¿…é¡»è®°ä½ï¼‰
1. **5000 è¡Œä»£ç **
2. **106 ä¸ªæµ‹è¯•ç”¨ä¾‹**ï¼ˆ100% é€šè¿‡ï¼‰
3. **90% æµ‹è¯•è¦†ç›–ç‡**
4. **10 å€æ€§èƒ½æå‡**ï¼ˆ50s â†’ 5sï¼‰
5. **1e-10 æ•°å€¼ç²¾åº¦**ï¼ˆä¸ MATLAB å¯¹é½ï¼‰

### ğŸ’¡ æœ€é‡è¦çš„ 3 ä¸ªæŠ€æœ¯äº®ç‚¹ï¼ˆé¢è¯•å¿…è¯´ï¼‰
1. **æ€§èƒ½ä¼˜åŒ–**ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜ â†’ 10å€æå‡
2. **æ•°å€¼ç¨³å®šæ€§**ï¼šmakephysical ç®—æ³• + å²­å›å½’
3. **Stage 3 å®Œæˆ**ï¼š8ä¸ªæ–°å­—æ®µ + comparisonæ¨¡å—(99è¡Œ) + æ–¹æ³•å¯¹æ¯”

---

## ğŸ“š ç›®å½•

1. [é¡¹ç›®ä¸€å¥è¯ä»‹ç»](#é¡¹ç›®ä¸€å¥è¯ä»‹ç»)
2. [é¡¹ç›®è¯¦ç»†ä»‹ç»](#é¡¹ç›®è¯¦ç»†ä»‹ç»)
3. [æ ¸å¿ƒæŠ€æœ¯äº®ç‚¹](#æ ¸å¿ƒæŠ€æœ¯äº®ç‚¹)
4. [æ¶æ„è®¾è®¡è¯¦è§£](#æ¶æ„è®¾è®¡è¯¦è§£)
5. [å…³é”®æŠ€æœ¯é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#å…³é”®æŠ€æœ¯é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
6. [Python æŠ€æœ¯è¦ç‚¹ï¼ˆç»“åˆé¡¹ç›®ï¼‰](#pythonæŠ€æœ¯è¦ç‚¹ç»“åˆé¡¹ç›®)
7. [é¢å‘å¯¹è±¡è®¾è®¡ï¼ˆOOPï¼‰](#é¢å‘å¯¹è±¡è®¾è®¡oop)
8. [è®¡ç®—æœºåŸºç¡€çŸ¥è¯†](#è®¡ç®—æœºåŸºç¡€çŸ¥è¯†)
9. [è½¯ä»¶å·¥ç¨‹å®è·µ](#è½¯ä»¶å·¥ç¨‹å®è·µ)
10. [å¸¸è§é¢è¯•é—®é¢˜åŠå›ç­”](#å¸¸è§é¢è¯•é—®é¢˜åŠå›ç­”)

---

## é¡¹ç›®ä¸€å¥è¯ä»‹ç»

**é¢è¯•å¼€åœºç™½æ¨¡æ¿**ï¼š

> "æˆ‘è´Ÿè´£å¼€å‘äº†ä¸€ä¸ªé‡å­æ€å±‚æé‡æ„å·¥å…·åŒ…ï¼Œå°†åŸæœ‰çš„ MATLAB ç³»ç»Ÿé‡æ„ä¸ºç°ä»£åŒ–çš„ Python å·¥ç¨‹é¡¹ç›®ã€‚è¯¥é¡¹ç›®é‡‡ç”¨**å››å±‚åˆ†å±‚æ¶æ„**è®¾è®¡ï¼Œå®ç°äº†**çº¿æ€§é‡æ„å’Œæœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMLEï¼‰ä¸¤ç§æ ¸å¿ƒç®—æ³•**ï¼Œæ”¯æŒä»»æ„ç»´åº¦çš„é‡å­æ€é‡æ„ï¼Œå¹¶é€šè¿‡**å®Œæ•´çš„å•å…ƒæµ‹è¯•**ï¼ˆ106ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ100%é€šè¿‡ï¼‰å’Œ**CLIå·¥å…·**æä¾›äº†å·¥ä¸šçº§çš„ä»£ç è´¨é‡ã€‚é¡¹ç›®è§„æ¨¡çº¦ **5000+ è¡Œä»£ç **ï¼Œæµ‹è¯•è¦†ç›–ç‡è¾¾ **90%**ï¼Œæ¶µç›–**æ¥å£å±‚ã€åº”ç”¨å±‚ã€é¢†åŸŸå±‚ã€åŸºç¡€è®¾æ–½å±‚**å››å±‚æ¶æ„ï¼Œå……åˆ†ä½“ç°äº†**é¢å‘å¯¹è±¡è®¾è®¡ã€è®¾è®¡æ¨¡å¼ã€æ€§èƒ½ä¼˜åŒ–ã€æµ‹è¯•é©±åŠ¨å¼€å‘**ç­‰è½¯ä»¶å·¥ç¨‹æœ€ä½³å®è·µã€‚"

---

## é¡¹ç›®è¯¦ç»†ä»‹ç»

### 1.1 é¡¹ç›®èƒŒæ™¯

**é—®é¢˜é¢†åŸŸ**ï¼šé‡å­æ€å±‚æï¼ˆQuantum State Tomography, QSTï¼‰æ˜¯é‡å­ä¿¡æ¯ç§‘å­¦ä¸­çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œç”¨äºä»å®éªŒæµ‹é‡æ•°æ®ä¸­é‡æ„é‡å­ç³»ç»Ÿçš„å¯†åº¦çŸ©é˜µã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š
- åŸæœ‰ MATLAB ç³»ç»Ÿç¼ºä¹æ¨¡å—åŒ–è®¾è®¡ï¼Œä»£ç è€¦åˆä¸¥é‡
- ç¼ºå°‘è‡ªåŠ¨åŒ–æµ‹è¯•ï¼Œç»´æŠ¤æˆæœ¬é«˜
- æ²¡æœ‰æ‰¹å¤„ç†å’Œå‘½ä»¤è¡Œå·¥å…·ï¼Œä½¿ç”¨ä¸ä¾¿
- å¯è§†åŒ–åŠŸèƒ½åˆ†æ•£ï¼Œä¸å¤Ÿç³»ç»ŸåŒ–

**é¡¹ç›®ç›®æ ‡**ï¼š
1. å°† MATLAB ä»£ç é‡æ„ä¸º Pythonï¼Œæå‡ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§
2. é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼Œå®ç°æ¸…æ™°çš„èŒè´£åˆ†ç¦»
3. æä¾›å®Œæ•´çš„æµ‹è¯•è¦†ç›–ï¼ˆå•å…ƒæµ‹è¯• + é›†æˆæµ‹è¯•ï¼‰
4. å®ç° CLI å·¥å…·å’Œæ‰¹å¤„ç†èƒ½åŠ›
5. ä¿è¯ä¸ MATLAB åŸºå‡†çš„æ•°å€¼ç²¾åº¦ï¼ˆè¯¯å·® < 1e-10ï¼‰

### 1.2 é¡¹ç›®è§„æ¨¡

| ç»´åº¦ | æ•°æ® |
|------|------|
| ä»£ç è¡Œæ•° | ~5000+ è¡Œï¼ˆä¸å«æ³¨é‡Šå’Œç©ºè¡Œï¼‰ |
| æ¨¡å—æ•°é‡ | 8 ä¸ªæ ¸å¿ƒæ¨¡å—ï¼ˆdomain, app, cli, analysis, infrastructure, visualizationï¼‰ |
| æµ‹è¯•ç”¨ä¾‹ | **106 ä¸ª**ï¼ˆ100% é€šè¿‡ï¼‰ï¼Œæµ‹è¯•è¦†ç›–ç‡ 90% |
| å¼€å‘å‘¨æœŸ | 3 ä¸ªä¸»è¦é˜¶æ®µï¼ˆåŸºç¡€æ¶æ„ â†’ Bellæ€åˆ†æ â†’ æŒ‡æ ‡æ‰©å±• âœ…ï¼‰ |
| æ–‡æ¡£æ•°é‡ | 30+ ä¸ªæŠ€æœ¯æ–‡æ¡£ï¼ˆåŒ…æ‹¬è®¾è®¡æ–‡æ¡£ã€æ•™å­¦æ–‡æ¡£ã€APIæ–‡æ¡£ï¼‰ |
| Git æäº¤ | è§„èŒƒæäº¤è®°å½•ï¼Œéµå¾ª Conventional Commits |
| ä»£ç è´¨é‡ | PEP 8 è§„èŒƒï¼Œå®Œæ•´ç±»å‹æç¤ºï¼Œè¯¦ç»†æ–‡æ¡£å­—ç¬¦ä¸² |

### 1.3 æ ¸å¿ƒåŠŸèƒ½

#### åŠŸèƒ½ 1ï¼šé‡å­æ€é‡æ„
- **çº¿æ€§é‡æ„**ï¼šåŸºäºæœ€å°äºŒä¹˜æ³•ï¼Œé€Ÿåº¦å¿«ï¼ˆ~0.01sï¼‰ï¼Œé€‚åˆå®æ—¶åœºæ™¯
- **MLE é‡æ„**ï¼šåŸºäºæœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼Œç²¾åº¦é«˜ï¼ˆä¿çœŸåº¦ > 0.999ï¼‰ï¼Œé€‚åˆé«˜ç²¾åº¦éœ€æ±‚

#### åŠŸèƒ½ 2ï¼šBell æ€åˆ†æ
- è®¡ç®—é‡æ„æ€ä¸ 4 ç§æ ‡å‡† Bell æ€çš„ä¿çœŸåº¦
- æ‰¾å‡ºæœ€ä½³åŒ¹é…æ€å’Œå¹³å‡ä¿çœŸåº¦
- ç”¨äºè¯„ä¼°çº ç¼ æ€çš„è´¨é‡

#### åŠŸèƒ½ 3ï¼šæ‰¹å¤„ç†ä¸ CLI
- æ”¯æŒä» CSV/Excel è¯»å–å¤šä¸ªæ ·æœ¬
- è‡ªåŠ¨ç”Ÿæˆ `summary.csv`ï¼ˆæ±‡æ€»æŠ¥å‘Šï¼Œå« 13 ä¸ªæŒ‡æ ‡å­—æ®µï¼‰å’Œ JSON è®°å½•
- æä¾› `reconstruct`ã€`summarize`ã€`bell-analyze`ã€`info` å››ä¸ªå­å‘½ä»¤
- Stage 3 å¢å¼ºï¼š`--compare-methods`ï¼ˆLinear vs MLE å¯¹æ¯”ï¼‰ã€`--detailed`ï¼ˆè¯¦ç»†ç»Ÿè®¡ï¼‰ã€`--output`ï¼ˆæŠ¥å‘Šå¯¼å‡ºï¼‰

#### åŠŸèƒ½ 4ï¼šå¯è§†åŒ–
- 2D çƒ­å›¾ï¼ˆå¯†åº¦çŸ©é˜µçš„å®éƒ¨/è™šéƒ¨ï¼‰
- 3D æŸ±çŠ¶å›¾ï¼ˆå¹…åº¦/ç›¸ä½ã€å®éƒ¨/è™šéƒ¨ï¼‰
- æ–¹æ³•å¯¹æ¯”å›¾ï¼ˆLinear vs MLEï¼‰

---

## æ ¸å¿ƒæŠ€æœ¯äº®ç‚¹

### 3.1 åˆ†å±‚æ¶æ„è®¾è®¡ â­â­â­

**å››å±‚æ¶æ„**ï¼ˆç”±ä¸‹è‡³ä¸Šï¼‰ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ¥å£å±‚ (Interface Layer)               â”‚  â† CLI (main.py, 203è¡Œ)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åº”ç”¨å±‚ (Application Layer)             â”‚  â† Controller (æ‰¹å¤„ç†ç¼–æ’, 154è¡Œ)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é¢†åŸŸå±‚ (Domain Layer)                  â”‚  â† Reconstructor, DensityMatrix
â”‚                                         â”‚    Projectors (æŠ•å½±ç®—ç¬¦)
â”‚                                         â”‚    Bellåˆ†æ, Metricsè®¡ç®—
â”‚                                         â”‚    Comparisonå¯¹æ¯” (99è¡Œ)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)      â”‚  â† ResultRepository, Visualizer
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**é¢è¯•è¦ç‚¹**ï¼š
- **ä¸ºä»€ä¹ˆé‡‡ç”¨åˆ†å±‚æ¶æ„ï¼Ÿ**
  - **èŒè´£æ¸…æ™°**ï¼šæ¯ä¸€å±‚æœ‰æ˜ç¡®çš„èŒè´£ï¼Œé™ä½è€¦åˆ
  - **å¯æµ‹è¯•æ€§**ï¼šå¯ä»¥ç‹¬ç«‹æµ‹è¯•æ¯ä¸€å±‚ï¼ˆå¦‚é¢†åŸŸå±‚ä¸ä¾èµ– CLIï¼‰
  - **å¯æ›¿æ¢æ€§**ï¼šå¯ä»¥è½»æ¾æ›¿æ¢æŸä¸€å±‚çš„å®ç°ï¼ˆå¦‚ä» JSON åˆ‡æ¢åˆ°æ•°æ®åº“ï¼‰
  - **ç¬¦åˆ SOLID åŸåˆ™**ï¼šç‰¹åˆ«æ˜¯**å•ä¸€èŒè´£åŸåˆ™**å’Œ**ä¾èµ–å€’ç½®åŸåˆ™**

- **å„å±‚èŒè´£**ï¼š
  - **æ¥å£å±‚**ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥ã€å‚æ•°è§£æã€é”™è¯¯æç¤º
  - **åº”ç”¨å±‚**ï¼šç¼–æ’ä¸šåŠ¡æµç¨‹ï¼ˆå¦‚æ‰¹å¤„ç†ã€ä¿å­˜ç»“æœã€ç”ŸæˆæŠ¥å‘Šï¼‰
  - **é¢†åŸŸå±‚**ï¼šæ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ˆé‡æ„ç®—æ³•ã€å¯†åº¦çŸ©é˜µç‰©ç†çº¦æŸã€Bellåˆ†æã€æŒ‡æ ‡è®¡ç®—ã€æ–¹æ³•å¯¹æ¯”ï¼‰
  - **åŸºç¡€è®¾æ–½å±‚**ï¼šæŠ€æœ¯ç»†èŠ‚ï¼ˆæ–‡ä»¶ I/Oã€å¯è§†åŒ–ã€æŒä¹…åŒ–ï¼‰

### 3.2 é¢å‘å¯¹è±¡è®¾è®¡ â­â­â­

#### æ ¸å¿ƒç±»è®¾è®¡

**1. DensityMatrixï¼ˆå¯†åº¦çŸ©é˜µï¼‰**
```python
class DensityMatrix:
    """å¯†åº¦çŸ©é˜µçš„é¢†åŸŸæ¨¡å‹ï¼Œå°è£…ç‰©ç†çº¦æŸå’Œè®¡ç®—é€»è¾‘"""
    
    def __init__(self, matrix: np.ndarray, tolerance: float = 1e-9):
        self._matrix = matrix
        self._tolerance = tolerance
        self._ensure_hermitian()      # å„ç±³æ€§çº¦æŸ
        self._ensure_positive_semi()  # åŠæ­£å®šçº¦æŸ
        self._ensure_trace_one()      # è¿¹ä¸º1çº¦æŸ
    
    @property
    def purity(self) -> float:
        """çº¯åº¦ = Tr(ÏÂ²)"""
        return np.real(np.trace(self._matrix @ self._matrix))
    
    @property
    def eigenvalues(self) -> np.ndarray:
        """ç‰¹å¾å€¼ï¼ˆé™åºæ’åˆ—ï¼‰"""
        return np.linalg.eigvalsh(self._matrix)[::-1]
```

**è®¾è®¡äº®ç‚¹**ï¼š
- **ä¸å˜æ€§çº¦æŸ**ï¼šæ„é€ å‡½æ•°ç¡®ä¿ç‰©ç†çº¦æŸå§‹ç»ˆæ»¡è¶³
- **å±æ€§å°è£…**ï¼šä½¿ç”¨ `@property` æä¾›åªè¯»è®¿é—®ï¼Œé¿å…å¤–éƒ¨ä¿®æ”¹
- **å»¶è¿Ÿè®¡ç®—**ï¼šç‰¹å¾å€¼ç­‰å±æ€§æŒ‰éœ€è®¡ç®—ï¼ˆå¯é€‰ç¼“å­˜ï¼‰

**2. LinearReconstructorï¼ˆçº¿æ€§é‡æ„å™¨ï¼‰**
```python
class LinearReconstructor:
    """çº¿æ€§é‡æ„ç®—æ³•çš„å®ç°"""
    
    def __init__(self, dimension: int, tolerance: float = 1e-9,
                 regularization: Optional[float] = None):
        self.dimension = dimension
        self.tolerance = tolerance
        self.regularization = regularization
        self._projector_set = None  # å»¶è¿Ÿåˆå§‹åŒ–
    
    def reconstruct(self, probabilities: np.ndarray) -> LinearResult:
        """æ‰§è¡Œé‡æ„ï¼Œè¿”å›ç»“æœå¯¹è±¡"""
        # 1. ç”ŸæˆæŠ•å½±ç®—ç¬¦
        if self._projector_set is None:
            self._projector_set = ProjectorSet(self.dimension)
        
        # 2. æ„å»ºçº¿æ€§æ–¹ç¨‹ç»„
        A, b = self._build_system(probabilities)
        
        # 3. æ±‚è§£ï¼ˆå¸¦æ­£åˆ™åŒ–ï¼‰
        rho_vec = self._solve(A, b)
        
        # 4. ç¡®ä¿ç‰©ç†çº¦æŸ
        rho = rho_vec.reshape((self.dimension, self.dimension))
        density = DensityMatrix(rho, self.tolerance)
        
        # 5. è¿”å›ç»“æœå¯¹è±¡
        return LinearResult(
            density=density,
            singular_values=svd_s,
            fidelity=self._calculate_fidelity(density, probabilities)
        )
```

**è®¾è®¡äº®ç‚¹**ï¼š
- **ç­–ç•¥æ¨¡å¼**ï¼šä¸åŒé‡æ„ç®—æ³•å®ç°ç›¸åŒæ¥å£ï¼ˆå¯æ‰©å±•ä¸º BaseReconstructorï¼‰
- **ç»“æœå¯¹è±¡**ï¼šè¿”å› `LinearResult` è€Œéè£¸æ•°æ®ï¼Œä¾¿äºæ‰©å±•
- **ä¾èµ–æ³¨å…¥**ï¼š`ProjectorSet` å¯å¤–éƒ¨æ³¨å…¥æˆ–å†…éƒ¨åˆ›å»º
- **å•ä¸€èŒè´£**ï¼šä¸“æ³¨äºé‡æ„é€»è¾‘ï¼Œä¸å¤„ç† I/O æˆ–å¯è§†åŒ–

#### OOP äº”å¤§åŸåˆ™ï¼ˆSOLIDï¼‰åº”ç”¨

| åŸåˆ™ | åº”ç”¨å®ä¾‹ |
|------|---------|
| **S**ingle Responsibility | `DensityMatrix` åªè´Ÿè´£å¯†åº¦çŸ©é˜µçš„ç‰©ç†çº¦æŸå’Œå±æ€§è®¡ç®— |
| **O**pen/Closed | `Reconstructor` å¯æ‰©å±•ä¸ºæ–°ç®—æ³•ï¼Œæ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç  |
| **L**iskov Substitution | `LinearReconstructor` å’Œ `MLEReconstructor` å¯äº’æ¢ä½¿ç”¨ |
| **I**nterface Segregation | `ResultRepository` åªæš´éœ² `save/load` æ¥å£ï¼Œä¸æš´éœ²æ ¼å¼ç»†èŠ‚ |
| **D**ependency Inversion | `Controller` ä¾èµ–æŠ½è±¡çš„ `Reconstructor`ï¼Œè€Œéå…·ä½“å®ç° |

### 3.3 è®¾è®¡æ¨¡å¼åº”ç”¨ â­â­

| æ¨¡å¼ | åº”ç”¨åœºæ™¯ | ä»£ç ä½ç½® |
|------|---------|---------|
| **å·¥å‚æ¨¡å¼** | æ ¹æ®é…ç½®åˆ›å»ºä¸åŒçš„ Reconstructor | `controller.py:_create_reconstructor()` |
| **ç­–ç•¥æ¨¡å¼** | åˆ‡æ¢é‡æ„ç®—æ³•ï¼ˆLinear/MLEï¼‰ | `LinearReconstructor`, `MLEReconstructor` |
| **ä»“å‚¨æ¨¡å¼** | æŠ½è±¡æ•°æ®æŒä¹…åŒ–é€»è¾‘ | `ResultRepository` |
| **å‘½ä»¤æ¨¡å¼** | CLI å­å‘½ä»¤åˆ†å‘ | `cli/main.py:build_parser()` |
| **å•ä¾‹æ¨¡å¼** | `ProjectorSet` ç¼“å­˜ï¼ˆå¯é€‰ï¼‰ | `projectors.py` |
| **æ¨¡æ¿æ–¹æ³•** | `_cmd_reconstruct` å®šä¹‰æµç¨‹æ¡†æ¶ | `cli/main.py` |

**ç¤ºä¾‹ï¼šå·¥å‚æ¨¡å¼**
```python
def _create_reconstructor(method: str, config: ReconstructionConfig):
    """å·¥å‚æ–¹æ³•ï¼šæ ¹æ®æ–¹æ³•ååˆ›å»ºé‡æ„å™¨"""
    if method == "linear":
        return LinearReconstructor(
            dimension=config.dimension,
            tolerance=config.tolerance,
            regularization=config.linear_regularization
        )
    elif method == "mle":
        return MLEReconstructor(
            dimension=config.dimension,
            tolerance=config.tolerance,
            max_iterations=config.mle_max_iterations,
            regularization=config.mle_regularization
        )
    else:
        raise ValueError(f"æœªçŸ¥çš„é‡æ„æ–¹æ³•: {method}")
```

**é¢è¯•ç­”é¢˜æ€è·¯**ï¼š
- **ä¸ºä»€ä¹ˆç”¨å·¥å‚æ¨¡å¼ï¼Ÿ** â†’ è§£è€¦å¯¹è±¡åˆ›å»ºå’Œä½¿ç”¨ï¼Œæ”¯æŒæ ¹æ®é…ç½®åŠ¨æ€åˆ›å»º
- **å¥½å¤„ï¼Ÿ** â†’ æ–°å¢ç®—æ³•æ—¶åªéœ€æ·»åŠ æ–°ç±»ï¼Œæ— éœ€ä¿®æ”¹è°ƒç”¨æ–¹ä»£ç ï¼ˆå¼€é—­åŸåˆ™ï¼‰

### 3.4 æ€§èƒ½ä¼˜åŒ– â­â­

#### ä¼˜åŒ– 1ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜

**é—®é¢˜**ï¼šæŠ•å½±ç®—ç¬¦ç”Ÿæˆè®¡ç®—å¯†é›†ï¼ˆ$O(n^4)$ï¼‰ï¼Œæ¯æ¬¡é‡æ„éƒ½ç”Ÿæˆæµªè´¹

**è§£å†³æ–¹æ¡ˆ**ï¼š
```python
class ProjectorSet:
    _cache: Dict[int, 'ProjectorSet'] = {}  # ç±»çº§ç¼“å­˜
    
    @classmethod
    def get_cached(cls, dimension: int) -> 'ProjectorSet':
        if dimension not in cls._cache:
            cls._cache[dimension] = ProjectorSet(dimension)
        return cls._cache[dimension]
```

**æ•ˆæœ**ï¼šæ‰¹å¤„ç† 100 ä¸ªæ ·æœ¬æ—¶ï¼Œè€—æ—¶ä» ~50s é™è‡³ ~5sï¼ˆ**10å€æå‡**ï¼‰

#### ä¼˜åŒ– 2ï¼šNumPy å‘é‡åŒ–

**é—®é¢˜**ï¼šPython å¾ªç¯æ…¢ï¼Œå¤„ç†å¤§çŸ©é˜µæ—¶æ•ˆç‡ä½

**è§£å†³æ–¹æ¡ˆ**ï¼š
```python
# âŒ æ…¢é€Ÿç‰ˆæœ¬ï¼ˆPython å¾ªç¯ï¼‰
for i in range(n):
    for j in range(n):
        result[i, j] = matrix1[i, j] * matrix2[i, j]

# âœ… å¿«é€Ÿç‰ˆæœ¬ï¼ˆNumPy å¹¿æ’­ï¼‰
result = matrix1 * matrix2  # 100x æ›´å¿«
```

**æ•ˆæœ**ï¼šå¯†åº¦çŸ©é˜µç‰©ç†åŒ–ï¼ˆ`makephysical`ï¼‰ä» ~10ms é™è‡³ ~0.1ms

#### ä¼˜åŒ– 3ï¼šæ¡ä»¶æ•°è®¡ç®—

**é—®é¢˜**ï¼šå¥‡å¼‚å€¼ä¸º 0 æ—¶ï¼Œæ¡ä»¶æ•°ä¸º `inf`ï¼Œå¯¼è‡´ CSV è¾“å‡ºé—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š
```python
def _calculate_condition_number(singular_values: np.ndarray) -> float:
    if len(singular_values) == 0:
        return 1.0
    max_sv = singular_values[0]
    min_sv = singular_values[-1]
    if min_sv < 1e-12 * max_sv:  # ç›¸å¯¹å®¹å·®
        return 1e16  # é¿å… inf
    return max_sv / min_sv
```

**é¢è¯•ç­”é¢˜**ï¼š
- **å¦‚ä½•å®šä½æ€§èƒ½ç“¶é¢ˆï¼Ÿ** â†’ ä½¿ç”¨ `cProfile` æˆ– `line_profiler` æ‰¾åˆ°çƒ­ç‚¹
- **ä¼˜åŒ–ç­–ç•¥ï¼Ÿ** â†’ ç¼“å­˜ã€å‘é‡åŒ–ã€é¿å…é‡å¤è®¡ç®—ã€ä½¿ç”¨ C æ‰©å±•åº“ï¼ˆNumPy/SciPyï¼‰

### 3.5 æ•°å€¼ç¨³å®šæ€§å¤„ç† â­â­

**é—®é¢˜ 1ï¼šå¯†åº¦çŸ©é˜µçš„ç‰©ç†çº¦æŸ**

é‡å­åŠ›å­¦è¦æ±‚å¯†åº¦çŸ©é˜µæ»¡è¶³ï¼š
1. **å„ç±³æ€§**ï¼š$\rho = \rho^\dagger$
2. **åŠæ­£å®šæ€§**ï¼šæ‰€æœ‰ç‰¹å¾å€¼ $\geq 0$
3. **è¿¹ä¸º1**ï¼š$\text{Tr}(\rho) = 1$

ä½†æ•°å€¼è®¡ç®—ä¼šå¼•å…¥è¯¯å·®ï¼Œå¯¼è‡´è¿åçº¦æŸã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š`makephysical` ç®—æ³•
```python
def _ensure_physical(self):
    # 1. å¼ºåˆ¶å„ç±³æ€§
    self._matrix = (self._matrix + self._matrix.conj().T) / 2
    
    # 2. ç‰¹å¾å€¼åˆ†è§£
    eigvals, eigvecs = np.linalg.eigh(self._matrix)
    
    # 3. è£å‰ªè´Ÿç‰¹å¾å€¼
    eigvals = np.maximum(eigvals, 0)
    
    # 4. é‡æ–°å½’ä¸€åŒ–
    eigvals = eigvals / eigvals.sum()
    
    # 5. é‡æ„çŸ©é˜µ
    self._matrix = eigvecs @ np.diag(eigvals) @ eigvecs.conj().T
```

**é—®é¢˜ 2ï¼šçº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£**

**æŒ‘æˆ˜**ï¼šç³»æ•°çŸ©é˜µ $A$ å¯èƒ½ç—…æ€ï¼ˆæ¡ä»¶æ•°å¾ˆå¤§ï¼‰ï¼Œç›´æ¥æ±‚è§£ä¸ç¨³å®š

**è§£å†³æ–¹æ¡ˆ**ï¼šå²­å›å½’ï¼ˆTikhonov æ­£åˆ™åŒ–ï¼‰
```python
def _solve_with_regularization(self, A, b, lambda_reg):
    # æ­£åˆ™åŒ–é¡¹ï¼šmin ||Ax - b||Â² + Î»||x||Â²
    # è§£æè§£ï¼šx = (A^T A + Î»I)^{-1} A^T b
    AtA = A.T @ A
    Atb = A.T @ b
    regularized = AtA + lambda_reg * np.eye(AtA.shape[0])
    return np.linalg.solve(regularized, Atb)
```

**é¢è¯•ç­”é¢˜**ï¼š
- **å¦‚ä½•ä¿è¯æ•°å€¼ç¨³å®šæ€§ï¼Ÿ** â†’ ä½¿ç”¨æˆç†Ÿåº“ï¼ˆNumPy/SciPyï¼‰ã€æ­£åˆ™åŒ–ã€ç‰¹å¾å€¼è£å‰ª
- **å¦‚ä½•éªŒè¯æ•°å€¼ç²¾åº¦ï¼Ÿ** â†’ ä¸ MATLAB åŸºå‡†å¯¹æ¯”ï¼ˆè¯¯å·® < 1e-10ï¼‰ã€å•å…ƒæµ‹è¯•

---

## Python æŠ€æœ¯è¦ç‚¹ï¼ˆç»“åˆé¡¹ç›®ï¼‰

### 4.1 Python é«˜çº§ç‰¹æ€§

#### ç‰¹æ€§ 1ï¼š`@property` è£…é¥°å™¨

**ä½œç”¨**ï¼šå°†æ–¹æ³•è½¬æ¢ä¸ºå±æ€§ï¼Œå®ç°è®¡ç®—å±æ€§å’Œå°è£…

**é¡¹ç›®åº”ç”¨**ï¼š
```python
class DensityMatrix:
    @property
    def purity(self) -> float:
        """çº¯åº¦ï¼ˆè®¡ç®—å±æ€§ï¼‰"""
        return np.real(np.trace(self._matrix @ self._matrix))
    
    @property
    def trace(self) -> float:
        """è¿¹ï¼ˆè®¡ç®—å±æ€§ï¼‰"""
        return np.real(np.trace(self._matrix))
```

**ä¼˜ç‚¹**ï¼š
- å¤–éƒ¨åƒè®¿é—®å±æ€§ä¸€æ ·ä½¿ç”¨ï¼š`density.purity`ï¼ˆæ— éœ€ `()`ï¼‰
- å†…éƒ¨å¯æ§åˆ¶è®¡ç®—é€»è¾‘ï¼ˆå¦‚ç¼“å­˜ã€éªŒè¯ï¼‰
- åªè¯»å±æ€§ï¼Œé˜²æ­¢å¤–éƒ¨ä¿®æ”¹

**é¢è¯•é—®é¢˜**ï¼š`@property` vs æ™®é€šå±æ€§ï¼Ÿ
- `@property`ï¼šè®¡ç®—å±æ€§ï¼Œå¯å»¶è¿Ÿè®¡ç®—ã€å¯éªŒè¯
- æ™®é€šå±æ€§ï¼šç›´æ¥å­˜å‚¨ï¼Œè®¿é—®æ›´å¿«ä½†æ— æ³•æ§åˆ¶

#### ç‰¹æ€§ 2ï¼š`dataclass` (Python 3.7+)

**ä½œç”¨**ï¼šç®€åŒ–æ•°æ®ç±»çš„å®šä¹‰ï¼Œè‡ªåŠ¨ç”Ÿæˆ `__init__`, `__repr__` ç­‰æ–¹æ³•

**é¡¹ç›®åº”ç”¨**ï¼š
```python
from dataclasses import dataclass

@dataclass
class LinearResult:
    """çº¿æ€§é‡æ„ç»“æœ"""
    density: DensityMatrix
    singular_values: np.ndarray
    fidelity: float
    timestamp: str = None
```

**ä¼˜ç‚¹**ï¼š
- å‡å°‘æ ·æ¿ä»£ç ï¼ˆæ— éœ€æ‰‹å†™ `__init__`ï¼‰
- è‡ªåŠ¨ç”Ÿæˆ `__repr__`ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
- ç±»å‹æç¤ºå¢å¼ºå¯è¯»æ€§

#### ç‰¹æ€§ 3ï¼šç±»å‹æç¤º (Type Hints)

**ä½œç”¨**ï¼šå¢å¼ºä»£ç å¯è¯»æ€§ï¼Œæ”¯æŒé™æ€ç±»å‹æ£€æŸ¥ï¼ˆmypyï¼‰

**é¡¹ç›®åº”ç”¨**ï¼š
```python
from typing import Optional, List, Tuple

def reconstruct(
    self,
    probabilities: np.ndarray,
    regularization: Optional[float] = None
) -> LinearResult:
    """
    é‡æ„é‡å­æ€
    
    å‚æ•°:
        probabilities: æµ‹é‡æ¦‚ç‡å‘é‡
        regularization: æ­£åˆ™åŒ–ç³»æ•°ï¼ˆå¯é€‰ï¼‰
    
    è¿”å›:
        é‡æ„ç»“æœå¯¹è±¡
    """
    ...
```

**ä¼˜ç‚¹**ï¼š
- æé«˜ä»£ç å¯è¯»æ€§ï¼ˆä¸€çœ¼çœ‹å‡ºå‚æ•°å’Œè¿”å›å€¼ç±»å‹ï¼‰
- IDE è‡ªåŠ¨è¡¥å…¨æ›´å‡†ç¡®
- å¯ç”¨ mypy è¿›è¡Œé™æ€æ£€æŸ¥

**é¢è¯•é—®é¢˜**ï¼šPython æ˜¯åŠ¨æ€ç±»å‹è¿˜æ˜¯é™æ€ç±»å‹ï¼Ÿ
- **åŠ¨æ€ç±»å‹**ï¼šè¿è¡Œæ—¶ç¡®å®šç±»å‹ï¼Œæ— éœ€å£°æ˜
- **ç±»å‹æç¤º**ï¼šå¯é€‰çš„é™æ€ç±»å‹æ ‡æ³¨ï¼Œä¸å¼ºåˆ¶æ‰§è¡Œï¼ˆä½†å¯ç”¨å·¥å…·æ£€æŸ¥ï¼‰

#### ç‰¹æ€§ 4ï¼šä¸Šä¸‹æ–‡ç®¡ç†å™¨ (`with` è¯­å¥)

**ä½œç”¨**ï¼šè‡ªåŠ¨ç®¡ç†èµ„æºï¼ˆæ–‡ä»¶ã€é”ç­‰ï¼‰ï¼Œç¡®ä¿æ­£ç¡®é‡Šæ”¾

**é¡¹ç›®åº”ç”¨**ï¼š
```python
def load_record(self, record_id: str) -> ReconstructionRecord:
    json_path = self.records_dir / f"{record_id}.json"
    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    return ReconstructionRecord.from_dict(data)
```

**ä¼˜ç‚¹**ï¼š
- è‡ªåŠ¨å…³é—­æ–‡ä»¶ï¼ˆå³ä½¿å‘ç”Ÿå¼‚å¸¸ï¼‰
- ä»£ç æ›´ç®€æ´ï¼ˆæ— éœ€ `try...finally`ï¼‰

**é¢è¯•é—®é¢˜**ï¼šå¦‚ä½•å®ç°æ ‡å‡†çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Ÿ

### **åŸºæœ¬å›ç­”**
> "Pythonä¸­çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨é€šè¿‡å®ç°`__enter__`å’Œ`__exit__`æ–¹æ³•æ¥å®šä¹‰ï¼Œæˆ–è€…ä½¿ç”¨`contextmanager`è£…é¥°å™¨ã€‚ä¸Šä¸‹æ–‡ç®¡ç†å™¨ä¸»è¦ç”¨äºèµ„æºç®¡ç†ï¼Œç¡®ä¿èµ„æºåœ¨ä½¿ç”¨åèƒ½å¤Ÿæ­£ç¡®é‡Šæ”¾ï¼Œå³ä½¿å‘ç”Ÿå¼‚å¸¸ä¹Ÿèƒ½ä¿è¯æ¸…ç†å·¥ä½œå®Œæˆã€‚"

### **ä¸¤ç§å®ç°æ–¹å¼**

#### **æ–¹æ³•1ï¼šç±»å®ç°**
```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        print(f"æ‰“å¼€æ–‡ä»¶: {self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"å…³é—­æ–‡ä»¶: {self.filename}")
        if self.file:
            self.file.close()
        return False  # ä¸æŠ‘åˆ¶å¼‚å¸¸
```

#### **æ–¹æ³•2ï¼šcontextmanagerè£…é¥°å™¨**
```python
from contextlib import contextmanager

@contextmanager
def file_manager(filename, mode):
    print(f"æ‰“å¼€æ–‡ä»¶: {filename}")
    file = open(filename, mode)
    try:
        yield file
    finally:
        print(f"å…³é—­æ–‡ä»¶: {filename}")
        file.close()
```

### **æˆ‘é¡¹ç›®ä¸­çš„å®é™…åº”ç”¨**

#### **1. æ–‡ä»¶æ“ä½œç®¡ç†ï¼ˆä¸»è¦åº”ç”¨ï¼‰**
```python
# JSONæ–‡ä»¶ä¿å­˜
def _save_json(self, payload: Dict[str, Any]) -> Path:
    with path.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, ensure_ascii=False, indent=2)

# CSVæ–‡ä»¶è¯»å–
def _load_all_csv(self) -> List[ReconstructionRecord]:
    with path.open("r", newline="", encoding="utf-8") as fh:
        reader = csv.DictReader(fh)
```

#### **2. å¼‚å¸¸æµ‹è¯•ç®¡ç†**
```python
# æµ‹è¯•å¼‚å¸¸æŠ›å‡º
def test_invalid_input():
    with pytest.raises(ValueError):
        DensityMatrix(np.array([1, 2, 3]))  # éæ–¹é˜µ
```

#### **3. è¿›ç¨‹æ± ç®¡ç†**
```python
# å¹¶è¡Œé‡æ„
def batch_reconstruct_parallel(samples):
    with ProcessPoolExecutor(max_workers=4) as executor:
        results = executor.map(reconstruct_worker, samples)
    return list(results)
```

### **æŠ€æœ¯è¦ç‚¹**

#### **`__exit__`æ–¹æ³•å‚æ•°**
- `exc_type`ï¼šå¼‚å¸¸ç±»å‹ï¼Œæ— å¼‚å¸¸æ—¶ä¸ºNone
- `exc_val`ï¼šå¼‚å¸¸å€¼ï¼Œæ— å¼‚å¸¸æ—¶ä¸ºNone  
- `exc_tb`ï¼šå¼‚å¸¸è¿½è¸ªï¼Œæ— å¼‚å¸¸æ—¶ä¸ºNone
- **è¿”å›å€¼**ï¼šTrueæŠ‘åˆ¶å¼‚å¸¸ï¼ŒFalse/Noneè®©å¼‚å¸¸ä¼ æ’­

#### **ä½¿ç”¨åœºæ™¯**
1. **æ–‡ä»¶æ“ä½œ**ï¼šç¡®ä¿æ–‡ä»¶æ­£ç¡®å…³é—­
2. **æ•°æ®åº“è¿æ¥**ï¼šç¡®ä¿è¿æ¥å’Œäº‹åŠ¡æ­£ç¡®å¤„ç†
3. **é”ç®¡ç†**ï¼šç¡®ä¿é”çš„æ­£ç¡®è·å–å’Œé‡Šæ”¾
4. **ä¸´æ—¶èµ„æº**ï¼šå¦‚ä¸´æ—¶æ–‡ä»¶ã€ä¸´æ—¶ç›®å½•
5. **çŠ¶æ€ç®¡ç†**ï¼šå¦‚æ—¥å¿—è®°å½•ã€æ€§èƒ½ç›‘æ§

### **é¢è¯•å®˜å¯èƒ½çš„è¿½é—®**

#### **Q1: "ä¸ºä»€ä¹ˆé€‰æ‹©ä¸Šä¸‹æ–‡ç®¡ç†å™¨è€Œä¸æ˜¯try-finallyï¼Ÿ"**
**å›ç­”**ï¼š
> "ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ›´ç®€æ´ï¼Œå‡å°‘äº†æ ·æ¿ä»£ç ã€‚æ¯”å¦‚æ–‡ä»¶æ“ä½œï¼š
> ```python
> # ä¼ ç»Ÿæ–¹å¼
> f = open('file.txt')
> try:
>     data = f.read()
> finally:
>     f.close()
> 
> # ä¸Šä¸‹æ–‡ç®¡ç†å™¨
> with open('file.txt') as f:
>     data = f.read()
> ```
> ä¸Šä¸‹æ–‡ç®¡ç†å™¨è‡ªåŠ¨å¤„ç†å¼‚å¸¸æƒ…å†µï¼Œä»£ç æ›´æ¸…æ™°ã€‚"

#### **Q2: "åœ¨ä½ çš„é¡¹ç›®ä¸­ï¼Œä¸Šä¸‹æ–‡ç®¡ç†å™¨è§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ"**
**å›ç­”**ï¼š
> "åœ¨æˆ‘çš„é‡å­æ€é‡æ„é¡¹ç›®ä¸­ï¼Œä¸Šä¸‹æ–‡ç®¡ç†å™¨ä¸»è¦è§£å†³äº†ä¸‰ä¸ªé—®é¢˜ï¼š
> 1. **æ–‡ä»¶å¥æŸ„æ³„æ¼**ï¼šç¡®ä¿JSON/CSVæ–‡ä»¶æ­£ç¡®å…³é—­ï¼Œé¿å…æ–‡ä»¶å¥æŸ„æ³„æ¼
> 2. **å¼‚å¸¸å®‰å…¨**ï¼šå³ä½¿é‡æ„è¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸¸ï¼Œæ–‡ä»¶ä¹Ÿèƒ½æ­£ç¡®å…³é—­
> 3. **èµ„æºç®¡ç†**ï¼šè¿›ç¨‹æ± çš„æ­£ç¡®åˆ›å»ºå’Œé”€æ¯ï¼Œé¿å…åƒµå°¸è¿›ç¨‹
> 
> ç‰¹åˆ«æ˜¯åœ¨æ‰¹å¤„ç†å¤§é‡æ–‡ä»¶æ—¶ï¼Œè¿™äº›èµ„æºç®¡ç†é—®é¢˜æ›´åŠ é‡è¦ã€‚"

#### **Q3: "contextmanagerè£…é¥°å™¨å’Œç±»å®ç°å¦‚ä½•é€‰æ‹©ï¼Ÿ"**
**å›ç­”**ï¼š
> "é€‰æ‹©åŸåˆ™ï¼š
> - **ç®€å•åœºæ™¯**ï¼šç”¨`@contextmanager`è£…é¥°å™¨ï¼Œä»£ç æ›´ç®€æ´
> - **å¤æ‚åœºæ™¯**ï¼šç”¨ç±»å®ç°ï¼Œå¯ä»¥å­˜å‚¨çŠ¶æ€ï¼Œæ›´çµæ´»
> 
> åœ¨æˆ‘çš„é¡¹ç›®ä¸­ï¼Œæ–‡ä»¶æ“ä½œæ¯”è¾ƒç®€å•ï¼Œç”¨æ ‡å‡†åº“çš„`open()`å°±å¤Ÿäº†ã€‚å¦‚æœè¦è‡ªå®šä¹‰å¤æ‚çš„èµ„æºç®¡ç†ï¼Œæˆ‘ä¼šé€‰æ‹©ç±»å®ç°ã€‚"

### 4.2 NumPy æ ¸å¿ƒæŠ€å·§

#### æŠ€å·§ 1ï¼šå¹¿æ’­ï¼ˆBroadcastingï¼‰

**æ¦‚å¿µ**ï¼šè‡ªåŠ¨æ‰©å±•æ•°ç»„ç»´åº¦ä»¥åŒ¹é…å½¢çŠ¶

**ç¤ºä¾‹**ï¼š
```python
# åœºæ™¯ï¼šçŸ©é˜µæ¯è¡Œå‡å»å‡å€¼
matrix = np.array([[1, 2, 3], [4, 5, 6]])  # (2, 3)
row_means = matrix.mean(axis=1, keepdims=True)  # (2, 1)
centered = matrix - row_means  # å¹¿æ’­ä¸º (2, 3)
```

**é¡¹ç›®åº”ç”¨**ï¼šå¯†åº¦çŸ©é˜µå½’ä¸€åŒ–
```python
# ç‰¹å¾å€¼å½’ä¸€åŒ–ï¼šeigvals / sum(eigvals)
eigvals_normalized = eigvals / eigvals.sum()  # è‡ªåŠ¨å¹¿æ’­
```

#### æŠ€å·§ 2ï¼š`einsum`ï¼ˆçˆ±å› æ–¯å¦æ±‚å’Œçº¦å®šï¼‰

**ä½œç”¨**ï¼šçµæ´»é«˜æ•ˆçš„å¼ é‡è¿ç®—

**ç¤ºä¾‹**ï¼š
```python
# çŸ©é˜µä¹˜æ³•ï¼šC = A @ B
C = np.einsum('ik,kj->ij', A, B)

# çŸ©é˜µè¿¹ï¼štr(A)
trace = np.einsum('ii->', A)

# Hadamard ç§¯ï¼ˆé€å…ƒç´ ä¹˜ï¼‰
result = np.einsum('ij,ij->ij', A, B)
```

**é¡¹ç›®åº”ç”¨**ï¼šæŠ•å½±ç®—ç¬¦è®¡ç®—
```python
# <Ïˆ|Ï|Ïˆ> = Tr(|ÏˆâŸ©âŸ¨Ïˆ| Ï)
expectation = np.einsum('ij,ji->', projector, density)
```

#### æŠ€å·§ 3ï¼š`np.linalg` çº¿æ€§ä»£æ•°

**å¸¸ç”¨å‡½æ•°**ï¼š
- `np.linalg.eigh(A)`ï¼šå„ç±³çŸ©é˜µç‰¹å¾å€¼åˆ†è§£ï¼ˆæ›´å¿«æ›´ç¨³å®šï¼‰
- `np.linalg.svd(A)`ï¼šå¥‡å¼‚å€¼åˆ†è§£
- `np.linalg.solve(A, b)`ï¼šæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ï¼ˆæ¯” `inv(A) @ b` å¿«ä¸”ç¨³å®šï¼‰

**é¡¹ç›®åº”ç”¨**ï¼š
```python
# ç‰©ç†åŒ–ç®—æ³•
eigvals, eigvecs = np.linalg.eigh(matrix)  # O(nÂ³)
matrix_phys = eigvecs @ np.diag(eigvals) @ eigvecs.conj().T
```

### 4.3 Pandas æ•°æ®å¤„ç†

#### æ“ä½œ 1ï¼šåˆ†ç»„èšåˆ

**åœºæ™¯**ï¼šæŒ‰æ–¹æ³•ï¼ˆLinear/MLEï¼‰åˆ†ç»„è®¡ç®—ç»Ÿè®¡é‡

**ä»£ç **ï¼š
```python
import pandas as pd

# è¯»å– summary.csv
df = pd.read_csv("summary.csv")

# æŒ‰ method åˆ†ç»„ï¼Œè®¡ç®—å‡å€¼å’Œæ ‡å‡†å·®
grouped = df.groupby("method")[["purity", "trace", "fidelity"]]
means = grouped.mean()
stds = grouped.std()

# åˆå¹¶ç»“æœ
report = pd.concat([means, stds], axis=1)
```

**è¾“å‡º**ï¼š
```
         purity  trace  fidelity  purity_std  trace_std  fidelity_std
method                                                                
linear    0.68   1.00      0.998       0.015       0.0          0.002
mle       0.67   1.00      0.999       0.012       0.0          0.001
```

#### æ“ä½œ 2ï¼šæ¡ä»¶ç­›é€‰

**åœºæ™¯**ï¼šæ‰¾å‡º MLE æœªæ”¶æ•›çš„æ ·æœ¬

**ä»£ç **ï¼š
```python
# ç­›é€‰ success=False çš„ MLE è®°å½•
failed = df[(df["method"] == "mle") & (df["success"] == False)]
print(f"å¤±è´¥æ ·æœ¬æ•°: {len(failed)}")
print(failed[["sample", "n_iterations", "fidelity"]])
```

#### æ“ä½œ 3ï¼šæ•°æ®é€è§†

**åœºæ™¯**ï¼šå¯¹æ¯” Linear å’Œ MLE çš„æŒ‡æ ‡

**ä»£ç **ï¼š
```python
# è®¾ç½® sample ä¸ºç´¢å¼•ï¼Œmethod ä¸ºåˆ—
pivot = df.pivot(index="sample", columns="method", values="purity")
pivot["diff"] = pivot["linear"] - pivot["mle"]
print(pivot)
```

**é¢è¯•é—®é¢˜**ï¼šPandas vs NumPyï¼Ÿ
- **NumPy**ï¼šæ•°å€¼è®¡ç®—ï¼Œå¤šç»´æ•°ç»„ï¼Œé€Ÿåº¦å¿«
- **Pandas**ï¼šæ•°æ®åˆ†æï¼Œè¡¨æ ¼æ•°æ®ï¼ŒåŠŸèƒ½ä¸°å¯Œï¼ˆåˆ†ç»„ã€é€è§†ã€æ—¶é—´åºåˆ—ï¼‰

### 4.4 å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ

**åŸåˆ™**ï¼šå…·ä½“æ•è·ã€å°½æ—©å¤±è´¥ã€æä¾›ä¸Šä¸‹æ–‡

**é¡¹ç›®åº”ç”¨**ï¼š
```python
def load_probabilities(input_path: Path) -> np.ndarray:
    """åŠ è½½æµ‹é‡æ¦‚ç‡"""
    if not input_path.exists():
        raise FileNotFoundError(f"è¾“å…¥æ–‡ä»¶ä¸å­˜åœ¨: {input_path}")
    
    try:
        if input_path.suffix == ".csv":
            df = pd.read_csv(input_path)
        elif input_path.suffix in [".xlsx", ".xls"]:
            df = pd.read_excel(input_path)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {input_path.suffix}")
    except pd.errors.EmptyDataError:
        raise ValueError(f"æ–‡ä»¶ä¸ºç©º: {input_path}")
    except Exception as e:
        raise RuntimeError(f"è¯»å–æ–‡ä»¶å¤±è´¥: {input_path}") from e
    
    # éªŒè¯æ•°æ®
    if "probability" not in df.columns:
        raise ValueError("ç¼ºå°‘ 'probability' åˆ—")
    
    return df["probability"].values
```

**è¦ç‚¹**ï¼š
- âœ… **å…·ä½“å¼‚å¸¸ç±»å‹**ï¼š`FileNotFoundError`, `ValueError`, `RuntimeError`
- âœ… **å¼‚å¸¸é“¾**ï¼š`raise ... from e` ä¿ç•™åŸå§‹å¼‚å¸¸
- âœ… **æä¾›ä¸Šä¸‹æ–‡**ï¼šé”™è¯¯ä¿¡æ¯åŒ…å«æ–‡ä»¶è·¯å¾„ã€åˆ—åç­‰ç»†èŠ‚
- âŒ **é¿å…è£¸ `except:`**ï¼šä¼šæ•è·æ‰€æœ‰å¼‚å¸¸ï¼ˆåŒ…æ‹¬ `KeyboardInterrupt`ï¼‰

---

## é¢å‘å¯¹è±¡è®¾è®¡ï¼ˆOOPï¼‰

### 5.1 å°è£… (Encapsulation)

**å®šä¹‰**ï¼šéšè—å†…éƒ¨å®ç°ï¼Œåªæš´éœ²å¿…è¦æ¥å£

**é¡¹ç›®ç¤ºä¾‹**ï¼š`DensityMatrix`

**ç§æœ‰å±æ€§**ï¼ˆçº¦å®šç”¨ `_` å‰ç¼€ï¼‰ï¼š
```python
class DensityMatrix:
    def __init__(self, matrix: np.ndarray):
        self._matrix = matrix  # ç§æœ‰å±æ€§
        self._tolerance = 1e-9
        self._eigenvalues_cache = None  # ç¼“å­˜
```

**å…¬å¼€æ¥å£**ï¼š
```python
@property
def purity(self) -> float:
    """å…¬å¼€æ¥å£ï¼šçº¯åº¦"""
    return np.real(np.trace(self._matrix @ self._matrix))

@property
def eigenvalues(self) -> np.ndarray:
    """å…¬å¼€æ¥å£ï¼šç‰¹å¾å€¼ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
    if self._eigenvalues_cache is None:
        self._eigenvalues_cache = np.linalg.eigvalsh(self._matrix)[::-1]
    return self._eigenvalues_cache
```

**å¥½å¤„**ï¼š
- å¤–éƒ¨æ— æ³•ç›´æ¥ä¿®æ”¹ `_matrix`ï¼ˆä¿æŠ¤ä¸å˜æ€§ï¼‰
- å¯ä»¥æ·»åŠ ç¼“å­˜ã€éªŒè¯ç­‰é€»è¾‘
- ä¿®æ”¹å†…éƒ¨å®ç°ä¸å½±å“å¤–éƒ¨è°ƒç”¨

### 5.2 ç»§æ‰¿ (Inheritance)

**å®šä¹‰**ï¼šå­ç±»ç»§æ‰¿çˆ¶ç±»çš„å±æ€§å’Œæ–¹æ³•ï¼Œå®ç°ä»£ç å¤ç”¨

**é¡¹ç›®ç¤ºä¾‹**ï¼šé‡æ„å™¨åŸºç±»ï¼ˆå¯é€‰è®¾è®¡ï¼‰

```python
from abc import ABC, abstractmethod

class BaseReconstructor(ABC):
    """é‡æ„å™¨æŠ½è±¡åŸºç±»"""
    
    def __init__(self, dimension: int, tolerance: float = 1e-9):
        self.dimension = dimension
        self.tolerance = tolerance
        self._projector_set = None
    
    @abstractmethod
    def reconstruct(self, probabilities: np.ndarray) -> ReconstructionResult:
        """æŠ½è±¡æ–¹æ³•ï¼šå­ç±»å¿…é¡»å®ç°"""
        pass
    
    def _get_projectors(self) -> ProjectorSet:
        """é€šç”¨æ–¹æ³•ï¼šè·å–æŠ•å½±ç®—ç¬¦"""
        if self._projector_set is None:
            self._projector_set = ProjectorSet(self.dimension)
        return self._projector_set

class LinearReconstructor(BaseReconstructor):
    """çº¿æ€§é‡æ„å™¨ï¼ˆå­ç±»ï¼‰"""
    
    def reconstruct(self, probabilities: np.ndarray) -> LinearResult:
        projectors = self._get_projectors()  # ç»§æ‰¿çš„æ–¹æ³•
        # ... çº¿æ€§é‡æ„é€»è¾‘
        return LinearResult(...)

class MLEReconstructor(BaseReconstructor):
    """MLE é‡æ„å™¨ï¼ˆå­ç±»ï¼‰"""
    
    def reconstruct(self, probabilities: np.ndarray) -> MLEResult:
        projectors = self._get_projectors()  # ç»§æ‰¿çš„æ–¹æ³•
        # ... MLE é‡æ„é€»è¾‘
        return MLEResult(...)
```

**å¥½å¤„**ï¼š
- å¤ç”¨é€šç”¨ä»£ç ï¼ˆ`_get_projectors`ï¼‰
- å¼ºåˆ¶å­ç±»å®ç°æ¥å£ï¼ˆ`@abstractmethod`ï¼‰
- ç¬¦åˆ**é‡Œæ°æ›¿æ¢åŸåˆ™**ï¼ˆå­ç±»å¯æ›¿æ¢çˆ¶ç±»ï¼‰

### 5.3 å¤šæ€ (Polymorphism)

**å®šä¹‰**ï¼šä¸åŒå¯¹è±¡å“åº”ç›¸åŒæ¥å£ï¼Œè¡Œä¸ºä¸åŒ

**é¡¹ç›®ç¤ºä¾‹**ï¼šController è°ƒç”¨ä¸åŒé‡æ„å™¨

```python
def run_single_reconstruction(reconstructor: BaseReconstructor, probabilities: np.ndarray):
    """å¤šæ€è°ƒç”¨ï¼šä¸å…³å¿ƒå…·ä½“é‡æ„å™¨ç±»å‹"""
    result = reconstructor.reconstruct(probabilities)  # ç»Ÿä¸€æ¥å£
    print(f"ä¿çœŸåº¦: {result.fidelity}")
    return result

# ä½¿ç”¨
linear_rec = LinearReconstructor(dimension=2)
mle_rec = MLEReconstructor(dimension=2)

run_single_reconstruction(linear_rec, probs)  # è°ƒç”¨ Linear.reconstruct
run_single_reconstruction(mle_rec, probs)     # è°ƒç”¨ MLE.reconstruct
```

**å¥½å¤„**ï¼š
- è°ƒç”¨æ–¹æ— éœ€å…³å¿ƒå…·ä½“ç±»å‹ï¼ˆä¾èµ–æŠ½è±¡ï¼‰
- æ˜“äºæ‰©å±•ï¼ˆæ–°å¢é‡æ„å™¨æ— éœ€ä¿®æ”¹è°ƒç”¨æ–¹ï¼‰
- ç¬¦åˆ**å¼€é—­åŸåˆ™**

### 5.4 ç»„åˆä¼˜äºç»§æ‰¿

**åŸåˆ™**ï¼šä¼˜å…ˆä½¿ç”¨ç»„åˆï¼ˆhas-aï¼‰è€Œéç»§æ‰¿ï¼ˆis-aï¼‰

**é¡¹ç›®ç¤ºä¾‹**ï¼š`ResultRepository`

```python
class ResultRepository:
    """ç»“æœä»“å‚¨ï¼ˆç»„åˆ JSON/CSV æ ¼å¼åŒ–å™¨ï¼‰"""
    
    def __init__(self, records_dir: Path, fmt: str = "json"):
        self.records_dir = records_dir
        # ç»„åˆï¼šåŒ…å«æ ¼å¼åŒ–å™¨å¯¹è±¡
        if fmt == "json":
            self._formatter = JSONFormatter()
        elif fmt == "csv":
            self._formatter = CSVFormatter()
    
    def save(self, record: ReconstructionRecord):
        """ä¿å­˜è®°å½•ï¼ˆå§”æ‰˜ç»™æ ¼å¼åŒ–å™¨ï¼‰"""
        data = self._formatter.serialize(record)
        path = self.records_dir / f"{record.id}.{self._formatter.ext}"
        path.write_text(data)
```

**ä¸ºä»€ä¹ˆç»„åˆä¼˜äºç»§æ‰¿ï¼Ÿ**
- ç»§æ‰¿è€¦åˆå¼ºï¼ˆä¿®æ”¹çˆ¶ç±»å½±å“æ‰€æœ‰å­ç±»ï¼‰
- ç»„åˆçµæ´»ï¼ˆè¿è¡Œæ—¶åˆ‡æ¢æ ¼å¼åŒ–å™¨ï¼‰
- é¿å…å¤šç»§æ‰¿çš„å¤æ‚æ€§

---

## è®¡ç®—æœºåŸºç¡€çŸ¥è¯†

### 6.1 è¿›ç¨‹ä¸çº¿ç¨‹

**å®šä¹‰**ï¼š
- **è¿›ç¨‹**ï¼šæ“ä½œç³»ç»Ÿèµ„æºåˆ†é…çš„åŸºæœ¬å•ä½ï¼Œæ‹¥æœ‰ç‹¬ç«‹å†…å­˜ç©ºé—´
- **çº¿ç¨‹**ï¼šCPU è°ƒåº¦çš„åŸºæœ¬å•ä½ï¼Œå…±äº«è¿›ç¨‹å†…å­˜

**å¯¹æ¯”**ï¼š

| ç»´åº¦ | è¿›ç¨‹ | çº¿ç¨‹ |
|------|------|------|
| å†…å­˜ | ç‹¬ç«‹åœ°å€ç©ºé—´ | å…±äº«è¿›ç¨‹å†…å­˜ |
| é€šä¿¡ | IPCï¼ˆç®¡é“ã€æ¶ˆæ¯é˜Ÿåˆ—ï¼‰ | å…±äº«å˜é‡ |
| å¼€é”€ | åˆ›å»º/åˆ‡æ¢æˆæœ¬é«˜ | åˆ›å»º/åˆ‡æ¢æˆæœ¬ä½ |
| ç¨³å®šæ€§ | ä¸€ä¸ªè¿›ç¨‹å´©æºƒä¸å½±å“å…¶ä»–è¿›ç¨‹ | ä¸€ä¸ªçº¿ç¨‹å´©æºƒå¯¼è‡´è¿›ç¨‹å´©æºƒ |

**Python å¤šçº¿ç¨‹ä¸ GIL**ï¼š
- **GILï¼ˆGlobal Interpreter Lockï¼‰**ï¼šå…¨å±€è§£é‡Šå™¨é”ï¼ŒåŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œ Python å­—èŠ‚ç 
- **å½±å“**ï¼šå¤šçº¿ç¨‹æ— æ³•åˆ©ç”¨å¤šæ ¸ CPUï¼ˆè®¡ç®—å¯†é›†å‹ä»»åŠ¡ï¼‰
- **é€‚ç”¨åœºæ™¯**ï¼š
  - âœ… I/O å¯†é›†å‹ä»»åŠ¡ï¼ˆæ–‡ä»¶è¯»å†™ã€ç½‘ç»œè¯·æ±‚ï¼‰
  - âŒ è®¡ç®—å¯†é›†å‹ä»»åŠ¡ï¼ˆç”¨ `multiprocessing` æˆ– NumPy/C æ‰©å±•ï¼‰

**é¡¹ç›®ä¸­çš„åº”ç”¨**ï¼ˆå¦‚æœæ‰©å±•ï¼‰ï¼š
```python
from concurrent.futures import ProcessPoolExecutor

def batch_reconstruct_parallel(samples: List[np.ndarray], dimension: int):
    """å¹¶è¡Œé‡æ„ï¼ˆå¤šè¿›ç¨‹ï¼‰"""
    with ProcessPoolExecutor(max_workers=4) as executor:
        results = executor.map(reconstruct_worker, samples)
    return list(results)

def reconstruct_worker(probs):
    """å·¥ä½œè¿›ç¨‹"""
    reconstructor = LinearReconstructor(dimension=2)
    return reconstructor.reconstruct(probs)
```

**é¢è¯•é—®é¢˜**ï¼š
1. **Python å¦‚ä½•å®ç°å¹¶è¡Œï¼Ÿ**
   - CPU å¯†é›†å‹ï¼š`multiprocessing`ï¼ˆå¤šè¿›ç¨‹ï¼‰
   - I/O å¯†é›†å‹ï¼š`threading`ï¼ˆå¤šçº¿ç¨‹ï¼‰æˆ– `asyncio`ï¼ˆåç¨‹ï¼‰
   - è®¡ç®—åº“ï¼šNumPy/SciPy å†…éƒ¨å·²å¹¶è¡Œï¼ˆåº•å±‚ C/Fortranï¼‰

2. **å¦‚ä½•é¿å…çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Ÿ**
   - ä½¿ç”¨é”ï¼ˆ`threading.Lock`ï¼‰
   - ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„ï¼ˆ`queue.Queue`ï¼‰
   - é¿å…å…±äº«å¯å˜çŠ¶æ€

### 6.2 å†…å­˜ç®¡ç†

**Python å†…å­˜ç®¡ç†æœºåˆ¶**ï¼š
1. **å¼•ç”¨è®¡æ•°**ï¼šå¯¹è±¡è¢«å¼•ç”¨æ—¶è®¡æ•° +1ï¼Œåˆ é™¤å¼•ç”¨æ—¶ -1ï¼Œè®¡æ•°ä¸º 0 æ—¶å›æ”¶
2. **å¾ªç¯åƒåœ¾å›æ”¶**ï¼šæ£€æµ‹å¼•ç”¨å¾ªç¯ï¼ˆA â†’ B â†’ Aï¼‰ï¼Œå®šæœŸæ¸…ç†
3. **å†…å­˜æ± **ï¼šå°å¯¹è±¡ï¼ˆ< 256 å­—èŠ‚ï¼‰ä½¿ç”¨ pymalloc åˆ†é…å™¨ï¼Œå‡å°‘ç¢ç‰‡

**é¡¹ç›®ä¸­çš„å†…å­˜ä¼˜åŒ–**ï¼š
```python
# âŒ å†…å­˜æµªè´¹ï¼šåˆ›å»ºä¸´æ—¶å‰¯æœ¬
def bad_normalize(matrix):
    temp = matrix.copy()  # é¢å¤–å†…å­˜
    temp = temp / np.trace(temp)
    return temp

# âœ… åŸåœ°æ“ä½œ
def good_normalize(matrix):
    matrix /= np.trace(matrix)  # åŸåœ°ä¿®æ”¹
    return matrix
```

**NumPy å†…å­˜ç®¡ç†**ï¼š
- **è§†å›¾ vs å‰¯æœ¬**ï¼š
  ```python
  a = np.array([1, 2, 3, 4])
  b = a[1:3]  # è§†å›¾ï¼ˆå…±äº«å†…å­˜ï¼‰
  c = a[1:3].copy()  # å‰¯æœ¬ï¼ˆç‹¬ç«‹å†…å­˜ï¼‰
  
  b[0] = 999  # a ä¹Ÿå˜åŒ–
  c[0] = 999  # a ä¸å˜
  ```

**é¢è¯•é—®é¢˜**ï¼š
1. **å¦‚ä½•æ£€æµ‹å†…å­˜æ³„æ¼ï¼Ÿ**
   - ä½¿ç”¨ `tracemalloc` æ¨¡å—
   - ä½¿ç”¨ `memory_profiler` å·¥å…·

2. **å¦‚ä½•å‡å°‘å†…å­˜å ç”¨ï¼Ÿ**
   - ä½¿ç”¨ç”Ÿæˆå™¨ä»£æ›¿åˆ—è¡¨ï¼ˆå»¶è¿Ÿè®¡ç®—ï¼‰
   - åŠæ—¶åˆ é™¤ä¸ç”¨çš„å¤§å¯¹è±¡ï¼ˆ`del`ï¼‰
   - ä½¿ç”¨ NumPy åŸåœ°æ“ä½œ

### 6.3 æ—¶é—´å¤æ‚åº¦ä¸ç©ºé—´å¤æ‚åº¦

**é¡¹ç›®ä¸­çš„å¤æ‚åº¦åˆ†æ**ï¼š

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å¤‡æ³¨ |
|------|-----------|-----------|------|
| ç”ŸæˆæŠ•å½±ç®—ç¬¦ | $O(n^4)$ | $O(n^4)$ | éœ€ç¼“å­˜ |
| çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£ | $O(n^6)$ | $O(n^4)$ | ä½¿ç”¨ `lstsq` |
| ç‰¹å¾å€¼åˆ†è§£ | $O(n^3)$ | $O(n^2)$ | ä½¿ç”¨ `eigh` |
| MLE å•æ¬¡è¿­ä»£ | $O(n^3)$ | $O(n^2)$ | çŸ©é˜µä¹˜æ³• |

**ä¼˜åŒ–æ€è·¯**ï¼š
- **ç¼“å­˜**ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜åï¼Œæ‰¹å¤„ç†ä» $O(mn^4)$ é™è‡³ $O(n^4 + mn^3)$ï¼ˆ$m$ ä¸ºæ ·æœ¬æ•°ï¼‰
- **ç¨€ç–çŸ©é˜µ**ï¼šè‹¥ç³»æ•°çŸ©é˜µç¨€ç–ï¼Œå¯ç”¨ `scipy.sparse`ï¼ˆæœ¬é¡¹ç›®å¯†é›†çŸ©é˜µï¼‰
- **ä½ç§©è¿‘ä¼¼**ï¼šè‹¥å¯†åº¦çŸ©é˜µä½ç§©ï¼Œå¯ç”¨ SVD é™ç»´ï¼ˆæœ¬é¡¹ç›®æœªåº”ç”¨ï¼‰

**é¢è¯•ç­”é¢˜æ¨¡æ¿**ï¼š
> "è¿™ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$ï¼Œå› ä¸ºæ¶‰åŠçŸ©é˜µä¹˜æ³•ã€‚æˆ‘ä»¬é€šè¿‡ç¼“å­˜æŠ•å½±ç®—ç¬¦å°†æ‰¹å¤„ç†çš„å¤æ‚åº¦ä» $O(mn^4)$ ä¼˜åŒ–åˆ° $O(n^4 + mn^3)$ï¼Œåœ¨å®é™…æµ‹è¯•ä¸­å°† 100 ä¸ªæ ·æœ¬çš„å¤„ç†æ—¶é—´ä» 50 ç§’é™è‡³ 5 ç§’ã€‚"

---

## è½¯ä»¶å·¥ç¨‹å®è·µ

### 7.1 æµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTDDï¼‰

**ç†å¿µ**ï¼šå…ˆå†™æµ‹è¯•ï¼Œå†å†™ä»£ç ï¼Œä¿è¯ä»£ç å¯æµ‹è¯•å’Œæ­£ç¡®æ€§

**é¡¹ç›®ä¸­çš„æµ‹è¯•åˆ†å±‚**ï¼š

```
tests/
â”œâ”€â”€ unit/                   # å•å…ƒæµ‹è¯•ï¼ˆ106 ä¸ªï¼Œ100% é€šè¿‡ï¼‰
â”‚   â”œâ”€â”€ test_density.py                  # å¯†åº¦çŸ©é˜µæ ¸å¿ƒé€»è¾‘ï¼ˆ27ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_density_performance.py      # æ€§èƒ½æµ‹è¯•ï¼ˆ12ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_linear_reconstructor.py     # çº¿æ€§é‡æ„ç®—æ³•ï¼ˆ6ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_mle_reconstructor.py        # MLE é‡æ„ç®—æ³•ï¼ˆ5ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_controller.py               # æ‰¹å¤„ç†æ§åˆ¶å™¨ï¼ˆ4ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_cli.py                      # CLI å‘½ä»¤ï¼ˆ8ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_analysis_metrics.py         # æŒ‡æ ‡è®¡ç®—ï¼ˆ5ä¸ªæµ‹è¯•ï¼‰ğŸ†•
â”‚   â”œâ”€â”€ test_analysis_comparison.py      # æ–¹æ³•å¯¹æ¯”ï¼ˆ3ä¸ªæµ‹è¯•ï¼‰ğŸ†•
â”‚   â”œâ”€â”€ test_bell_analysis.py            # Bellåˆ†æï¼ˆ5ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_projectors.py               # æŠ•å½±ç®—ç¬¦ï¼ˆ6ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_result_repository.py        # ç»“æœæŒä¹…åŒ–ï¼ˆ4ä¸ªæµ‹è¯•ï¼‰
â”‚   â”œâ”€â”€ test_config_io.py                # é…ç½®ç®¡ç†ï¼ˆ8ä¸ªæµ‹è¯•ï¼‰
â”‚   â””â”€â”€ test_visualization.py            # å¯è§†åŒ–ï¼ˆ4ä¸ªæµ‹è¯•ï¼‰
â””â”€â”€ integration/            # é›†æˆæµ‹è¯•ï¼ˆåŒ…å«åœ¨ unit ä¸­ï¼‰
    â”œâ”€â”€ test_linear_reconstruction.py  # å®Œæ•´æµç¨‹
    â””â”€â”€ test_matlab_comparison.py      # MATLAB åŸºå‡†å¯¹æ¯”ï¼ˆè¯¯å·® < 1e-10ï¼‰
```

**å•å…ƒæµ‹è¯•ç¤ºä¾‹**ï¼š
```python
import pytest
import numpy as np

def test_density_matrix_purity():
    """æµ‹è¯•çº¯æ€çš„çº¯åº¦ = 1"""
    # çº¯æ€ï¼š|0âŸ©âŸ¨0|
    pure_state = np.array([[1, 0], [0, 0]], dtype=complex)
    density = DensityMatrix(pure_state)
    
    assert np.isclose(density.purity, 1.0)

def test_density_matrix_trace():
    """æµ‹è¯•å¯†åº¦çŸ©é˜µçš„è¿¹ = 1"""
    mixed_state = np.array([[0.7, 0], [0, 0.3]], dtype=complex)
    density = DensityMatrix(mixed_state)
    
    assert np.isclose(density.trace, 1.0)

def test_density_matrix_physical_constraints():
    """æµ‹è¯•ç‰©ç†çº¦æŸä¿®æ­£"""
    # æ•…æ„æ„é€ éç‰©ç†çŸ©é˜µï¼ˆè´Ÿç‰¹å¾å€¼ï¼‰
    bad_matrix = np.array([[1.2, 0], [0, -0.2]], dtype=complex)
    density = DensityMatrix(bad_matrix)
    
    # éªŒè¯ä¿®æ­£åæ»¡è¶³çº¦æŸ
    assert np.all(density.eigenvalues >= 0)  # åŠæ­£å®š
    assert np.isclose(density.trace, 1.0)    # è¿¹ä¸º1
```

**é›†æˆæµ‹è¯•ç¤ºä¾‹**ï¼š
```python
def test_matlab_alignment_dim4():
    """æµ‹è¯•ä¸ MATLAB åŸºå‡†å¯¹é½ï¼ˆ4 ç»´ï¼‰"""
    # åŠ è½½ MATLAB å‚è€ƒæ•°æ®
    matlab_data = scipy.io.loadmat("rho_matlab_alignment_dim4.mat")
    matlab_rho = matlab_data["rho"]
    matlab_purity = matlab_data["purity"][0, 0]
    
    # Python é‡æ„
    probs = matlab_data["probabilities"].flatten()
    reconstructor = LinearReconstructor(dimension=4)
    result = reconstructor.reconstruct(probs)
    
    # å¯¹æ¯”ï¼ˆè¯¯å·® < 1e-10ï¼‰
    np.testing.assert_allclose(result.density.matrix, matlab_rho, atol=1e-10)
    np.testing.assert_allclose(result.density.purity, matlab_purity, atol=1e-10)
```

**æµ‹è¯•è¦†ç›–ç‡**ï¼š
- **ç›®æ ‡**ï¼šæ ¸å¿ƒæ¨¡å— > 80%
- **å·¥å…·**ï¼š`pytest-cov`
- **å‘½ä»¤**ï¼š`pytest --cov=qtomography --cov-report=html`

**é¢è¯•é—®é¢˜**ï¼š
1. **å•å…ƒæµ‹è¯• vs é›†æˆæµ‹è¯•ï¼Ÿ**
   - **å•å…ƒæµ‹è¯•**ï¼šæµ‹è¯•å•ä¸ªå‡½æ•°/ç±»ï¼Œé€Ÿåº¦å¿«ï¼Œæ˜“å®šä½é—®é¢˜
   - **é›†æˆæµ‹è¯•**ï¼šæµ‹è¯•å¤šä¸ªæ¨¡å—åä½œï¼Œæ›´æ¥è¿‘çœŸå®åœºæ™¯

2. **å¦‚ä½•æé«˜æµ‹è¯•è´¨é‡ï¼Ÿ**
   - è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼ˆç©ºè¾“å…¥ã€è¶…å¤§è¾“å…¥ã€å¼‚å¸¸è¾“å…¥ï¼‰
   - å‚æ•°åŒ–æµ‹è¯•ï¼ˆ`@pytest.mark.parametrize`ï¼‰
   - Mock å¤–éƒ¨ä¾èµ–ï¼ˆæ–‡ä»¶ã€ç½‘ç»œã€æ•°æ®åº“ï¼‰

### 7.2 ç‰ˆæœ¬æ§åˆ¶ï¼ˆGitï¼‰

**åˆ†æ”¯ç­–ç•¥**ï¼š
- `main`ï¼šç¨³å®šåˆ†æ”¯ï¼Œå§‹ç»ˆå¯éƒ¨ç½²
- `develop`ï¼šå¼€å‘åˆ†æ”¯ï¼Œé›†æˆæ–°åŠŸèƒ½
- `feature/xxx`ï¼šåŠŸèƒ½åˆ†æ”¯ï¼ˆå¦‚ `feature/stage3-metrics`ï¼‰
- `hotfix/xxx`ï¼šç´§æ€¥ä¿®å¤åˆ†æ”¯

**æäº¤è§„èŒƒ**ï¼ˆConventional Commitsï¼‰ï¼š
```
feat: æ·»åŠ  MLE é‡æ„ç®—æ³•
fix: ä¿®å¤å¯†åº¦çŸ©é˜µå½’ä¸€åŒ–bug
docs: æ›´æ–° README ä½¿ç”¨è¯´æ˜
test: æ·»åŠ  controller å•å…ƒæµ‹è¯•
refactor: é‡æ„æŠ•å½±ç®—ç¬¦ç¼“å­˜é€»è¾‘
perf: ä¼˜åŒ–çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£é€Ÿåº¦
```

**å¸¸ç”¨å‘½ä»¤**ï¼š
```bash
# åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feature/new-feature

# æäº¤ä»£ç 
git add qtomography/
git commit -m "feat: æ·»åŠ  Bell æ€åˆ†æåŠŸèƒ½"

# æ¨é€åˆ†æ”¯
git push origin feature/new-feature

# åˆå¹¶åˆ° develop
git checkout develop
git merge feature/new-feature

# æŸ¥çœ‹å†å²
git log --oneline --graph
```

### 7.3 ä»£ç å®¡æŸ¥ï¼ˆCode Reviewï¼‰

**æ£€æŸ¥è¦ç‚¹**ï¼š
1. **åŠŸèƒ½æ­£ç¡®æ€§**ï¼šé€»è¾‘æ˜¯å¦æ­£ç¡®ï¼Œè¾¹ç•Œæƒ…å†µæ˜¯å¦å¤„ç†
2. **ä»£ç è´¨é‡**ï¼šå‘½åã€æ³¨é‡Šã€ç»“æ„æ˜¯å¦æ¸…æ™°
3. **æ€§èƒ½**ï¼šæ˜¯å¦æœ‰æ˜æ˜¾æ€§èƒ½é—®é¢˜
4. **æµ‹è¯•**ï¼šæ˜¯å¦æœ‰å¯¹åº”æµ‹è¯•ï¼Œè¦†ç›–ç‡æ˜¯å¦è¶³å¤Ÿ
5. **å®‰å…¨**ï¼šæ˜¯å¦æœ‰å®‰å…¨æ¼æ´ï¼ˆSQL æ³¨å…¥ã€XSS ç­‰ï¼Œæœ¬é¡¹ç›®ä¸æ¶‰åŠï¼‰

**é¡¹ç›®ä¸­çš„æœ€ä½³å®è·µ**ï¼š
- æ¯ä¸ª PR åŒ…å«æµ‹è¯•
- ä»£ç éµå¾ª PEP 8 è§„èŒƒï¼ˆä½¿ç”¨ `black` æ ¼å¼åŒ–ï¼‰
- å‡½æ•°æœ‰ç±»å‹æç¤ºå’Œæ–‡æ¡£å­—ç¬¦ä¸²
- å•ä¸ª PR ä¸è¶…è¿‡ 500 è¡Œï¼ˆä¾¿äºå®¡æŸ¥ï¼‰

### 7.4 æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²ï¼ˆCI/CDï¼‰

**æ¦‚å¿µ**ï¼š
- **CI**ï¼šæ¯æ¬¡æäº¤è‡ªåŠ¨è¿è¡Œæµ‹è¯•ã€ä»£ç æ£€æŸ¥
- **CD**ï¼šæµ‹è¯•é€šè¿‡åè‡ªåŠ¨éƒ¨ç½²

**å·¥å…·**ï¼šGitHub Actions, GitLab CI, Jenkins

**ç¤ºä¾‹é…ç½®**ï¼ˆ`.github/workflows/test.yml`ï¼‰ï¼š
```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - run: pip install -r requirements.txt
      - run: pytest --cov=qtomography
      - run: black --check qtomography/
```

---

## å¸¸è§é¢è¯•é—®é¢˜åŠå›ç­”

### 8.1 é¡¹ç›®ç›¸å…³é—®é¢˜

#### Q1: ä»‹ç»ä¸€ä¸‹ä½ çš„é¡¹ç›®

**å›ç­”æ¨¡æ¿**ï¼š
> "æˆ‘å¼€å‘äº†ä¸€ä¸ªé‡å­æ€å±‚æé‡æ„å·¥å…·åŒ…ï¼Œä¸»è¦è§£å†³é‡å­ä¿¡æ¯ç§‘å­¦ä¸­çš„æ€é‡æ„é—®é¢˜ã€‚é¡¹ç›®è§„æ¨¡çº¦ 5000 è¡Œä»£ç ï¼Œé‡‡ç”¨**å››å±‚æ¶æ„**ï¼ˆæ¥å£å±‚ã€åº”ç”¨å±‚ã€é¢†åŸŸå±‚ã€åŸºç¡€è®¾æ–½å±‚ï¼‰è®¾è®¡ï¼Œå®ç°äº†**çº¿æ€§é‡æ„å’Œ MLE ä¸¤ç§æ ¸å¿ƒç®—æ³•**ã€‚
>
> æŠ€æœ¯æ ˆæ–¹é¢ï¼Œä½¿ç”¨ **Python + NumPy + SciPy** è¿›è¡Œæ•°å€¼è®¡ç®—ï¼Œ**Pandas** å¤„ç†æ•°æ®åˆ†æï¼Œ**Pytest** è¿›è¡Œæµ‹è¯•ï¼ˆå…± **106 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ100% é€šè¿‡ï¼Œè¦†ç›–ç‡ 90%**ï¼‰ï¼Œ**argparse** æ„å»º CLI å·¥å…·ã€‚
>
> åœ¨æ¶æ„è®¾è®¡ä¸Šï¼Œæˆ‘åº”ç”¨äº†**å·¥å‚æ¨¡å¼ã€ç­–ç•¥æ¨¡å¼ã€ä»“å‚¨æ¨¡å¼**ç­‰è®¾è®¡æ¨¡å¼ï¼Œéµå¾ª **SOLID åŸåˆ™**ï¼Œä¿è¯ä»£ç çš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
>
> é¡¹ç›®äº®ç‚¹åŒ…æ‹¬ï¼š
> 1. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡æŠ•å½±ç®—ç¬¦ç¼“å­˜ï¼Œå°†æ‰¹å¤„ç†æ€§èƒ½æå‡ 10 å€
> 2. **æ•°å€¼ç²¾åº¦**ï¼šä¸ MATLAB åŸºå‡†å¯¹é½ï¼Œè¯¯å·® < 1e-10
> 3. **å®Œæ•´æµ‹è¯•**ï¼š106 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–ç‡ 90%ï¼ŒåŒ…å«æ€§èƒ½æµ‹è¯•
> 4. **å·¥ç¨‹åŒ–å®è·µ**ï¼šCLI å·¥å…·ã€æ‰¹å¤„ç†ã€é…ç½®ç®¡ç†ã€é”™è¯¯å¤„ç†
>
> åœ¨æœ€è¿‘å®Œæˆçš„ **Stage 3 è¿­ä»£**ä¸­ï¼Œæˆ‘ï¼š
> - æ‰©å±•äº†æŒ‡æ ‡ç³»ç»Ÿï¼ˆæ–°å¢ 8 ä¸ªå­—æ®µï¼ŒåŒ…æ‹¬æ¡ä»¶æ•°ã€ç‰¹å¾å€¼ç†µç­‰ï¼‰
> - å®ç°äº† **Linear vs MLE çš„æ–¹æ³•å¯¹æ¯”åŠŸèƒ½**ï¼ˆè‡ªåŠ¨é…å¯¹æ ·æœ¬ã€è®¡ç®—å·®å¼‚ç»Ÿè®¡ï¼‰
> - æ–°å¢ **comparison æ¨¡å—**ï¼ˆ99 è¡Œï¼‰ï¼Œæä¾›è¯¦ç»†ç»Ÿè®¡ï¼ˆæœ€å°å€¼ã€åˆ†ä½æ•°ã€æœ€å¤§å€¼ï¼‰
> - éµå¾ª**å•ä¸€æ•°æ®æºåŸåˆ™**ï¼Œç¡®ä¿ JSON å’Œ CSV æ•°æ®ä¸€è‡´æ€§
> - é€šè¿‡ **5 ä¸ªæ–°å¢æµ‹è¯•**éªŒè¯åŠŸèƒ½æ­£ç¡®æ€§ï¼Œä½¿ç”¨ `np.isclose()` å¤„ç†æµ®ç‚¹ç²¾åº¦
>
> **é¡¹ç›®çŠ¶æ€**ï¼šå·²å®Œæˆå¼€å‘ï¼Œæ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼Œä»£ç å·²æäº¤ï¼Œç”Ÿäº§å°±ç»ªã€‚"

#### Q2: é¡¹ç›®ä¸­é‡åˆ°çš„æœ€å¤§æŠ€æœ¯æŒ‘æˆ˜æ˜¯ä»€ä¹ˆï¼Ÿ

**å›ç­”æ¨¡æ¿**ï¼š

> "æœ€å¤§çš„æŠ€æœ¯æŒ‘æˆ˜æ˜¯**ä¿è¯æ•°å€¼ç¨³å®šæ€§å’Œç‰©ç†çº¦æŸ**ã€‚å…·ä½“æ¥è¯´ï¼š
>
> **é—®é¢˜ 1ï¼šå¯†åº¦çŸ©é˜µçš„ç‰©ç†çº¦æŸ**
> é‡å­åŠ›å­¦è¦æ±‚å¯†åº¦çŸ©é˜µå¿…é¡»æ˜¯å„ç±³çš„ã€åŠæ­£å®šçš„ã€è¿¹ä¸º1çš„ï¼Œä½†æ•°å€¼è®¡ç®—ä¼šå¼•å…¥è¯¯å·®ï¼Œå¯¼è‡´è¿™äº›çº¦æŸè¢«è¿åã€‚
>
> **è§£å†³æ–¹æ¡ˆ**ï¼šæˆ‘å®ç°äº† `makephysical` ç®—æ³•ï¼š
> 1. å¼ºåˆ¶å„ç±³æ€§ï¼š$(Ï + Ï^\dagger) / 2$
> 2. ç‰¹å¾å€¼åˆ†è§£ï¼Œè£å‰ªè´Ÿç‰¹å¾å€¼
> 3. é‡æ–°å½’ä¸€åŒ–ï¼Œç¡®ä¿è¿¹ä¸º1
> 4. ä½¿ç”¨è£å‰ªåçš„ç‰¹å¾å€¼é‡æ„çŸ©é˜µ
>
> **é—®é¢˜ 2ï¼šçº¿æ€§æ–¹ç¨‹ç»„ç—…æ€**
> ç³»æ•°çŸ©é˜µæ¡ä»¶æ•°å¾ˆå¤§ï¼ˆå¯è¾¾ $10^{15}$ï¼‰ï¼Œç›´æ¥æ±‚è§£ä¼šå¯¼è‡´æ•°å€¼ä¸ç¨³å®šã€‚
>
> **è§£å†³æ–¹æ¡ˆ**ï¼šå¼•å…¥å²­å›å½’ï¼ˆTikhonovæ­£åˆ™åŒ–ï¼‰ï¼š
> - åœ¨ç›®æ ‡å‡½æ•°ä¸­æ·»åŠ æ­£åˆ™é¡¹ï¼š$\min ||Ax - b||^2 + \lambda ||x||^2$
> - è§£æè§£ï¼š$x = (A^T A + \lambda I)^{-1} A^T b$
> - æ­£åˆ™åŒ–ç³»æ•° $\lambda$ é€šè¿‡äº¤å‰éªŒè¯ç¡®å®šï¼ˆå…¸å‹å€¼ $10^{-6}$ï¼‰
>
> **éªŒè¯**ï¼šé€šè¿‡ä¸ MATLAB åŸºå‡†å¯¹æ¯”ï¼Œç¡®ä¿é‡æ„ç»“æœçš„è¯¯å·® < 1e-10ï¼Œè¯æ˜æ–¹æ¡ˆæœ‰æ•ˆã€‚
>
> **æ”¶è·**ï¼šè¿™ä¸ªè¿‡ç¨‹è®©æˆ‘æ·±å…¥ç†è§£äº†æ•°å€¼è®¡ç®—çš„ç¨³å®šæ€§é—®é¢˜ï¼Œä»¥åŠå¦‚ä½•åœ¨ç†è®ºå’Œå·¥ç¨‹å®è·µä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚"

#### Q3: å¦‚ä½•ä¿è¯ä»£ç è´¨é‡ï¼Ÿ

**å›ç­”æ¨¡æ¿**ï¼š

> "æˆ‘é‡‡ç”¨äº†å¤šå±‚æ¬¡çš„è´¨é‡ä¿è¯ç­–ç•¥ï¼š
>
> **1. æµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTDDï¼‰**
> - 36 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ˆ11 ä¸ªå•å…ƒæµ‹è¯• + 5 ä¸ªé›†æˆæµ‹è¯•ï¼‰
> - ä½¿ç”¨ `pytest` æ¡†æ¶ï¼Œæ”¯æŒå‚æ•°åŒ–æµ‹è¯•å’Œ fixture
> - ä¸ MATLAB åŸºå‡†å¯¹é½æµ‹è¯•ï¼Œç¡®ä¿æ•°å€¼ç²¾åº¦
>
> **2. ä»£ç è§„èŒƒ**
> - éµå¾ª PEP 8 è§„èŒƒï¼Œä½¿ç”¨ `black` è‡ªåŠ¨æ ¼å¼åŒ–
> - ç±»å‹æç¤ºï¼ˆType Hintsï¼‰æå‡ä»£ç å¯è¯»æ€§
> - æ–‡æ¡£å­—ç¬¦ä¸²ï¼ˆDocstringï¼‰è¯´æ˜å‡½æ•°ç”¨é€”å’Œå‚æ•°
>
> **3. åˆ†å±‚æ¶æ„**
> - æ¸…æ™°çš„èŒè´£åˆ†ç¦»ï¼Œé™ä½æ¨¡å—è€¦åˆ
> - ä¾¿äºå•ç‹¬æµ‹è¯•æ¯ä¸€å±‚ï¼ˆå¦‚é¢†åŸŸå±‚ä¸ä¾èµ– CLIï¼‰
>
> **4. ä»£ç å®¡æŸ¥**
> - æ¯ä¸ªåŠŸèƒ½åˆ†æ”¯éƒ½æœ‰å¯¹åº”çš„æµ‹è¯•
> - æäº¤å‰è¿è¡Œæµ‹è¯•ï¼Œç¡®ä¿æ²¡æœ‰ç ´åç°æœ‰åŠŸèƒ½
> - éµå¾ª Conventional Commits è§„èŒƒ
>
> **5. æŒç»­è¿­ä»£**
> - é€šè¿‡ 3 ä¸ªä¸»è¦é˜¶æ®µé€æ­¥å®Œå–„åŠŸèƒ½
> - Stage 3 æ–°å¢äº† 8 ä¸ªæŒ‡æ ‡å­—æ®µå’Œæ–¹æ³•å¯¹æ¯”åŠŸèƒ½
> - æ¯ä¸ªé˜¶æ®µéƒ½æœ‰è¯¦ç»†çš„è®¾è®¡æ–‡æ¡£å’Œæµ‹è¯•éªŒè¯"

#### Q4: Stage 3 åšäº†ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾è®¡ï¼Ÿ

**å›ç­”æ¨¡æ¿**ï¼š

> "Stage 3 æ˜¯**æŒ‡æ ‡æ‰©å±•ä¸æŠ¥å‘Šå¢å¼º**é˜¶æ®µï¼Œä¸»è¦è§£å†³æ•°æ®åˆ†æå’Œæ–¹æ³•å¯¹æ¯”çš„éœ€æ±‚ã€‚
>
> **èƒŒæ™¯**ï¼š
> - åŸæœ‰ `summary.csv` åªæœ‰åŸºç¡€æŒ‡æ ‡ï¼ˆpurity, trace, fidelityï¼‰
> - ç¼ºå°‘ç®—æ³•æ€§èƒ½æŒ‡æ ‡ï¼ˆè¿­ä»£æ¬¡æ•°ã€æˆåŠŸç‡ï¼‰
> - æ— æ³•ç›´è§‚å¯¹æ¯” Linear å’Œ MLE çš„ä¼˜åŠ£
>
> **å®ç°**ï¼š
> 
> **1. æ‰©å±• summary.csv å­—æ®µ**ï¼ˆæ–°å¢ 8 ä¸ªå­—æ®µï¼‰
> - P1 æ ¸å¿ƒå­—æ®µï¼š`rank`, `min_eigenvalue`, `max_eigenvalue`, `n_iterations`, `n_evaluations`, `success`
> - P2 å¯é€‰å­—æ®µï¼š`condition_number`ï¼ˆæ•°å€¼ç¨³å®šæ€§ï¼‰, `eigenvalue_entropy`ï¼ˆæ··åˆåº¦ï¼‰
>
> **2. æ•°æ®ä¸€è‡´æ€§è®¾è®¡**
> - ç­–ç•¥ï¼šå…ˆå†™ JSON `record.metrics`ï¼Œå†ä» `record.metrics` è¯»åˆ° CSV
> - å¥½å¤„ï¼šå•ä¸€æ•°æ®æºï¼Œé¿å…ä¸ä¸€è‡´ï¼›ä¾¿äºè°ƒè¯•å’Œå›æº¯
>
> **3. CLI å¢å¼º**
> - `--compare-methods`ï¼šLinear vs MLE å¯¹æ¯”æŠ¥è¡¨ï¼ˆè‡ªåŠ¨é…å¯¹æ ·æœ¬ï¼Œæ˜¾ç¤ºå·®å¼‚ï¼‰
> - `--detailed`ï¼šè¯¦ç»†ç»Ÿè®¡ï¼ˆæœ€å°å€¼ã€25%ã€ä¸­ä½æ•°ã€75%ã€æœ€å¤§å€¼ï¼‰
> - `--output`ï¼šä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶ï¼ˆCSV/JSONï¼‰
>
> **4. æ•°å€¼ç¨³å®šæ€§å¤„ç†**
> ```python
> def _calculate_condition_number(singular_values):
>     if min_sv < 1e-12 * max_sv:
>         return 1e16  # é¿å… infï¼Œé˜²æ­¢ CSV æ ¼å¼åŒ–é—®é¢˜
>     return max_sv / min_sv
> ```
>
> **5. æµ‹è¯•è¦†ç›–**
> - æ–°å¢ 5 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ˆ`test_run_batch_metrics_fields`, `test_cli_summarize_compare_methods` ç­‰ï¼‰
> - ä½¿ç”¨ `np.isclose()` å¤„ç†æµ®ç‚¹ç²¾åº¦é—®é¢˜
>
> **æ”¶è·**ï¼š
> - å­¦ä¼šäº†æ•°æ®ä¸€è‡´æ€§è®¾è®¡ï¼ˆå•ä¸€æ•°æ®æºåŸåˆ™ï¼‰
> - ç†è§£äº† CLI å·¥å…·çš„è®¾è®¡æ¨¡å¼ï¼ˆargparse å­å‘½ä»¤ã€å‚æ•°éªŒè¯ï¼‰
> - æŒæ¡äº†æµ®ç‚¹æ•°æ¯”è¾ƒçš„æœ€ä½³å®è·µ"

#### Q5: å¦‚æœè¦æ‰©å±•æ–°çš„é‡æ„ç®—æ³•ï¼Œå¦‚ä½•è®¾è®¡ï¼Ÿ

**å›ç­”æ¨¡æ¿**ï¼š

> "æˆ‘ä¼šéµå¾ª**å¼€é—­åŸåˆ™**ï¼ˆå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ï¼‰ï¼Œå…·ä½“æ­¥éª¤ï¼š
>
> **1. å®šä¹‰æŠ½è±¡åŸºç±»**ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
> ```python
> from abc import ABC, abstractmethod
> 
> class BaseReconstructor(ABC):
>     def __init__(self, dimension: int, tolerance: float = 1e-9):
>         self.dimension = dimension
>         self.tolerance = tolerance
>     
>     @abstractmethod
>     def reconstruct(self, probabilities: np.ndarray) -> ReconstructionResult:
>         \"\"\"æŠ½è±¡æ–¹æ³•ï¼šå­ç±»å¿…é¡»å®ç°\"\"\"
>         pass
> ```
>
> **2. å®ç°æ–°ç®—æ³•**
> ```python
> class BayesianReconstructor(BaseReconstructor):
>     \"\"\"è´å¶æ–¯é‡æ„ç®—æ³•\"\"\"
>     
>     def reconstruct(self, probabilities: np.ndarray) -> BayesianResult:
>         # å®ç°è´å¶æ–¯é‡æ„é€»è¾‘
>         projectors = ProjectorSet(self.dimension)
>         # ... ç®—æ³•å®ç°
>         return BayesianResult(density=..., posterior=...)
> ```
>
> **3. ä¿®æ”¹å·¥å‚æ–¹æ³•**
> ```python
> def _create_reconstructor(method: str, config):
>     if method == \"bayesian\":  # æ–°å¢åˆ†æ”¯
>         return BayesianReconstructor(
>             dimension=config.dimension,
>             tolerance=config.tolerance,
>             prior=config.bayesian_prior
>         )
>     # å…¶ä»–æ–¹æ³•ä¸å˜
> ```
>
> **4. æ›´æ–° CLI å‚æ•°**
> ```python
> reconstruct.add_argument(
>     \"--method\",
>     choices=[\"linear\", \"mle\", \"bayesian\", \"both\"],  # æ–°å¢é€‰é¡¹
>     default=\"both\"
> )
> ```
>
> **5. æ·»åŠ æµ‹è¯•**
> ```python
> def test_bayesian_reconstructor():
>     reconstructor = BayesianReconstructor(dimension=2)
>     result = reconstructor.reconstruct(test_probs)
>     assert result.density.trace == pytest.approx(1.0)
> ```
>
> **ä¼˜åŠ¿**ï¼š
> - æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç ï¼ˆControllerã€CLI è°ƒç”¨é€»è¾‘ä¸å˜ï¼‰
> - æ–°æ—§ç®—æ³•å¯äº’æ¢ä½¿ç”¨ï¼ˆé‡Œæ°æ›¿æ¢åŸåˆ™ï¼‰
> - æ˜“äºç»´æŠ¤å’Œæµ‹è¯•"

### 8.2 Python æŠ€æœ¯é—®é¢˜

#### Q6: Python çš„ GIL æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•å¤„ç†ï¼Ÿ

**å›ç­”**ï¼š

> "GILï¼ˆGlobal Interpreter Lockï¼‰æ˜¯ CPython çš„å…¨å±€è§£é‡Šå™¨é”ï¼Œ**åŒä¸€æ—¶åˆ»åªå…è®¸ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œ Python å­—èŠ‚ç **ã€‚
>
> **å½±å“**ï¼š
> - âœ… å•çº¿ç¨‹ç¨‹åºæ— å½±å“
> - âœ… I/O å¯†é›†å‹ä»»åŠ¡å¯ç”¨å¤šçº¿ç¨‹ï¼ˆI/O ç­‰å¾…æ—¶é‡Šæ”¾ GILï¼‰
> - âŒ CPU å¯†é›†å‹ä»»åŠ¡æ— æ³•åˆ©ç”¨å¤šæ ¸ï¼ˆå¤šçº¿ç¨‹ä¹Ÿåªç”¨ä¸€ä¸ªæ ¸å¿ƒï¼‰
>
> **è§£å†³æ–¹æ¡ˆ**ï¼š
>
> **æ–¹æ¡ˆ 1ï¼šå¤šè¿›ç¨‹ï¼ˆ`multiprocessing`ï¼‰**
> ```python
> from concurrent.futures import ProcessPoolExecutor
> 
> def batch_reconstruct_parallel(samples):
>     with ProcessPoolExecutor(max_workers=4) as executor:
>         results = executor.map(reconstruct_worker, samples)
>     return list(results)
> ```
> - ä¼˜ç‚¹ï¼šçœŸæ­£å¹¶è¡Œï¼Œåˆ©ç”¨å¤šæ ¸
> - ç¼ºç‚¹ï¼šè¿›ç¨‹é—´é€šä¿¡å¼€é”€å¤§ï¼Œå†…å­˜å ç”¨é«˜
>
> **æ–¹æ¡ˆ 2ï¼šä½¿ç”¨ C æ‰©å±•åº“**
> ```python
> # NumPy/SciPy åº•å±‚æ˜¯ C/Fortranï¼Œé‡Šæ”¾ GIL
> result = np.linalg.eigh(matrix)  # å†…éƒ¨å¤šçº¿ç¨‹ï¼Œä¸å— GIL é™åˆ¶
> ```
> - ä¼˜ç‚¹ï¼šæ€§èƒ½æé«˜ï¼Œæ— éœ€ä¿®æ”¹ä»£ç 
> - ç¼ºç‚¹ï¼šä»…é™äºæ•°å€¼è®¡ç®—
>
> **æ–¹æ¡ˆ 3ï¼šåç¨‹ï¼ˆ`asyncio`ï¼‰**
> - é€‚ç”¨åœºæ™¯ï¼šI/O å¯†é›†å‹ï¼ˆç½‘ç»œè¯·æ±‚ã€æ–‡ä»¶è¯»å†™ï¼‰
> - æœ¬é¡¹ç›®ä¸æ¶‰åŠå¼‚æ­¥ I/Oï¼Œæš‚æœªä½¿ç”¨
>
> **é¡¹ç›®ä¸­çš„é€‰æ‹©**ï¼š
> - æ ¸å¿ƒè®¡ç®—ä¾èµ– NumPy/SciPyï¼ˆå·²é‡Šæ”¾ GILï¼‰
> - æ‰¹å¤„ç†å¯é€‰å¤šè¿›ç¨‹ï¼ˆæœªå®ç°ï¼Œå› å•æ ·æœ¬å¤„ç†å·²è¶³å¤Ÿå¿«ï¼‰"

#### Q7: Python çš„åƒåœ¾å›æ”¶æœºåˆ¶ï¼Ÿ

**å›ç­”**ï¼š

> "Python é‡‡ç”¨**å¼•ç”¨è®¡æ•° + å¾ªç¯åƒåœ¾å›æ”¶**çš„æ··åˆæœºåˆ¶ï¼š
>
> **1. å¼•ç”¨è®¡æ•°ï¼ˆä¸»è¦æœºåˆ¶ï¼‰**
> - æ¯ä¸ªå¯¹è±¡ç»´æŠ¤ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨
> - å¼•ç”¨ +1ï¼šèµ‹å€¼ã€ä¼ å‚ã€åŠ å…¥å®¹å™¨
> - å¼•ç”¨ -1ï¼šåˆ é™¤å¼•ç”¨ã€ç¦»å¼€ä½œç”¨åŸŸ
> - è®¡æ•°ä¸º 0 æ—¶ç«‹å³å›æ”¶
>
> ```python
> import sys
> a = [1, 2, 3]
> sys.getrefcount(a)  # 2ï¼ˆa æœ¬èº« + getrefcount å‚æ•°ï¼‰
> b = a
> sys.getrefcount(a)  # 3
> del b
> sys.getrefcount(a)  # 2
> ```
>
> **2. å¾ªç¯åƒåœ¾å›æ”¶ï¼ˆè¾…åŠ©æœºåˆ¶ï¼‰**
> - é—®é¢˜ï¼šå¾ªç¯å¼•ç”¨æ— æ³•è¢«å¼•ç”¨è®¡æ•°å›æ”¶
>   ```python
>   a = []
>   b = []
>   a.append(b)
>   b.append(a)  # å¾ªç¯å¼•ç”¨
>   del a, b  # å¼•ç”¨è®¡æ•° > 0ï¼Œä¸ä¼šå›æ”¶
>   ```
> - è§£å†³ï¼šæ ‡è®°-æ¸…é™¤ç®—æ³•ï¼ˆå®šæœŸæ‰«æï¼Œæ£€æµ‹ä¸å¯è¾¾å¯¹è±¡ï¼‰
> - åˆ†ä»£å›æ”¶ï¼šå¯¹è±¡åˆ† 3 ä»£ï¼Œå¹´è½»ä»£å›æ”¶é¢‘ç‡é«˜
>
> **3. æ‰‹åŠ¨æ§åˆ¶**
> ```python
> import gc
> gc.collect()  # æ‰‹åŠ¨è§¦å‘åƒåœ¾å›æ”¶
> gc.disable()  # ç¦ç”¨è‡ªåŠ¨å›æ”¶ï¼ˆæ€§èƒ½æ•æ„Ÿåœºæ™¯ï¼‰
> ```
>
> **é¡¹ç›®ä¸­çš„æœ€ä½³å®è·µ**ï¼š
> - åŠæ—¶åˆ é™¤å¤§å¯¹è±¡ï¼š`del large_array`
> - é¿å…å¾ªç¯å¼•ç”¨ï¼šä½¿ç”¨å¼±å¼•ç”¨ï¼ˆ`weakref`ï¼‰
> - NumPy æ•°ç»„ï¼šC å±‚å†…å­˜ç®¡ç†ï¼Œä¸å— GIL å½±å“"

#### Q8: `@property` vs `@staticmethod` vs `@classmethod`ï¼Ÿ

**å›ç­”**ï¼š

> **1. `@property`**ï¼šå°†æ–¹æ³•è½¬æ¢ä¸ºå±æ€§
> ```python
> class DensityMatrix:
>     @property
>     def purity(self):
>         return np.trace(self._matrix @ self._matrix)
> 
> # ä½¿ç”¨
> density.purity  # åƒå±æ€§ä¸€æ ·è®¿é—®ï¼ˆæ— éœ€æ‹¬å·ï¼‰
> ```
> - ç”¨é€”ï¼šè®¡ç®—å±æ€§ã€åªè¯»å±æ€§ã€getter/setter
>
> **2. `@staticmethod`**ï¼šé™æ€æ–¹æ³•ï¼ˆä¸ä¾èµ–å®ä¾‹å’Œç±»ï¼‰
> ```python
> class MathUtils:
>     @staticmethod
>     def norm(vector):
>         return np.sqrt(np.sum(vector ** 2))
> 
> # ä½¿ç”¨
> MathUtils.norm([3, 4])  # 5.0
> ```
> - ç”¨é€”ï¼šå·¥å…·å‡½æ•°ï¼Œé€»è¾‘ä¸Šå±äºç±»ä½†ä¸éœ€è¦è®¿é—®å®ä¾‹/ç±»å±æ€§
>
> **3. `@classmethod`**ï¼šç±»æ–¹æ³•ï¼ˆæ¥æ”¶ç±»ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼‰
> ```python
> class ProjectorSet:
>     _cache = {}
>     
>     @classmethod
>     def get_cached(cls, dimension):
>         if dimension not in cls._cache:
>             cls._cache[dimension] = cls(dimension)
>         return cls._cache[dimension]
> 
> # ä½¿ç”¨
> proj = ProjectorSet.get_cached(4)
> ```
> - ç”¨é€”ï¼šå·¥å‚æ–¹æ³•ã€å•ä¾‹æ¨¡å¼ã€ç¼“å­˜ç®¡ç†
>
> **å¯¹æ¯”**ï¼š
> | è£…é¥°å™¨ | ç¬¬ä¸€ä¸ªå‚æ•° | è®¿é—®å®ä¾‹å±æ€§ | è®¿é—®ç±»å±æ€§ | å…¸å‹ç”¨é€” |
> |--------|-----------|------------|----------|---------|
> | `@property` | `self` | âœ… | âœ… | è®¡ç®—å±æ€§ |
> | `@staticmethod` | æ—  | âŒ | âŒ | å·¥å…·å‡½æ•° |
> | `@classmethod` | `cls` | âŒ | âœ… | å·¥å‚æ–¹æ³• |"

#### Q9: Python æ·±æ‹·è´ vs æµ…æ‹·è´ï¼Ÿ

**å›ç­”**ï¼š

> **æµ…æ‹·è´ï¼ˆShallow Copyï¼‰**ï¼š
> ```python
> import copy
> a = [[1, 2], [3, 4]]
> b = copy.copy(a)  # æˆ– a.copy()
> b[0][0] = 999
> print(a)  # [[999, 2], [3, 4]]  # a ä¹Ÿå˜äº†ï¼
> ```
> - å¤åˆ¶å¤–å±‚å¯¹è±¡ï¼Œå†…å±‚å¯¹è±¡ä»å…±äº«å¼•ç”¨
>
> **æ·±æ‹·è´ï¼ˆDeep Copyï¼‰**ï¼š
> ```python
> b = copy.deepcopy(a)
> b[0][0] = 999
> print(a)  # [[1, 2], [3, 4]]  # a ä¸å˜
> ```
> - é€’å½’å¤åˆ¶æ‰€æœ‰å±‚çº§ï¼Œå®Œå…¨ç‹¬ç«‹
>
> **NumPy æ•°ç»„**ï¼š
> ```python
> a = np.array([[1, 2], [3, 4]])
> b = a  # è§†å›¾ï¼ˆå…±äº«å†…å­˜ï¼‰
> c = a.copy()  # æ·±æ‹·è´ï¼ˆç‹¬ç«‹å†…å­˜ï¼‰
> 
> b[0, 0] = 999  # a ä¹Ÿå˜
> c[0, 0] = 999  # a ä¸å˜
> ```
>
> **é¡¹ç›®ä¸­çš„åº”ç”¨**ï¼š
> ```python
> def _ensure_hermitian(self):
>     # åŸåœ°æ“ä½œï¼Œé¿å…å¤åˆ¶
>     self._matrix = (self._matrix + self._matrix.conj().T) / 2
> 
> def get_matrix_copy(self):
>     # è¿”å›å‰¯æœ¬ï¼Œé˜²æ­¢å¤–éƒ¨ä¿®æ”¹
>     return self._matrix.copy()
> ```"

### 8.3 è®¾è®¡æ¨¡å¼é—®é¢˜

#### Q10: å·¥å‚æ¨¡å¼ vs æŠ½è±¡å·¥å‚æ¨¡å¼ï¼Ÿ

**å›ç­”**ï¼š

> **å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰**ï¼š
> - å®šä¹‰ï¼šæä¾›åˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œä½†ç”±å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸ªç±»
> - é¡¹ç›®åº”ç”¨ï¼š
> ```python
> def _create_reconstructor(method: str, config):
>     \"\"\"å·¥å‚æ–¹æ³•\"\"\"
>     if method == \"linear\":
>         return LinearReconstructor(config.dimension, ...)
>     elif method == \"mle\":
>         return MLEReconstructor(config.dimension, ...)
>     else:
>         raise ValueError(f\"æœªçŸ¥æ–¹æ³•: {method}\")
> ```
> - ä¼˜ç‚¹ï¼šè§£è€¦å¯¹è±¡åˆ›å»ºå’Œä½¿ç”¨ï¼Œæ˜“äºæ‰©å±•æ–°ç®—æ³•
>
> **æŠ½è±¡å·¥å‚æ¨¡å¼ï¼ˆAbstract Factory Patternï¼‰**ï¼š
> - å®šä¹‰ï¼šæä¾›åˆ›å»º**ä¸€ç³»åˆ—ç›¸å…³å¯¹è±¡**çš„æ¥å£ï¼Œæ— éœ€æŒ‡å®šå…·ä½“ç±»
> - ç¤ºä¾‹ï¼š
> ```python
> class AnalysisToolFactory(ABC):
>     @abstractmethod
>     def create_reconstructor(self): pass
>     @abstractmethod
>     def create_visualizer(self): pass
> 
> class QuantumFactory(AnalysisToolFactory):
>     def create_reconstructor(self):
>         return QuantumReconstructor()
>     def create_visualizer(self):
>         return QuantumVisualizer()
> 
> class ClassicalFactory(AnalysisToolFactory):
>     def create_reconstructor(self):
>         return ClassicalReconstructor()
>     def create_visualizer(self):
>         return ClassicalVisualizer()
> ```
> - ä¼˜ç‚¹ï¼šç¡®ä¿ä¸€ç»„å¯¹è±¡çš„å…¼å®¹æ€§
>
> **åŒºåˆ«**ï¼š
> - å·¥å‚æ¨¡å¼ï¼šåˆ›å»º**å•ä¸ª**å¯¹è±¡
> - æŠ½è±¡å·¥å‚ï¼šåˆ›å»º**ä¸€ç³»åˆ—ç›¸å…³**å¯¹è±¡"

#### Q11: ç­–ç•¥æ¨¡å¼çš„åº”ç”¨ï¼Ÿ

**å›ç­”**ï¼š

> **å®šä¹‰**ï¼šå®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼Œå°è£…æ¯ä¸ªç®—æ³•ï¼Œå¹¶ä½¿å®ƒä»¬å¯äº’æ¢ã€‚
>
> **é¡¹ç›®åº”ç”¨**ï¼š
> ```python
> # ç­–ç•¥æ¥å£
> class ReconstructionStrategy(ABC):
>     @abstractmethod
>     def reconstruct(self, probabilities): pass
> 
> # å…·ä½“ç­–ç•¥
> class LinearStrategy(ReconstructionStrategy):
>     def reconstruct(self, probabilities):
>         # çº¿æ€§é‡æ„ç®—æ³•
>         return linear_result
> 
> class MLEStrategy(ReconstructionStrategy):
>     def reconstruct(self, probabilities):
>         # MLE é‡æ„ç®—æ³•
>         return mle_result
> 
> # ä¸Šä¸‹æ–‡
> class ReconstructionContext:
>     def __init__(self, strategy: ReconstructionStrategy):
>         self._strategy = strategy
>     
>     def execute(self, probabilities):
>         return self._strategy.reconstruct(probabilities)
> 
> # ä½¿ç”¨
> context = ReconstructionContext(LinearStrategy())
> result = context.execute(probs)
> 
> # è¿è¡Œæ—¶åˆ‡æ¢ç­–ç•¥
> context._strategy = MLEStrategy()
> result = context.execute(probs)
> ```
>
> **ä¼˜ç‚¹**ï¼š
> - ç®—æ³•å¯äº’æ¢ï¼ˆç¬¦åˆå¼€é—­åŸåˆ™ï¼‰
> - é¿å…å¤§é‡ if-else åˆ¤æ–­
> - æ¯ä¸ªç®—æ³•ç‹¬ç«‹æµ‹è¯•"

#### Q12: å•ä¾‹æ¨¡å¼åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨ï¼Ÿ

**å›ç­”**ï¼š

> **å®šä¹‰**ï¼šç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›å…¨å±€è®¿é—®ç‚¹ã€‚
>
> **é¡¹ç›®åº”ç”¨**ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜
> ```python
> class ProjectorSet:
>     _cache: Dict[int, 'ProjectorSet'] = {}  # ç±»çº§ç¼“å­˜
>     
>     def __new__(cls, dimension: int):
>         # å•ä¾‹æ¨¡å¼ï¼šç›¸åŒç»´åº¦è¿”å›åŒä¸€å®ä¾‹
>         if dimension not in cls._cache:
>             instance = super().__new__(cls)
>             cls._cache[dimension] = instance
>         return cls._cache[dimension]
>     
>     def __init__(self, dimension: int):
>         if hasattr(self, '_initialized'):
>             return  # é¿å…é‡å¤åˆå§‹åŒ–
>         self._initialized = True
>         self.dimension = dimension
>         self.projectors = self._generate_projectors()
> 
> # ä½¿ç”¨
> proj1 = ProjectorSet(4)
> proj2 = ProjectorSet(4)
> assert proj1 is proj2  # åŒä¸€å®ä¾‹
> ```
>
> **å…¶ä»–å®ç°æ–¹å¼**ï¼š
> ```python
> # æ–¹å¼ 2ï¼šç±»æ–¹æ³•
> @classmethod
> def get_instance(cls, dimension):
>     if dimension not in cls._cache:
>         cls._cache[dimension] = cls(dimension)
>     return cls._cache[dimension]
> 
> # æ–¹å¼ 3ï¼šè£…é¥°å™¨
> def singleton(cls):
>     instances = {}
>     def wrapper(*args, **kwargs):
>         if cls not in instances:
>             instances[cls] = cls(*args, **kwargs)
>         return instances[cls]
>     return wrapper
> ```
>
> **æ³¨æ„äº‹é¡¹**ï¼š
> - çº¿ç¨‹å®‰å…¨ï¼šå¤šçº¿ç¨‹æ—¶éœ€åŠ é”
> - æµ‹è¯•å›°éš¾ï¼šå…¨å±€çŠ¶æ€éš¾ä»¥éš”ç¦»
> - è°¨æ…ä½¿ç”¨ï¼šè¿‡åº¦ä½¿ç”¨ä¼šå¯¼è‡´ä»£ç è€¦åˆ"

### 8.4 ç®—æ³•ä¸æ•°æ®ç»“æ„

#### Q13: æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦åˆ†æ

**å›ç­”**ï¼š

> **é¡¹ç›®ä¸­çš„å¤æ‚åº¦**ï¼š
>
> | æ“ä½œ            | æ—¶é—´å¤æ‚åº¦    | ç©ºé—´å¤æ‚åº¦ | ä¼˜åŒ–æ–¹æ³•                  |
> |------|-----------|-----------|---------|
> | ç”ŸæˆæŠ•å½±ç®—ç¬¦    | $O(n^4)$      | $O(n^4)$   | ç¼“å­˜ï¼ˆæ‰¹å¤„ç†æ—¶å¤ç”¨ï¼‰      |
> | æ„å»ºçº¿æ€§æ–¹ç¨‹ç»„  | $O(1)$        | $O(n^4)$   | NumPy å‘é‡åŒ–ï¼ˆè§†å›¾æ“ä½œï¼‰  |
> | æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„  | $O(n^4)$      | $O(n^4)$   | ä½¿ç”¨ lstsqï¼ˆSVDåˆ†è§£ï¼‰     |
> | ç‰¹å¾å€¼åˆ†è§£      | $O(n^3)$      | $O(n^2)$   | ä½¿ç”¨ eighï¼ˆå„ç±³çŸ©é˜µä¼˜åŒ–ï¼‰ |
> | MLE å•æ¬¡è¿­ä»£    | $O(n^4)$      | $O(n^2)$   | çŸ©é˜µä¹˜æ³•                  |
> | Pandas åˆ†ç»„èšåˆ | $O(m \log m)$ | $O(m)$     | $m$ ä¸ºæ ·æœ¬æ•°              |
>
> **ä¼˜åŒ–æ¡ˆä¾‹**ï¼š
>
> ```python
> # åŸå§‹ï¼šO(mn^4)ï¼Œæ¯æ¬¡ç”ŸæˆæŠ•å½±ç®—ç¬¦
> for sample in samples:  # m ä¸ªæ ·æœ¬
>  projectors = ProjectorSet(dimension)  # O(n^4)
>  result = reconstruct(sample, projectors)  # O(n^3)
> 
> # ä¼˜åŒ–ï¼šO(n^4 + mn^3)ï¼Œç¼“å­˜æŠ•å½±ç®—ç¬¦
> projectors = ProjectorSet(dimension)  # ä»…ä¸€æ¬¡ O(n^4)
> for sample in samples:
>  result = reconstruct(sample, projectors)  # O(n^3)
> ```
> - 100 ä¸ªæ ·æœ¬ï¼š50s â†’ 5sï¼ˆ**10å€æå‡**ï¼‰
>
> **åˆ†ææ–¹æ³•**ï¼š
> 1. ä½¿ç”¨ `cProfile` æ‰¾çƒ­ç‚¹ï¼š`python -m cProfile -s cumtime script.py`
> 2. ä½¿ç”¨ `line_profiler` é€è¡Œåˆ†æ
> 3. çŸ©é˜µè¿ç®—å¤æ‚åº¦ï¼š
>    - çŸ©é˜µä¹˜æ³• `A @ B`ï¼š$O(n^3)$
>    - ç‰¹å¾å€¼åˆ†è§£ `eigh(A)`ï¼š$O(n^3)$
>    - æ±‚é€† `inv(A)`ï¼š$O(n^3)$ï¼ˆä½† `solve` æ›´å¿«æ›´ç¨³å®šï¼‰"

#### Q14: å“ˆå¸Œè¡¨çš„åŸç†å’Œåº”ç”¨ï¼Ÿ

**å›ç­”**ï¼š

> **åŸç†**ï¼š
> - é€šè¿‡å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•
> - å†²çªè§£å†³ï¼šé“¾è¡¨æ³•ï¼ˆPython dictï¼‰æˆ–å¼€æ”¾å¯»å€
> - å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šæŸ¥æ‰¾/æ’å…¥/åˆ é™¤ $O(1)$
>
> **Python çš„ dict**ï¼š
> ```python
> # åº•å±‚ï¼šå“ˆå¸Œè¡¨ï¼ˆC å®ç°ï¼‰
> cache = {}
> cache[key] = value  # O(1) æ’å…¥
> result = cache.get(key)  # O(1) æŸ¥è¯¢
> ```
>
> **é¡¹ç›®åº”ç”¨**ï¼š
> ```python
> class ProjectorSet:
>     _cache: Dict[int, 'ProjectorSet'] = {}  # dimension â†’ instance
>     
>     @classmethod
>     def get_cached(cls, dimension: int):
>         # O(1) æŸ¥è¯¢ï¼Œå‘½ä¸­åˆ™ç›´æ¥è¿”å›
>         if dimension in cls._cache:
>             return cls._cache[dimension]
>         # æœªå‘½ä¸­åˆ™åˆ›å»ºå¹¶ç¼“å­˜
>         instance = cls(dimension)
>         cls._cache[dimension] = instance
>         return instance
> ```
>
> **æ³¨æ„äº‹é¡¹**ï¼š
> - é”®å¿…é¡»å¯å“ˆå¸Œï¼ˆä¸å¯å˜ç±»å‹ï¼šint, str, tupleï¼‰
> - ä¸å¯å“ˆå¸Œï¼šlist, dict, set
> - è‡ªå®šä¹‰å¯¹è±¡ï¼šå®ç° `__hash__()` å’Œ `__eq__()`"

### 8.5 æ•°æ®åº“ä¸ç¼“å­˜ï¼ˆæ‰©å±•çŸ¥è¯†ï¼‰

#### Q15: å¦‚æœè¦æŒä¹…åŒ–åˆ°æ•°æ®åº“ï¼Œå¦‚ä½•è®¾è®¡ï¼Ÿ

**å›ç­”**ï¼š

> **å½“å‰æ–¹æ¡ˆ**ï¼šæ–‡ä»¶å­˜å‚¨ï¼ˆJSON + CSVï¼‰
> - ä¼˜ç‚¹ï¼šç®€å•ã€æ˜“è°ƒè¯•ã€é€‚åˆå°è§„æ¨¡æ•°æ®
> - ç¼ºç‚¹ï¼šæŸ¥è¯¢ä¸ä¾¿ã€å¹¶å‘æ€§èƒ½å·®ã€ä¸æ”¯æŒå¤æ‚æŸ¥è¯¢
>
> **æ•°æ®åº“æ–¹æ¡ˆ**ï¼š
>
> **1. å…³ç³»å‹æ•°æ®åº“ï¼ˆPostgreSQLï¼‰**
> ```sql
> -- è¡¨ç»“æ„è®¾è®¡
> CREATE TABLE reconstruction_records (
>     id SERIAL PRIMARY KEY,
>     sample_id INT NOT NULL,
>     method VARCHAR(10) NOT NULL,  -- 'linear' or 'mle'
>     dimension INT NOT NULL,
>     purity DOUBLE PRECISION,
>     trace DOUBLE PRECISION,
>     fidelity DOUBLE PRECISION,
>     rank INT,
>     min_eigenvalue DOUBLE PRECISION,
>     max_eigenvalue DOUBLE PRECISION,
>     condition_number DOUBLE PRECISION,
>     eigenvalue_entropy DOUBLE PRECISION,
>     n_iterations INT,
>     n_evaluations INT,
>     success BOOLEAN,
>     timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
>     density_matrix JSONB,  -- å­˜å‚¨çŸ©é˜µï¼ˆJSONæ ¼å¼ï¼‰
>     UNIQUE(sample_id, method)
> );
> 
> -- ç´¢å¼•ä¼˜åŒ–
> CREATE INDEX idx_method ON reconstruction_records(method);
> CREATE INDEX idx_sample_method ON reconstruction_records(sample_id, method);
> ```
>
> **2. ORM å®ç°ï¼ˆSQLAlchemyï¼‰**
> ```python
> from sqlalchemy import Column, Integer, Float, Boolean, JSON
> from sqlalchemy.ext.declarative import declarative_base
> 
> Base = declarative_base()
> 
> class ReconstructionRecord(Base):
>     __tablename__ = 'reconstruction_records'
>     
>     id = Column(Integer, primary_key=True)
>     sample_id = Column(Integer, nullable=False)
>     method = Column(String(10), nullable=False)
>     purity = Column(Float)
>     trace = Column(Float)
>     fidelity = Column(Float)
>     density_matrix = Column(JSON)
>     # ... å…¶ä»–å­—æ®µ
>     
>     def to_dict(self):
>         return {
>             'sample_id': self.sample_id,
>             'method': self.method,
>             'purity': self.purity,
>             # ...
>         }
> ```
>
> **3. æŸ¥è¯¢ç¤ºä¾‹**
> ```python
> # æŸ¥è¯¢æ‰€æœ‰ MLE æˆåŠŸçš„è®°å½•
> successful_mle = session.query(ReconstructionRecord)\\
>     .filter_by(method='mle', success=True)\\
>     .all()
> 
> # è®¡ç®— Linear çš„å¹³å‡çº¯åº¦
> avg_purity = session.query(func.avg(ReconstructionRecord.purity))\\
>     .filter_by(method='linear')\\
>     .scalar()
> 
> # å¯¹æ¯” Linear vs MLEï¼ˆJOINï¼‰
> comparison = session.query(
>     linear.sample_id,
>     linear.purity.label('linear_purity'),
>     mle.purity.label('mle_purity')
> ).join(mle, linear.sample_id == mle.sample_id)\\
>  .filter(linear.method == 'linear', mle.method == 'mle')\\
>  .all()
> ```
>
> **ä¼˜ç‚¹**ï¼š
> - å¼ºå¤§çš„æŸ¥è¯¢èƒ½åŠ›ï¼ˆèšåˆã€JOINã€å­æŸ¥è¯¢ï¼‰
> - äº‹åŠ¡æ”¯æŒï¼ˆACID ç‰¹æ€§ï¼‰
> - å¹¶å‘æ€§èƒ½å¥½
>
> **ç¼ºç‚¹**ï¼š
> - éƒ¨ç½²å¤æ‚ï¼ˆéœ€è¦æ•°æ®åº“æœåŠ¡å™¨ï¼‰
> - å­¦ä¹ æˆæœ¬é«˜"

---

## å®æˆ˜æ¼”ç»ƒï¼šæ¨¡æ‹Ÿé¢è¯•é—®ç­”

### 9.1 å¼€åœºè‡ªæˆ‘ä»‹ç»ï¼ˆ1åˆ†é’Ÿï¼‰

**æ¨¡æ¿**ï¼š

> "é¢è¯•å®˜æ‚¨å¥½ï¼Œæˆ‘æ˜¯XXXï¼Œç ”ç©¶ç”Ÿåœ¨è¯»ï¼Œä¸“ä¸šæ˜¯XXXã€‚
>
> æˆ‘æœ€è¿‘å®Œæˆäº†ä¸€ä¸ª**é‡å­æ€å±‚æé‡æ„å·¥å…·åŒ…**çš„å¼€å‘ï¼Œè¿™æ˜¯æˆ‘çš„æ ¸å¿ƒé¡¹ç›®ç»éªŒã€‚é¡¹ç›®è§„æ¨¡çº¦ **5000 è¡Œä»£ç **ï¼Œé‡‡ç”¨ **Python + NumPy + SciPy** æŠ€æœ¯æ ˆï¼Œå®ç°äº†**çº¿æ€§é‡æ„å’Œ MLE ä¸¤ç§æ ¸å¿ƒç®—æ³•**ã€‚
>
> åœ¨æ¶æ„è®¾è®¡ä¸Šï¼Œæˆ‘é‡‡ç”¨äº†**å››å±‚åˆ†å±‚æ¶æ„**ï¼Œåº”ç”¨äº†**å·¥å‚æ¨¡å¼ã€ç­–ç•¥æ¨¡å¼ã€ä»“å‚¨æ¨¡å¼**ç­‰è®¾è®¡æ¨¡å¼ï¼Œéµå¾ª **SOLID åŸåˆ™**ã€‚é¡¹ç›®åŒ…å« **36 ä¸ªæµ‹è¯•ç”¨ä¾‹**ï¼Œä¸ MATLAB åŸºå‡†å¯¹é½ç²¾åº¦è¾¾ **1e-10**ã€‚
>
> æŠ€æœ¯äº®ç‚¹åŒ…æ‹¬ï¼š
> 1. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡æŠ•å½±ç®—ç¬¦ç¼“å­˜ï¼Œæ‰¹å¤„ç†æ€§èƒ½æå‡ **10 å€**
> 2. **å·¥ç¨‹åŒ–å®è·µ**ï¼šå®Œæ•´çš„ CLI å·¥å…·ã€æ‰¹å¤„ç†ã€é…ç½®ç®¡ç†
> 3. **æ•°å€¼ç¨³å®šæ€§**ï¼šå®ç° makephysical ç®—æ³•å’Œå²­å›å½’ï¼Œä¿è¯è®¡ç®—ç²¾åº¦
>
> æˆ‘ç†Ÿæ‚‰ Python ç”Ÿæ€ï¼ˆNumPyã€Pandasã€Pytestï¼‰ï¼Œç†è§£é¢å‘å¯¹è±¡è®¾è®¡ã€è®¾è®¡æ¨¡å¼ã€ç®—æ³•ä¼˜åŒ–ã€‚æœŸå¾…èƒ½åœ¨è´µå¸ç»§ç»­æ·±åŒ–è½¯ä»¶å·¥ç¨‹èƒ½åŠ›ã€‚è°¢è°¢ï¼"

### 9.2 æŠ€æœ¯æ·±æŒ–ï¼ˆè¿ç¯å‘é—®ï¼‰

**é¢è¯•å®˜**: "ä½ æåˆ°æ€§èƒ½ä¼˜åŒ–ï¼Œå…·ä½“æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ"

**å›ç­”**:
> "ä¸»è¦æœ‰ä¸¤ä¸ªä¼˜åŒ–ï¼š
>
> **1. æŠ•å½±ç®—ç¬¦ç¼“å­˜**
> - **é—®é¢˜**ï¼šç”ŸæˆæŠ•å½±ç®—ç¬¦çš„è®¡ç®—é‡æ˜¯ $O(n^4)$ï¼Œæ‰¹å¤„ç† 100 ä¸ªæ ·æœ¬ä¼šé‡å¤ç”Ÿæˆ 100 æ¬¡ï¼Œéå¸¸æµªè´¹
> - **æ–¹æ¡ˆ**ï¼šä½¿ç”¨ç±»çº§ç¼“å­˜ï¼Œç›¸åŒç»´åº¦çš„æŠ•å½±ç®—ç¬¦åªç”Ÿæˆä¸€æ¬¡
> - **å®ç°**ï¼š
>   ```python
>   class ProjectorSet:
>       _cache: Dict[int, 'ProjectorSet'] = {}
>         
>       @classmethod
>       def get_cached(cls, dimension: int):
>           if dimension not in cls._cache:
>               cls._cache[dimension] = cls(dimension)
>           return cls._cache[dimension]
>   ```
> - **æ•ˆæœ**ï¼š100 ä¸ªæ ·æœ¬ä» 50s é™è‡³ 5sï¼Œ**10 å€æå‡**
>
> **2. NumPy å‘é‡åŒ–**
> - ç”¨ NumPy å¹¿æ’­æ›¿ä»£ Python å¾ªç¯
> - ä¾‹å¦‚å¯†åº¦çŸ©é˜µå½’ä¸€åŒ–ï¼š`eigvals / eigvals.sum()`ï¼ˆè‡ªåŠ¨å¹¿æ’­ï¼‰
> - æ•ˆæœï¼šå¯†åº¦çŸ©é˜µç‰©ç†åŒ–ä» 10ms é™è‡³ 0.1ms"

**é¢è¯•å®˜**: "ç¼“å­˜ä¼šå¸¦æ¥å†…å­˜é—®é¢˜å—ï¼Ÿ"

**å›ç­”**:
> "ä¼šçš„ï¼Œæˆ‘è€ƒè™‘è¿‡è¿™ä¸ªé—®é¢˜ã€‚
>
> **åˆ†æ**ï¼š
> - æŠ•å½±ç®—ç¬¦å ç”¨å†…å­˜ï¼š$O(n^4)$
> - 4 ç»´ç³»ç»Ÿï¼š
>
>   - æ€»åŸºæ•°é‡ï¼š4Â² = 16ä¸ªåŸº
>
>   - æ¯ä¸ªæŠ•å½±ç®—ç¬¦ï¼š4Ã—4 å¤æ•°çŸ©é˜µ = 16Ã—8 = 128å­—èŠ‚--æ¯ä¸ªå¤æ•°8å­—èŠ‚
>
>   - æŠ•å½±ç®—ç¬¦æ€»å†…å­˜ï¼š16 Ã— 128 = 2.0 KB
>
>   - æµ‹é‡çŸ©é˜µMï¼š16Ã—16 å¤æ•°çŸ©é˜µ = 256Ã—8 = 2.0 KB
>
>   - æ€»å†…å­˜ï¼šçº¦ 4.0 KB
> - 16 ç»´ç³»ç»Ÿï¼š
>
>   - æ€»åŸºæ•°é‡ï¼š16Â² = 256ä¸ªåŸº
>
>   - æ¯ä¸ªæŠ•å½±ç®—ç¬¦ï¼š16Ã—16 å¤æ•°çŸ©é˜µ = 256Ã—8 = 2KB
>
>   - æŠ•å½±ç®—ç¬¦æ€»å†…å­˜ï¼š256 Ã— 2KB = 512 KB
>
>   - æµ‹é‡çŸ©é˜µMï¼š256Ã—256 å¤æ•°çŸ©é˜µ = 512 KB
>
>   - æ€»å†…å­˜ï¼šçº¦ 1.0 MB
>
> **è§£å†³æ–¹æ¡ˆ**ï¼ˆæœªå®ç°ä½†å¯æ‰©å±•ï¼‰ï¼š
> 1. **LRU ç¼“å­˜**ï¼šé™åˆ¶ç¼“å­˜å¤§å°ï¼Œæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„
>
>    - é€‚åˆæ‰¹å¤„ç†å¤šç»´åº¦åœºæ™¯
>
>    - å¯æ§åˆ¶å†…å­˜ä½¿ç”¨ä¸Šé™
>
>    - å³ä½¿è¢«æ·˜æ±°åé‡å»ºï¼Œä¹Ÿæ¯”æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—è¦å¥½
>
>    ```python
>    from functools import lru_cache
>    
>    @lru_cache(maxsize=3)  # æœ€å¤šç¼“å­˜ 3 ä¸ªç»´åº¦
>    def get_projectors(dimension):
>        return ProjectorSet(dimension)
>    ```
> 2. **ç»´åº¦çº§ç¼“å­˜ï¼ˆå½“å‰å®ç°ï¼‰**ï¼šæŒ‰ç»´åº¦ç¼“å­˜ï¼Œä¸€æ¬¡æ“ä½œä¸­æŒç»­ä½¿ç”¨
>
>    - é€‚åˆå•æ¬¡æ“ä½œåœºæ™¯
>
>    - é¿å…é‡å¤è®¡ç®—
> 3. **æŒ‰éœ€è®¡ç®—**ï¼šä¸é¢„å…ˆç”Ÿæˆæ‰€æœ‰æŠ•å½±ç®—ç¬¦ï¼Œè€Œæ˜¯åŠ¨æ€è®¡ç®—ï¼ˆæ—¶é—´æ¢ç©ºé—´ï¼‰
>
> **å½“å‰é€‰æ‹©**ï¼šç®€å•ç¼“å­˜ï¼Œå› ä¸ºæœ¬é¡¹ç›®ç»´åº¦ä¸è¶…è¿‡ 16"

**é¢è¯•å®˜**: "å¦‚æœè¦æ”¯æŒå¹¶å‘ï¼Œæ€ä¹ˆä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿ"

**å›ç­”**:
> "ç¼“å­˜çš„çº¿ç¨‹å®‰å…¨æ˜¯ä¸ªå¥½é—®é¢˜ã€‚å½“å‰å®ç°åœ¨å•çº¿ç¨‹ä¸‹å®‰å…¨ï¼Œä½†å¤šçº¿ç¨‹ä¼šæœ‰ç«æ€æ¡ä»¶ã€‚
>
> **é—®é¢˜åœºæ™¯**ï¼š
> ```python
> # çº¿ç¨‹ 1 å’Œçº¿ç¨‹ 2 åŒæ—¶æ£€æŸ¥ç¼“å­˜
> if dimension not in cls._cache:  # ä¸¤ä¸ªçº¿ç¨‹éƒ½è¿›å…¥
>     cls._cache[dimension] = cls(dimension)  # åˆ›å»ºä¸¤æ¬¡ï¼
> ```
>
> **è§£å†³æ–¹æ¡ˆ**ï¼š
> ```python
> import threading
> 
> class ProjectorSet:
>     _cache = {}
>     _lock = threading.Lock()  # é”
>     
>     @classmethod
>     def get_cached(cls, dimension):
>         # åŒé‡æ£€æŸ¥é”å®šï¼ˆDouble-Checked Lockingï¼‰
>         if dimension not in cls._cache:
>             with cls._lock:
>                 if dimension not in cls._cache:  # å†æ¬¡æ£€æŸ¥
>                     cls._cache[dimension] = cls(dimension)
>         return cls._cache[dimension]
> ```
>
> **å…¶ä»–æ–¹æ¡ˆ**ï¼š
> - ä½¿ç”¨ `threading.RLock()`ï¼ˆå¯é‡å…¥é”ï¼‰
> - ä½¿ç”¨ `multiprocessing.Manager().dict()`ï¼ˆè¿›ç¨‹å®‰å…¨ï¼‰
> - ä½¿ç”¨ Redis ç­‰å¤–éƒ¨ç¼“å­˜ï¼ˆåˆ†å¸ƒå¼åœºæ™¯ï¼‰"

### 9.3 é¡¹ç›®éš¾ç‚¹è¿½é—®

**é¢è¯•å®˜**: "ä½ æåˆ°æ•°å€¼ç¨³å®šæ€§ï¼Œèƒ½è¯¦ç»†è¯´è¯´å—ï¼Ÿ"

**å›ç­”**:
> "æ•°å€¼ç¨³å®šæ€§æ˜¯è¿™ä¸ªé¡¹ç›®æœ€å¤§çš„æŒ‘æˆ˜ï¼Œä¸»è¦ä½“ç°åœ¨ä¸¤ä¸ªæ–¹é¢ï¼š
>
> **æŒ‘æˆ˜ 1ï¼šå¯†åº¦çŸ©é˜µçš„ç‰©ç†çº¦æŸ**
>
> é‡å­åŠ›å­¦è¦æ±‚å¯†åº¦çŸ©é˜µæ»¡è¶³ä¸‰ä¸ªçº¦æŸï¼š
> 1. å„ç±³æ€§ï¼š$\rho = \rho^\dagger$
> 2. åŠæ­£å®šæ€§ï¼šæ‰€æœ‰ç‰¹å¾å€¼ $\geq 0$
> 3. è¿¹ä¸º1ï¼š$\text{Tr}(\rho) = 1$
>
> ä½†æ•°å€¼è®¡ç®—ä¼šå¼•å…¥è¯¯å·®ï¼Œæ¯”å¦‚ï¼š
> - æµ®ç‚¹è¿ç®—è¯¯å·®ï¼š$1.0 - 0.3 - 0.3 - 0.3 = 0.1$ â‰  `0.09999999999999998`
> - ç‰¹å¾å€¼åˆ†è§£åå¯èƒ½å‡ºç°å¾®å°è´Ÿå€¼ï¼ˆå¦‚ `-1e-15`ï¼‰
>
> **æˆ‘çš„è§£å†³æ–¹æ¡ˆ**ï¼š`makephysical` ç®—æ³•
> ```python
> def _ensure_physical(self):
>     # æ­¥éª¤ 1ï¼šå¼ºåˆ¶å„ç±³æ€§
>     self._matrix = (self._matrix + self._matrix.conj().T) / 2
>     
>     # æ­¥éª¤ 2ï¼šç‰¹å¾å€¼åˆ†è§£
>     eigvals, eigvecs = np.linalg.eigh(self._matrix)
>     
>     # æ­¥éª¤ 3ï¼šè£å‰ªè´Ÿç‰¹å¾å€¼ï¼ˆæ•°å€¼å™ªå£°ï¼‰
>     eigvals = np.maximum(eigvals, 0)
>     
>     # æ­¥éª¤ 4ï¼šå½’ä¸€åŒ–ï¼ˆç¡®ä¿è¿¹ä¸º1ï¼‰
>     eigvals = eigvals / eigvals.sum()
>     
>     # æ­¥éª¤ 5ï¼šé‡æ„çŸ©é˜µ
>     self._matrix = eigvecs @ np.diag(eigvals) @ eigvecs.conj().T
> ```
>
> **æŒ‘æˆ˜ 2ï¼šçº¿æ€§æ–¹ç¨‹ç»„ç—…æ€**
>
> ç³»æ•°çŸ©é˜µ $A$ çš„æ¡ä»¶æ•°å¯è¾¾ $10^{15}$ï¼Œç›´æ¥æ±‚è§£ä¼šå¯¼è‡´ï¼š
> - æ•°å€¼ä¸ç¨³å®šï¼ˆå¾®å°æ‰°åŠ¨å¯¼è‡´è§£å‰§çƒˆå˜åŒ–ï¼‰
> - è¯¯å·®æ”¾å¤§
>
> **æˆ‘çš„è§£å†³æ–¹æ¡ˆ**ï¼šå²­å›å½’ï¼ˆTikhonov æ­£åˆ™åŒ–ï¼‰
> ```python
> def _solve_with_regularization(self, A, b, lambda_reg=1e-6):
>     # æ­£åˆ™åŒ–ï¼šmin ||Ax - b||Â² + Î»||x||Â²
>     AtA = A.T @ A
>     Atb = A.T @ b
>     regularized = AtA + lambda_reg * np.eye(AtA.shape[0])
>     return np.linalg.solve(regularized, Atb)
> ```
>
> **éªŒè¯**ï¼š
> - ä¸ MATLAB åŸºå‡†å¯¹æ¯”ï¼Œè¯¯å·® < `1e-10`
> - å•å…ƒæµ‹è¯•è¦†ç›–å„ç§è¾¹ç•Œæ¡ä»¶ï¼ˆçº¯æ€ã€æœ€å¤§æ··åˆæ€ã€ç—…æ€çŸ©é˜µï¼‰
>
> **æ”¶è·**ï¼š
> è¿™è®©æˆ‘æ·±åˆ»ç†è§£äº†**ç†è®ºå’Œå·¥ç¨‹çš„å·®è·**â€”â€”ç†è®ºä¸Šå®Œç¾çš„ç®—æ³•ï¼Œåœ¨å®é™…è®¡ç®—ä¸­å¯èƒ½å› æµ®ç‚¹è¯¯å·®è€Œå¤±æ•ˆï¼Œéœ€è¦é¢å¤–çš„æ•°å€¼æŠ€å·§æ¥ä¿è¯ç¨³å®šæ€§ã€‚"

### 9.4 è¡Œä¸ºé¢è¯•

**é¢è¯•å®˜**: "åœ¨é¡¹ç›®ä¸­é‡åˆ°è¿‡åˆ†æ­§å—ï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿ"

**å›ç­”**:
> "æœ‰çš„ï¼Œåœ¨ Stage 3 è®¾è®¡æ—¶ï¼Œå…³äº**æ•°æ®ä¸€è‡´æ€§**æœ‰è¿‡è®¨è®ºã€‚
>
> **èƒŒæ™¯**ï¼š
> æˆ‘ä»¬éœ€è¦åŒæ—¶è¾“å‡º JSON è®°å½•å’Œ CSV æ±‡æ€»ï¼Œä¸¤è€…éƒ½åŒ…å«æŒ‡æ ‡æ•°æ®ï¼ˆpurity, traceç­‰ï¼‰ã€‚
>
> **åˆ†æ­§**ï¼š
> - **æ–¹æ¡ˆ A**ï¼ˆæˆ‘çš„åˆå§‹æƒ³æ³•ï¼‰ï¼šåˆ†åˆ«è®¡ç®—æŒ‡æ ‡ï¼Œå†™å…¥ JSON å’Œ CSV
> - **æ–¹æ¡ˆ B**ï¼ˆå¯¼å¸ˆå»ºè®®ï¼‰ï¼šå…ˆå†™ JSONï¼ŒCSV ä» JSON è¯»å–
>
> **é—®é¢˜åˆ†æ**ï¼š
> æ–¹æ¡ˆ A çš„é—®é¢˜ï¼š
> - ä¸¤å¤„è®¡ç®—å¯èƒ½ä¸ä¸€è‡´ï¼ˆæµ®ç‚¹ç²¾åº¦ã€è®¡ç®—é¡ºåºï¼‰
> - ç»´æŠ¤æˆæœ¬é«˜ï¼ˆæ–°å¢æŒ‡æ ‡éœ€ä¿®æ”¹ä¸¤å¤„ï¼‰
> - è°ƒè¯•å›°éš¾ï¼ˆå‡ºé”™æ—¶ä¸çŸ¥é“å“ªä¸ªæ˜¯å¯¹çš„ï¼‰
>
> **æœ€ç»ˆæ–¹æ¡ˆ**ï¼ˆæ–¹æ¡ˆ Bï¼‰ï¼š
> ```python
> # 1. å…ˆè®¡ç®—å¹¶å†™å…¥ JSON
> record.metrics = {
>     \"purity\": density.purity,
>     \"trace\": density.trace,
>     \"rank\": np.linalg.matrix_rank(density.matrix),
>     # ...
> }
> save_json(record)
>
> # 2. CSV ä» JSON è¯»å–ï¼ˆå•ä¸€æ•°æ®æºï¼‰
> summary_entry = {
>     \"sample\": sample_id,
>     \"method\": \"linear\",
>     \"purity\": record.metrics[\"purity\"],
>     \"trace\": record.metrics[\"trace\"],
>     # ...
> }
> ```
>
> **ä¼˜åŠ¿**ï¼š
> - JSON å’Œ CSV æ•°æ®å®Œå…¨ä¸€è‡´
> - å•ä¸€æ•°æ®æºï¼Œæ˜“äºç»´æŠ¤
> - æ–°å¢æŒ‡æ ‡åªéœ€ä¿®æ”¹ä¸€å¤„
>
> **æ”¶è·**ï¼š
> è¿™æ¬¡è®¨è®ºè®©æˆ‘è®¤è¯†åˆ°**å•ä¸€æ•°æ®æºåŸåˆ™**çš„é‡è¦æ€§ï¼Œä»¥åŠåœ¨è®¾è®¡æ—¶è¦å……åˆ†è€ƒè™‘ç»´æŠ¤æ€§å’Œå¯é æ€§ï¼Œè€Œä¸ä»…ä»…æ˜¯å®ç°åŠŸèƒ½ã€‚"

---

## æ€»ç»“ï¼šé¢è¯•å‡†å¤‡æ¸…å•

### âœ… é¡¹ç›®å‡†å¤‡ï¼ˆå¿…èƒŒï¼‰

1. **ä¸€å¥è¯ä»‹ç»**ï¼ˆ30 ç§’ç‰ˆ + 1 åˆ†é’Ÿç‰ˆï¼‰
2. **æŠ€æœ¯æ ˆ**ï¼šPython 3.9+, NumPy, SciPy, Pandas, Matplotlib, Pytest
3. **é¡¹ç›®è§„æ¨¡**ï¼š5000+ è¡Œï¼Œ36 æµ‹è¯•ï¼Œå››å±‚æ¶æ„ï¼Œ8 æ¨¡å—
4. **æ ¸å¿ƒç®—æ³•**ï¼šçº¿æ€§é‡æ„ï¼ˆ0.01sï¼‰ã€MLEï¼ˆç²¾åº¦ 0.999ï¼‰
5. **æŠ€æœ¯äº®ç‚¹**ï¼š
   - æ€§èƒ½ä¼˜åŒ–ï¼ˆç¼“å­˜ â†’ 10å€æå‡ï¼‰
   - æ•°å€¼ç¨³å®šæ€§ï¼ˆmakephysical + å²­å›å½’ï¼‰
   - åˆ†å±‚æ¶æ„ï¼ˆSOLID åŸåˆ™ï¼‰
   - è®¾è®¡æ¨¡å¼ï¼ˆå·¥å‚ã€ç­–ç•¥ã€ä»“å‚¨ï¼‰
   - Stage 3 å¢å¼ºï¼ˆ8 ä¸ªæ–°å­—æ®µ + æ–¹æ³•å¯¹æ¯”ï¼‰

### âœ… Python çŸ¥è¯†ï¼ˆé‡ç‚¹ï¼‰

1. **é«˜çº§ç‰¹æ€§**ï¼š`@property`, `dataclass`, ç±»å‹æç¤º, ä¸Šä¸‹æ–‡ç®¡ç†å™¨
2. **GIL**ï¼šå®šä¹‰ã€å½±å“ã€è§£å†³æ–¹æ¡ˆï¼ˆmultiprocessing, Cæ‰©å±•ï¼‰
3. **åƒåœ¾å›æ”¶**ï¼šå¼•ç”¨è®¡æ•° + å¾ªç¯åƒåœ¾å›æ”¶
4. **è£…é¥°å™¨**ï¼š`@property`, `@staticmethod`, `@classmethod` åŒºåˆ«
5. **æ·±æµ…æ‹·è´**ï¼š`copy.copy()` vs `copy.deepcopy()`
6. **NumPy**ï¼šå¹¿æ’­ã€einsumã€linalg
7. **Pandas**ï¼šåˆ†ç»„èšåˆã€æ¡ä»¶ç­›é€‰ã€æ•°æ®é€è§†

### âœ… OOP çŸ¥è¯†ï¼ˆé‡ç‚¹ï¼‰

1. **ä¸‰å¤§ç‰¹æ€§**ï¼šå°è£…ã€ç»§æ‰¿ã€å¤šæ€
2. **SOLID åŸåˆ™**ï¼ˆæ¯ä¸ªéƒ½èƒ½ä¸¾é¡¹ç›®ä¾‹å­ï¼‰
3. **ç»„åˆ vs ç»§æ‰¿**
4. **è®¾è®¡æ¨¡å¼**ï¼šå·¥å‚ã€ç­–ç•¥ã€å•ä¾‹ã€ä»“å‚¨

### âœ… è®¡ç®—æœºåŸºç¡€

1. **è¿›ç¨‹ vs çº¿ç¨‹**ï¼šå®šä¹‰ã€åŒºåˆ«ã€Python çš„ GIL
2. **å†…å­˜ç®¡ç†**ï¼šå¼•ç”¨è®¡æ•°ã€åƒåœ¾å›æ”¶ã€å†…å­˜ä¼˜åŒ–
3. **æ—¶é—´/ç©ºé—´å¤æ‚åº¦**ï¼šé¡¹ç›®ä¸­çš„å¤æ‚åº¦åˆ†æ
4. **å“ˆå¸Œè¡¨**ï¼šåŸç†ã€åº”ç”¨ï¼ˆç¼“å­˜ï¼‰

### âœ… è½¯ä»¶å·¥ç¨‹

1. **æµ‹è¯•**ï¼šå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€TDDã€è¦†ç›–ç‡
2. **Git**ï¼šåˆ†æ”¯ç­–ç•¥ã€æäº¤è§„èŒƒã€å¸¸ç”¨å‘½ä»¤
3. **ä»£ç å®¡æŸ¥**ï¼šæ£€æŸ¥è¦ç‚¹ã€æœ€ä½³å®è·µ
4. **CI/CD**ï¼šæ¦‚å¿µã€å·¥å…·ã€é…ç½®ç¤ºä¾‹

### âœ… è¡Œä¸ºé¢è¯•

1. **é¡¹ç›®äº®ç‚¹**ï¼šæ€§èƒ½ä¼˜åŒ– 10å€ã€æ•°å€¼ç²¾åº¦ 1e-10ã€Stage 3 å¢å¼º
2. **æŠ€æœ¯éš¾ç‚¹**ï¼šæ•°å€¼ç¨³å®šæ€§ï¼ˆmakephysical + å²­å›å½’ï¼‰
3. **å›¢é˜Ÿåä½œ**ï¼šæ•°æ®ä¸€è‡´æ€§è®¾è®¡è®¨è®º
4. **å­¦ä¹ èƒ½åŠ›**ï¼šä» MATLAB åˆ° Pythonã€ä»ç†è®ºåˆ°å·¥ç¨‹

---

## æœ€åçš„å»ºè®®

1. **ç†Ÿæ‚‰æ¯ä¸ªæŠ€æœ¯ç‚¹çš„é¡¹ç›®ä¾‹å­**ï¼šé¢è¯•å®˜é—®åˆ°ä»»ä½•å…«è‚¡æ–‡ï¼Œéƒ½èƒ½ç»“åˆé¡¹ç›®ä¸¾ä¾‹
2. **å‡†å¤‡ä»£ç ç‰‡æ®µ**ï¼šå…³é”®ä»£ç ï¼ˆå¦‚ makephysicalã€å·¥å‚æ–¹æ³•ï¼‰è¦èƒ½æ‰‹å†™
3. **æ•°å­—è¦å‡†ç¡®**ï¼š5000è¡Œã€36æµ‹è¯•ã€10å€æå‡ã€1e-10ç²¾åº¦
4. **ä¿æŒè°¦è™š**ï¼šå¼ºè°ƒ"è¿˜åœ¨å­¦ä¹ ä¸­"ã€"æ¬¢è¿æŒ‡å¯¼"
5. **å±•ç°çƒ­æƒ…**ï¼šè¡¨è¾¾å¯¹è½¯ä»¶å·¥ç¨‹ã€æŠ€æœ¯ä¼˜åŒ–çš„å…´è¶£
6. **æé—®ç¯èŠ‚**ï¼šå‡†å¤‡2-3ä¸ªé—®é¢˜ï¼ˆå›¢é˜Ÿè§„æ¨¡ã€æŠ€æœ¯æ ˆã€Code Reviewæµç¨‹ï¼‰

---

## é™„å½•ï¼šå¿«é€Ÿå¤ä¹ å¡ç‰‡

### å¡ç‰‡ 1ï¼šé¡¹ç›®ç”µæ¢¯æ¼”è®²ï¼ˆ30ç§’ï¼‰
> "æˆ‘å¼€å‘äº†ä¸€ä¸ªé‡å­æ€å±‚æé‡æ„å·¥å…·åŒ…ï¼Œ5000è¡ŒPythonä»£ç ï¼Œå®ç°äº†çº¿æ€§å’ŒMLEä¸¤ç§æ ¸å¿ƒç®—æ³•ã€‚é‡‡ç”¨å››å±‚åˆ†å±‚æ¶æ„ï¼Œåº”ç”¨å·¥å‚ã€ç­–ç•¥ç­‰è®¾è®¡æ¨¡å¼ï¼Œéµå¾ªSOLIDåŸåˆ™ã€‚é€šè¿‡æŠ•å½±ç®—ç¬¦ç¼“å­˜å°†æ‰¹å¤„ç†æ€§èƒ½æå‡10å€ï¼Œä¸MATLABåŸºå‡†å¯¹é½ç²¾åº¦è¾¾1e-10ã€‚é¡¹ç›®åŒ…å«**106ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ˆ100%é€šè¿‡ï¼Œè¦†ç›–ç‡90%ï¼‰**ï¼Œå®ç°äº†CLIå·¥å…·å’Œæ‰¹å¤„ç†èƒ½åŠ›ã€‚Stage 3 æ–°å¢æ–¹æ³•å¯¹æ¯”åŠŸèƒ½å’Œ 8 ä¸ªæŒ‡æ ‡å­—æ®µã€‚"

### å¡ç‰‡ 2ï¼šæŠ€æœ¯æ ˆ
- **è¯­è¨€**ï¼šPython 3.13+ (å‘ä¸‹å…¼å®¹ 3.9+)
- **æ•°å€¼è®¡ç®—**ï¼šNumPy, SciPy
- **æ•°æ®åˆ†æ**ï¼šPandas
- **å¯è§†åŒ–**ï¼šMatplotlib
- **æµ‹è¯•**ï¼šPytest (**106ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ100%é€šè¿‡ï¼Œè¦†ç›–ç‡90%**)
- **CLI**ï¼šargparse (4ä¸ªå­å‘½ä»¤)
- **ç±»å‹æ£€æŸ¥**ï¼šType Hints (å®Œæ•´ç±»å‹æ ‡æ³¨)
- **ä»£ç è§„èŒƒ**ï¼šPEP 8, å®Œæ•´æ–‡æ¡£å­—ç¬¦ä¸²

### å¡ç‰‡ 3ï¼šæ ¸å¿ƒäº®ç‚¹
1. **æ€§èƒ½ä¼˜åŒ–**ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜ â†’ 10å€æå‡ï¼ˆ50s â†’ 5sï¼‰
2. **æ•°å€¼ç²¾åº¦**ï¼šmakephysical + å²­å›å½’ â†’ è¯¯å·® < 1e-10
3. **å·¥ç¨‹åŒ–**ï¼šå››å±‚æ¶æ„ + è®¾è®¡æ¨¡å¼ + **106ä¸ªæµ‹è¯•ï¼ˆ90%è¦†ç›–ç‡ï¼‰**
4. **Stage 3 âœ…**ï¼š8ä¸ªæ–°å­—æ®µ + Linear vs MLEå¯¹æ¯” + comparisonæ¨¡å—(99è¡Œ)

### å¡ç‰‡ 4ï¼šSOLID åŸåˆ™ï¼ˆé¡¹ç›®ä¾‹å­ï¼‰
- **S**ï¼šDensityMatrix åªè´Ÿè´£ç‰©ç†çº¦æŸ
- **O**ï¼šæ–°å¢é‡æ„ç®—æ³•æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 
- **L**ï¼šLinear/MLE å¯äº’æ¢
- **I**ï¼šResultRepository åªæš´éœ² save/load
- **D**ï¼šController ä¾èµ–æŠ½è±¡ Reconstructor

### å¡ç‰‡ 5ï¼šè®¾è®¡æ¨¡å¼
- **å·¥å‚æ¨¡å¼**ï¼š`_create_reconstructor(method)`
- **ç­–ç•¥æ¨¡å¼**ï¼šLinear/MLE ç®—æ³•åˆ‡æ¢
- **ä»“å‚¨æ¨¡å¼**ï¼š`ResultRepository` æŠ½è±¡æŒä¹…åŒ–
- **å•ä¾‹æ¨¡å¼**ï¼š`ProjectorSet` ç¼“å­˜

### å¡ç‰‡ 6ï¼šPython GIL
- **å®šä¹‰**ï¼šå…¨å±€è§£é‡Šå™¨é”ï¼ŒåŒä¸€æ—¶åˆ»åªå…è®¸ä¸€ä¸ªçº¿ç¨‹æ‰§è¡ŒPythonå­—èŠ‚ç 
- **å½±å“**ï¼šCPUå¯†é›†å‹ä»»åŠ¡æ— æ³•åˆ©ç”¨å¤šæ ¸
- **è§£å†³**ï¼šmultiprocessingï¼ˆå¤šè¿›ç¨‹ï¼‰ã€NumPy/SciPyï¼ˆCæ‰©å±•ï¼‰

### å¡ç‰‡ 7ï¼šåƒåœ¾å›æ”¶
- **å¼•ç”¨è®¡æ•°**ï¼šå¼•ç”¨+1/-1ï¼Œè®¡æ•°ä¸º0ç«‹å³å›æ”¶
- **å¾ªç¯å›æ”¶**ï¼šæ ‡è®°-æ¸…é™¤ç®—æ³•ï¼Œæ£€æµ‹å¾ªç¯å¼•ç”¨
- **åˆ†ä»£å›æ”¶**ï¼šå¯¹è±¡åˆ†3ä»£ï¼Œå¹´è½»ä»£å›æ”¶é¢‘ç‡é«˜

### å¡ç‰‡ 8ï¼šå¤æ‚åº¦åˆ†æ

- çº¿æ€§é‡æ„çš„å¤æ‚åº¦åˆ†æï¼š

  1. å•æ¬¡é‡æ„ï¼šO(nâ´) - ä¸»è¦æ˜¯çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£
  2. æ€»å¤æ‚åº¦ï¼šO(nâ´) - æ— è¿­ä»£ï¼Œä¸€æ¬¡æ±‚è§£
  3. ç¼“å­˜æ•ˆæœï¼šç¬¬ä¸€æ¬¡O(nâ´ + nâ´)ï¼Œåç»­O(nâ´)

   å…³é”®æ´å¯Ÿï¼š

  - çº¿æ€§é‡æ„çš„ç“¶é¢ˆåœ¨çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£ï¼Œæ¯æ¬¡é‡æ„éƒ½æ˜¯O(nâ´)

  - ç¼“å­˜ä¸»è¦èŠ‚çœæŠ•å½±ç®—ç¬¦çš„è®¡ç®—æ—¶é—´ï¼Œä½†çº¿æ€§é‡æ„æœ¬èº«å·²ç»å¾ˆå¿«

  - å¯¹äºå¤§ç»´åº¦ç³»ç»Ÿï¼Œçº¿æ€§é‡æ„æ¯”MLEå¿«å¾—å¤šï¼Œå› ä¸ºæ— è¿­ä»£

- MLEé‡æ„çš„å¤æ‚åº¦åˆ†æ

  1. å•æ¬¡è¿­ä»£ï¼šO(nâ´) - ä¸»è¦æ˜¯æœŸæœ›æ¦‚ç‡è®¡ç®—
  2. æ€»å¤æ‚åº¦ï¼šO(mnâ´) - mæ¬¡è¿­ä»£
  3. ç¼“å­˜æ•ˆæœï¼šç¬¬ä¸€æ¬¡O(nâ´ + mnâ´)ï¼Œåç»­O(mnâ´)

  å…³é”®æ´å¯Ÿï¼š

  - MLEçš„ç“¶é¢ˆåœ¨æœŸæœ›æ¦‚ç‡è®¡ç®—ï¼Œæ¯æ¬¡è¿­ä»£éƒ½æ˜¯O(nâ´)

  - ç¼“å­˜ä¸»è¦èŠ‚çœæŠ•å½±ç®—ç¬¦çš„è®¡ç®—æ—¶é—´

  - å¯¹äºå¤§ç»´åº¦ç³»ç»Ÿï¼ŒMLEçš„è¿­ä»£è®¡ç®—æ˜¯ä¸»è¦ç“¶é¢ˆ

  è¿™å°±æ˜¯ä¸ºä»€ä¹ˆMLEé‡æ„æ¯”çº¿æ€§é‡æ„æ…¢å¾ˆå¤šçš„åŸå› ï¼

### å¡ç‰‡ 9ï¼šæ•°å€¼ç¨³å®šæ€§
**é—®é¢˜1**ï¼šå¯†åº¦çŸ©é˜µç‰©ç†çº¦æŸï¼ˆå„ç±³ã€åŠæ­£å®šã€è¿¹ä¸º1ï¼‰
**æ–¹æ¡ˆ**ï¼šmakephysicalï¼ˆå¼ºåˆ¶å„ç±³ â†’ ç‰¹å¾å€¼åˆ†è§£ â†’ è£å‰ªè´Ÿå€¼ â†’ å½’ä¸€åŒ– â†’ é‡æ„ï¼‰

**é—®é¢˜2**ï¼šçº¿æ€§æ–¹ç¨‹ç»„ç—…æ€ï¼ˆæ¡ä»¶æ•° 10Â¹âµï¼‰
**æ–¹æ¡ˆ**ï¼šå²­å›å½’ï¼ˆmin ||Ax-b||Â² + Î»||x||Â²ï¼‰

### å¡ç‰‡ 10ï¼šStage 3 å¢å¼º âœ… (å·²å®Œæˆ)
- **æ–°å­—æ®µ**ï¼šrank, min/max_eigenvalue, condition_number, eigenvalue_entropy, n_iterations, n_evaluations, success (å…±8ä¸ª)
- **æ–°æ¨¡å—**ï¼šcomparison.py (99è¡Œ) - æ–¹æ³•å¯¹æ¯”æ ¸å¿ƒé€»è¾‘
- **æ•°æ®ä¸€è‡´æ€§**ï¼šå…ˆå†™JSON metricsï¼ŒCSVä»JSONè¯»ï¼ˆå•ä¸€æ•°æ®æºåŸåˆ™ï¼‰
- **CLIå¢å¼º**ï¼š--compare-methods (è‡ªåŠ¨é…å¯¹æ ·æœ¬), --detailed (è¯¦ç»†ç»Ÿè®¡), --output (CSV/JSONå¯¼å‡º)
- **æµ‹è¯•**ï¼š5ä¸ªæ–°æµ‹è¯•ç”¨ä¾‹ï¼Œnp.isclose()å¤„ç†æµ®ç‚¹ç²¾åº¦
- **æµ‹è¯•ç»“æœ**ï¼š106/106 passed (100%), è¦†ç›–ç‡ 90%
- **é¡¹ç›®çŠ¶æ€**ï¼šâœ… ç”Ÿäº§å°±ç»ªï¼Œæ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼Œä»£ç å·²æäº¤

---

## è¡¥å……ï¼šé«˜é¢‘æŠ€æœ¯é—®é¢˜é€ŸæŸ¥

### Q16: Python è£…é¥°å™¨çš„åŸç†ï¼Ÿ

**å›ç­”**ï¼š

> "è£…é¥°å™¨æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª**é«˜é˜¶å‡½æ•°**ï¼ˆæ¥å—å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œè¿”å›å‡½æ•°ï¼‰ã€‚
>
> **åŸç†**ï¼š
> ```python
> def timer(func):
>     def wrapper(*args, **kwargs):
>         start = time.time()
>         result = func(*args, **kwargs)
>         print(f'è€—æ—¶: {time.time() - start:.2f}s')
>         return result
>     return wrapper
> 
> @timer
> def reconstruct(probs):
>     # ç­‰ä»·äº reconstruct = timer(reconstruct)
>     return density
> ```
>
> **é¡¹ç›®åº”ç”¨**ï¼š
> ```python
> @property
> def purity(self):
>     return np.trace(self._matrix @ self._matrix)
> 
> # ç­‰ä»·äº
> purity = property(purity)
> ```
>
> **å¸¦å‚æ•°çš„è£…é¥°å™¨**ï¼š
> ```python
> def cache(maxsize=128):
>     def decorator(func):
>         _cache = {}
>         def wrapper(*args):
>             if args in _cache:
>                 return _cache[args]
>             result = func(*args)
>             if len(_cache) < maxsize:
>                 _cache[args] = result
>             return result
>         return wrapper
>     return decorator
> 
> @cache(maxsize=256)
> def fibonacci(n):
>     if n < 2:
>         return n
>     return fibonacci(n-1) + fibonacci(n-2)
> ```"

### Q17: Python ç”Ÿæˆå™¨å’Œè¿­ä»£å™¨çš„åŒºåˆ«ï¼Ÿ

**å›ç­”**ï¼š

> **è¿­ä»£å™¨ï¼ˆIteratorï¼‰**ï¼š
> - å®ç° `__iter__()` å’Œ `__next__()` æ–¹æ³•çš„å¯¹è±¡
> - å¯ä»¥ç”¨ `for` å¾ªç¯éå†
> ```python
> class Counter:
>     def __init__(self, n):
>         self.n = n
>         self.i = 0
>     
>     def __iter__(self):
>         return self
>     
>     def __next__(self):
>         if self.i < self.n:
>             self.i += 1
>             return self.i
>         raise StopIteration
> 
> for num in Counter(5):
>     print(num)  # 1, 2, 3, 4, 5
> ```
>
> **ç”Ÿæˆå™¨ï¼ˆGeneratorï¼‰**ï¼š
> - ä½¿ç”¨ `yield` å…³é”®å­—çš„å‡½æ•°
> - è‡ªåŠ¨å®ç°è¿­ä»£å™¨åè®®ï¼Œæ›´ç®€æ´
> ```python
> def counter(n):
>     i = 0
>     while i < n:
>         yield i + 1
>         i += 1
> 
> for num in counter(5):
>     print(num)  # 1, 2, 3, 4, 5
> ```
>
> **ä¼˜åŠ¿**ï¼š
> - **å»¶è¿Ÿè®¡ç®—**ï¼šæŒ‰éœ€ç”Ÿæˆï¼ŒèŠ‚çœå†…å­˜
> - **æ— é™åºåˆ—**ï¼šå¯ä»¥ç”Ÿæˆæ— é™åºåˆ—
> - **ç®¡é“æ“ä½œ**ï¼šå¯ä»¥é“¾å¼ç»„åˆ
>
> **é¡¹ç›®ä¸­çš„æ½œåœ¨åº”ç”¨**ï¼š
> ```python
> def batch_loader(csv_path, batch_size=100):
>     \"\"\"æ‰¹é‡åŠ è½½å¤§æ–‡ä»¶ï¼ˆèŠ‚çœå†…å­˜ï¼‰\"\"\"
>     df = pd.read_csv(csv_path, chunksize=batch_size)
>     for chunk in df:
>         yield chunk['probability'].values
> 
> # ä½¿ç”¨
> for probs_batch in batch_loader('large_data.csv'):
>     result = reconstruct(probs_batch)
> ```"

### Q18: Python å¤šç»§æ‰¿å’Œ MROï¼ˆæ–¹æ³•è§£æé¡ºåºï¼‰ï¼Ÿ

**å›ç­”**ï¼š

> **å¤šç»§æ‰¿**ï¼šä¸€ä¸ªç±»å¯ä»¥ç»§æ‰¿å¤šä¸ªçˆ¶ç±»
> ```python
> class A:
>     def method(self):
>         print('A')
> 
> class B(A):
>     def method(self):
>         print('B')
> 
> class C(A):
>     def method(self):
>         print('C')
> 
> class D(B, C):
>     pass
> 
> d = D()
> d.method()  # è¾“å‡ºä»€ä¹ˆï¼Ÿ
> ```
>
> **MROï¼ˆMethod Resolution Orderï¼‰**ï¼š
> - Python ä½¿ç”¨ C3 çº¿æ€§åŒ–ç®—æ³•ç¡®å®šæ–¹æ³•æŸ¥æ‰¾é¡ºåº
> - éµå¾ªï¼š**å¹¿åº¦ä¼˜å…ˆ + ä¿æŒå±€éƒ¨ä¼˜å…ˆ**
> ```python
> print(D.__mro__)
> # (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)
> 
> d.method()  # è¾“å‡º 'B'ï¼ˆB åœ¨ C ä¹‹å‰ï¼‰
> ```
>
> **super() çš„æ­£ç¡®ç”¨æ³•**ï¼š
> ```python
> class A:
>     def __init__(self):
>         print('A init')
> 
> class B(A):
>     def __init__(self):
>         super().__init__()  # è°ƒç”¨ MRO ä¸­çš„ä¸‹ä¸€ä¸ªç±»
>         print('B init')
> 
> class C(A):
>     def __init__(self):
>         super().__init__()
>         print('C init')
> 
> class D(B, C):
>     def __init__(self):
>         super().__init__()
>         print('D init')
> 
> d = D()
> # è¾“å‡ºï¼šA init â†’ C init â†’ B init â†’ D init
> ```
>
> **é¡¹ç›®ä¸­çš„å»ºè®®**ï¼š
> - ä¼˜å…ˆä½¿ç”¨**ç»„åˆ**è€Œéå¤šç»§æ‰¿
> - å¦‚æœå¿…é¡»å¤šç»§æ‰¿ï¼Œç¡®ä¿ç†è§£ MRO
> - ä½¿ç”¨ `super()` è€Œéç›´æ¥è°ƒç”¨çˆ¶ç±»"

### Q19: å¦‚ä½•ä¼˜åŒ– Python ä»£ç æ€§èƒ½ï¼Ÿ

**å›ç­”**ï¼š

> **1. ä½¿ç”¨å†…ç½®å‡½æ•°å’Œåº“**
> ```python
> # âŒ æ…¢
> result = []
> for i in range(1000000):
>     result.append(i ** 2)
> 
> # âœ… å¿«ï¼ˆåˆ—è¡¨æ¨å¯¼å¼ï¼‰
> result = [i ** 2 for i in range(1000000)]
> 
> # âœ… æ›´å¿«ï¼ˆNumPyï¼‰
> result = np.arange(1000000) ** 2
> ```
>
> **2. é¿å…å¾ªç¯ï¼Œä½¿ç”¨å‘é‡åŒ–**
> ```python
> # âŒ æ…¢ï¼ˆPython å¾ªç¯ï¼‰
> for i in range(n):
>     for j in range(n):
>         matrix[i, j] = compute(i, j)
> 
> # âœ… å¿«ï¼ˆNumPy å‘é‡åŒ–ï¼‰
> i, j = np.meshgrid(np.arange(n), np.arange(n))
> matrix = compute(i, j)
> ```
>
> **3. ä½¿ç”¨ç¼“å­˜**
> ```python
> from functools import lru_cache
> 
> @lru_cache(maxsize=None)
> def expensive_computation(n):
>     # æ˜‚è´µçš„è®¡ç®—
>     return result
> ```
>
> **4. ä½¿ç”¨ç”Ÿæˆå™¨èŠ‚çœå†…å­˜**
> ```python
> # âŒ å†…å­˜å ç”¨å¤§
> data = [process(x) for x in huge_list]
> 
> # âœ… å»¶è¿Ÿè®¡ç®—
> data = (process(x) for x in huge_list)
> ```
>
> **5. æ€§èƒ½åˆ†æå·¥å…·**
> ```python
> # cProfileï¼šæ‰¾åˆ°çƒ­ç‚¹å‡½æ•°
> python -m cProfile -s cumtime script.py
> 
> # line_profilerï¼šé€è¡Œåˆ†æ
> @profile
> def slow_function():
>     # ...
> 
> kernprof -l -v script.py
> ```
>
> **6. ä½¿ç”¨ Numba JIT ç¼–è¯‘**
> ```python
> from numba import jit
> 
> @jit(nopython=True)
> def fast_loop(n):
>     result = 0
>     for i in range(n):
>         result += i ** 2
>     return result
> ```
>
> **é¡¹ç›®ä¸­çš„å®è·µ**ï¼š
> - NumPy å‘é‡åŒ–ï¼šå¯†åº¦çŸ©é˜µè®¡ç®—
> - ç¼“å­˜ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜
> - ä½¿ç”¨æˆç†Ÿåº“ï¼šSciPy çš„ä¼˜åŒ–å™¨"

### Q20: RESTful API è®¾è®¡åŸåˆ™ï¼Ÿï¼ˆæ‰©å±•çŸ¥è¯†ï¼‰

**å›ç­”**ï¼š

> **å¦‚æœè¦å°†è¿™ä¸ªé¡¹ç›®æ”¹é€ æˆ Web æœåŠ¡ï¼Œæˆ‘ä¼šè¿™æ ·è®¾è®¡ APIï¼š**
>
> **1. èµ„æºå¯¼å‘**
> ```
> GET    /api/v1/reconstructions          # è·å–é‡æ„åˆ—è¡¨
> POST   /api/v1/reconstructions          # åˆ›å»ºæ–°é‡æ„ä»»åŠ¡
> GET    /api/v1/reconstructions/{id}     # è·å–å•ä¸ªé‡æ„ç»“æœ
> DELETE /api/v1/reconstructions/{id}     # åˆ é™¤é‡æ„è®°å½•
> 
> GET    /api/v1/reconstructions/{id}/bell-analysis  # Bellæ€åˆ†æ
> GET    /api/v1/reconstructions/summary              # æ±‡æ€»ç»Ÿè®¡
> ```
>
> **2. HTTP æ–¹æ³•è¯­ä¹‰**
> - `GET`ï¼šæŸ¥è¯¢ï¼ˆå¹‚ç­‰ã€å®‰å…¨ï¼‰
> - `POST`ï¼šåˆ›å»ºï¼ˆéå¹‚ç­‰ï¼‰
> - `PUT`ï¼šæ›´æ–°ï¼ˆå¹‚ç­‰ï¼‰
> - `DELETE`ï¼šåˆ é™¤ï¼ˆå¹‚ç­‰ï¼‰
>
> **3. è¯·æ±‚/å“åº”ç¤ºä¾‹**
> ```python
> # POST /api/v1/reconstructions
> {
>   "probabilities": [0.5, 0.5, 0.25, 0.25],
>   "dimension": 2,
>   "method": "both",
>   "config": {
>     "mle_max_iterations": 2000,
>     "tolerance": 1e-9
>   }
> }
>
> # Response: 201 Created
> {
>   "id": "rec_123abc",
>   "status": "completed",
>   "results": {
>     "linear": {
>       "purity": 0.75,
>       "fidelity": 0.9998
>     },
>     "mle": {
>       "purity": 0.75,
>       "fidelity": 0.9999
>     }
>   },
>   "created_at": "2025-10-07T10:30:00Z"
> }
> ```
>
> **4. çŠ¶æ€ç **
> - `200 OK`ï¼šæˆåŠŸ
> - `201 Created`ï¼šåˆ›å»ºæˆåŠŸ
> - `400 Bad Request`ï¼šè¯·æ±‚å‚æ•°é”™è¯¯
> - `404 Not Found`ï¼šèµ„æºä¸å­˜åœ¨
> - `500 Internal Server Error`ï¼šæœåŠ¡å™¨é”™è¯¯
>
> **5. Flask å®ç°ç¤ºä¾‹**
> ```python
> from flask import Flask, request, jsonify
> 
> app = Flask(__name__)
> 
> @app.route('/api/v1/reconstructions', methods=['POST'])
> def create_reconstruction():
>     data = request.get_json()
>     
>     # éªŒè¯å‚æ•°
>     if 'probabilities' not in data:
>         return jsonify({'error': 'Missing probabilities'}), 400
>     
>     # æ‰§è¡Œé‡æ„
>     reconstructor = LinearReconstructor(dimension=data['dimension'])
>     result = reconstructor.reconstruct(data['probabilities'])
>     
>     # ä¿å­˜ç»“æœ
>     record_id = save_record(result)
>     
>     return jsonify({
>         'id': record_id,
>         'status': 'completed',
>         'purity': result.density.purity
>     }), 201
> ```"

### Q21: SQL åŸºç¡€ä¸ç´¢å¼•ä¼˜åŒ–ï¼Ÿï¼ˆæ‰©å±•çŸ¥è¯†ï¼‰

**å›ç­”**ï¼š

> **å¸¸è§ SQL æ“ä½œ**ï¼š
> ```sql
> -- æŸ¥è¯¢
> SELECT method, AVG(purity), COUNT(*)
> FROM reconstruction_records
> WHERE success = true
> GROUP BY method
> HAVING AVG(purity) > 0.7
> ORDER BY AVG(purity) DESC;
> 
> -- è¿æ¥ï¼ˆJOINï¼‰
> SELECT l.sample_id, l.purity AS linear_purity, m.purity AS mle_purity
> FROM reconstruction_records l
> INNER JOIN reconstruction_records m
>   ON l.sample_id = m.sample_id
> WHERE l.method = 'linear' AND m.method = 'mle';
> 
> -- å­æŸ¥è¯¢
> SELECT *
> FROM reconstruction_records
> WHERE purity > (SELECT AVG(purity) FROM reconstruction_records);
> ```
>
> **ç´¢å¼•ä¼˜åŒ–**ï¼š
> ```sql
> -- å•åˆ—ç´¢å¼•
> CREATE INDEX idx_method ON reconstruction_records(method);
> 
> -- å¤åˆç´¢å¼•ï¼ˆé¡ºåºé‡è¦ï¼‰
> CREATE INDEX idx_sample_method ON reconstruction_records(sample_id, method);
> 
> -- ä½¿ç”¨ç´¢å¼•çš„åœºæ™¯
> SELECT * FROM reconstruction_records WHERE method = 'mle';  -- ä½¿ç”¨ idx_method
> SELECT * FROM reconstruction_records WHERE sample_id = 1;   -- ä½¿ç”¨ idx_sample_method
> SELECT * FROM reconstruction_records WHERE purity > 0.8;    -- ä¸ä½¿ç”¨ç´¢å¼•ï¼ˆå…¨è¡¨æ‰«æï¼‰
> ```
>
> **ç´¢å¼•åŸç†**ï¼š
> - B+ æ ‘ç»“æ„ï¼ˆå¹³è¡¡å¤šè·¯æŸ¥æ‰¾æ ‘ï¼‰
> - å¶å­èŠ‚ç‚¹å­˜å‚¨æ•°æ®/æŒ‡é’ˆ
> - æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
>
> **ç´¢å¼•çš„ä»£ä»·**ï¼š
> - å ç”¨é¢å¤–ç©ºé—´
> - æ’å…¥/æ›´æ–°æ—¶éœ€ç»´æŠ¤ç´¢å¼•ï¼ˆå˜æ…¢ï¼‰
> - æƒè¡¡ï¼šè¯»å¤šå†™å°‘ â†’ åŠ ç´¢å¼•ï¼›å†™å¤šè¯»å°‘ â†’ å°‘åŠ ç´¢å¼•"

### Q22: Git å¸¸ç”¨å‘½ä»¤å’Œåœºæ™¯ï¼Ÿ

**å›ç­”**ï¼š

> **æ—¥å¸¸å¼€å‘æµç¨‹**ï¼š
> ```bash
> # 1. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
> git checkout -b feature/new-algorithm
> 
> # 2. å¼€å‘å¹¶æäº¤
> git add qtomography/domain/bayesian.py
> git commit -m "feat: æ·»åŠ è´å¶æ–¯é‡æ„ç®—æ³•"
> 
> # 3. æŸ¥çœ‹çŠ¶æ€
> git status
> git log --oneline --graph
> 
> # 4. æ‹‰å–æœ€æ–°ä»£ç 
> git checkout develop
> git pull origin develop
> 
> # 5. åˆå¹¶åŠŸèƒ½åˆ†æ”¯
> git merge feature/new-algorithm
> 
> # 6. è§£å†³å†²çªï¼ˆå¦‚æœæœ‰ï¼‰
> git status  # æŸ¥çœ‹å†²çªæ–‡ä»¶
> # æ‰‹åŠ¨ç¼–è¾‘å†²çªæ–‡ä»¶
> git add conflicted_file.py
> git commit -m "merge: è§£å†³åˆå¹¶å†²çª"
> 
> # 7. æ¨é€åˆ°è¿œç¨‹
> git push origin develop
> ```
>
> **å¸¸è§åœºæ™¯**ï¼š
>
> **åœºæ™¯ 1ï¼šæ’¤é”€ä¿®æ”¹**
> ```bash
> # æ’¤é”€å·¥ä½œåŒºä¿®æ”¹ï¼ˆæœª addï¼‰
> git checkout -- file.py
> 
> # æ’¤é”€æš‚å­˜åŒºï¼ˆå·² addï¼Œæœª commitï¼‰
> git reset HEAD file.py
> 
> # æ’¤é”€æœ€åä¸€æ¬¡æäº¤ï¼ˆä¿ç•™ä¿®æ”¹ï¼‰
> git reset --soft HEAD~1
> 
> # æ’¤é”€æœ€åä¸€æ¬¡æäº¤ï¼ˆä¸¢å¼ƒä¿®æ”¹ï¼‰
> git reset --hard HEAD~1
> ```
>
> **åœºæ™¯ 2ï¼šæš‚å­˜å½“å‰å·¥ä½œ**
> ```bash
> # ä¸´æ—¶ä¿å­˜ä¿®æ”¹ï¼ˆåˆ‡æ¢åˆ†æ”¯ï¼‰
> git stash
> 
> # æ¢å¤æš‚å­˜çš„ä¿®æ”¹
> git stash pop
> 
> # æŸ¥çœ‹æš‚å­˜åˆ—è¡¨
> git stash list
> ```
>
> **åœºæ™¯ 3ï¼šä¿®æ”¹æäº¤å†å²**
> ```bash
> # ä¿®æ”¹æœ€åä¸€æ¬¡æäº¤ä¿¡æ¯
> git commit --amend
> 
> # åˆå¹¶å¤šä¸ªæäº¤ï¼ˆäº¤äº’å¼ rebaseï¼‰
> git rebase -i HEAD~3
> ```
>
> **åœºæ™¯ 4ï¼šæŸ¥çœ‹å·®å¼‚**
> ```bash
> # å·¥ä½œåŒº vs æš‚å­˜åŒº
> git diff
> 
> # æš‚å­˜åŒº vs æœ€åä¸€æ¬¡æäº¤
> git diff --cached
> 
> # ä¸¤ä¸ªåˆ†æ”¯çš„å·®å¼‚
> git diff main..feature/new-algorithm
> ```"

---

## ç»ˆæå¤ä¹ ï¼š3åˆ†é’Ÿé€Ÿç­”æ¨¡æ¿

### é¡¹ç›®ä»‹ç»ï¼ˆ1åˆ†é’Ÿï¼‰
"æˆ‘å¼€å‘äº†ä¸€ä¸ªé‡å­æ€å±‚æé‡æ„å·¥å…·åŒ…ï¼Œ5000è¡ŒPythonä»£ç ï¼Œå®ç°äº†çº¿æ€§å’ŒMLEä¸¤ç§æ ¸å¿ƒç®—æ³•ã€‚é‡‡ç”¨**å››å±‚åˆ†å±‚æ¶æ„**ï¼Œåº”ç”¨å·¥å‚ã€ç­–ç•¥ç­‰è®¾è®¡æ¨¡å¼ï¼Œéµå¾ªSOLIDåŸåˆ™ã€‚é€šè¿‡æŠ•å½±ç®—ç¬¦ç¼“å­˜å°†æ‰¹å¤„ç†æ€§èƒ½æå‡10å€ï¼Œä¸MATLABåŸºå‡†å¯¹é½ç²¾åº¦è¾¾1e-10ã€‚é¡¹ç›®åŒ…å«**106ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ˆ100%é€šè¿‡ï¼Œè¦†ç›–ç‡90%ï¼‰**ï¼Œæœ€è¿‘å®Œæˆçš„Stage 3å¢å¼ºæ–°å¢äº†8ä¸ªæŒ‡æ ‡å­—æ®µã€comparisonæ¨¡å—å’Œæ–¹æ³•å¯¹æ¯”åŠŸèƒ½ã€‚**é¡¹ç›®å·²å®Œæˆå¼€å‘ï¼Œç”Ÿäº§å°±ç»ªã€‚**"

### æŠ€æœ¯æ ˆï¼ˆ30ç§’ï¼‰
"Python 3.13+, NumPy/SciPyæ•°å€¼è®¡ç®—, Pandasæ•°æ®åˆ†æ, Matplotlibå¯è§†åŒ–, Pytestæµ‹è¯•æ¡†æ¶ï¼ˆ106ä¸ªæµ‹è¯•ï¼Œ90%è¦†ç›–ç‡ï¼‰, argparseæ„å»ºCLIå·¥å…·ã€‚éµå¾ªPEP 8è§„èŒƒï¼Œå®Œæ•´ç±»å‹æç¤ºå’Œæ–‡æ¡£å­—ç¬¦ä¸²ã€‚"

### æŠ€æœ¯äº®ç‚¹ï¼ˆ1åˆ†é’Ÿï¼‰
"**æ€§èƒ½ä¼˜åŒ–**ï¼šæŠ•å½±ç®—ç¬¦ç¼“å­˜ï¼Œä»50ç§’é™è‡³5ç§’ï¼Œ10å€æå‡ã€‚**æ•°å€¼ç¨³å®šæ€§**ï¼šmakephysicalç®—æ³•å¤„ç†ç‰©ç†çº¦æŸï¼Œå²­å›å½’è§£å†³ç—…æ€æ–¹ç¨‹ç»„ã€‚**å·¥ç¨‹åŒ–å®è·µ**ï¼šå››å±‚æ¶æ„é™ä½è€¦åˆï¼Œè®¾è®¡æ¨¡å¼æå‡å¯æ‰©å±•æ€§ï¼ŒTDDä¿è¯ä»£ç è´¨é‡ï¼ˆ106ä¸ªæµ‹è¯•ï¼Œ90%è¦†ç›–ç‡ï¼‰ã€‚**Stage 3å¢å¼ºï¼ˆå·²å®Œæˆï¼‰**ï¼šæ‰©å±•æŒ‡æ ‡ç³»ç»Ÿï¼ˆ8ä¸ªæ–°å­—æ®µï¼‰ï¼Œæ–°å¢comparisonæ¨¡å—ï¼ˆ99è¡Œï¼‰ï¼Œå®ç°Linear vs MLEå¯¹æ¯”ï¼Œéµå¾ªå•ä¸€æ•°æ®æºåŸåˆ™ä¿è¯ä¸€è‡´æ€§ï¼Œé€šè¿‡5ä¸ªæ–°æµ‹è¯•éªŒè¯æ­£ç¡®æ€§ã€‚"

### æœ€å¤§æŒ‘æˆ˜ï¼ˆ30ç§’ï¼‰
"æ•°å€¼ç¨³å®šæ€§ã€‚å¯†åº¦çŸ©é˜µå¿…é¡»æ»¡è¶³å„ç±³ã€åŠæ­£å®šã€è¿¹ä¸º1çš„ç‰©ç†çº¦æŸï¼Œä½†æµ®ç‚¹è¯¯å·®ä¼šå¯¼è‡´è¿åã€‚æˆ‘å®ç°äº†makephysicalç®—æ³•è¿›è¡Œä¿®æ­£ã€‚å¦å¤–ï¼Œçº¿æ€§æ–¹ç¨‹ç»„æ¡ä»¶æ•°è¾¾10^15ï¼Œé€šè¿‡å²­å›å½’è§£å†³ã€‚æœ€ç»ˆä¸MATLABåŸºå‡†å¯¹é½ï¼Œè¯¯å·®<1e-10ã€‚"

---

## é¢è¯•å‰æœ€åæ£€æŸ¥æ¸…å• ğŸ”¥ (10æœˆ10æ—¥)

### âœ… åŸºç¡€çŸ¥è¯†å‡†å¤‡ (å¿…é¡»ç†Ÿè®°)
- [ ] Python é«˜çº§ç‰¹æ€§ï¼ˆproperty, dataclass, ç±»å‹æç¤ºï¼‰èƒŒç†Ÿ
- [ ] GIL å’Œåƒåœ¾å›æ”¶æœºåˆ¶ç†è§£é€å½»
- [ ] SOLID åŸåˆ™æ¯ä¸ªéƒ½èƒ½ä¸¾é¡¹ç›®ä¾‹å­
- [ ] 4ç§è®¾è®¡æ¨¡å¼çš„é¡¹ç›®åº”ç”¨è®°ç‰¢
- [ ] è¿›ç¨‹vsçº¿ç¨‹ã€æ—¶é—´/ç©ºé—´å¤æ‚åº¦å‡†å¤‡å……åˆ†

### âœ… é¡¹ç›®å‡†å¤‡ (æ ¸å¿ƒ)
- [ ] 30ç§’ã€1åˆ†é’Ÿã€3åˆ†é’Ÿç‰ˆæœ¬ä»‹ç»æµç•…
- [ ] **å…³é”®æ•°å­—è®°ç‰¢**ï¼š5000è¡Œã€**106æµ‹è¯•ï¼ˆ90%è¦†ç›–ç‡ï¼‰**ã€10å€æå‡ã€1e-10ç²¾åº¦
- [ ] **Stage 3** çš„è®¾è®¡æ€è·¯å’Œå®ç°ç»†èŠ‚æ¸…æ¥šï¼ˆ8ä¸ªå­—æ®µã€comparisonæ¨¡å—ã€å•ä¸€æ•°æ®æºï¼‰
- [ ] èƒ½æ‰‹å†™ makephysical ç®—æ³•ã€å·¥å‚æ–¹æ³•
- [ ] èƒ½è§£é‡Š comparison.py çš„è®¾è®¡ï¼ˆ99è¡Œï¼Œæ–¹æ³•å¯¹æ¯”æ ¸å¿ƒé€»è¾‘ï¼‰

### âœ… è¡Œä¸ºé¢è¯•å‡†å¤‡
- [ ] æŠ€æœ¯éš¾ç‚¹ï¼ˆæ•°å€¼ç¨³å®šæ€§ï¼‰çš„è§£å†³æ–¹æ¡ˆæ¸…æ™°
- [ ] å›¢é˜Ÿåä½œæ¡ˆä¾‹ï¼ˆæ•°æ®ä¸€è‡´æ€§è®¨è®ºï¼‰å‡†å¤‡å¥½
- [ ] å­¦ä¹ èƒ½åŠ›æ¡ˆä¾‹ï¼ˆMATLABâ†’Pythonã€ç†è®ºâ†’å·¥ç¨‹ï¼‰
- [ ] **æœ€è¿‘å®Œæˆçš„å·¥ä½œ**ï¼šStage 3 å…¨éƒ¨å®Œæˆï¼Œ106ä¸ªæµ‹è¯•å…¨éƒ¨é€šè¿‡

### âœ… å¿ƒæ€å‡†å¤‡
- [ ] ä¿æŒè‡ªä¿¡ä½†è°¦è™š
- [ ] ä¸ä¼šçš„é—®é¢˜è¯šå®å›ç­”ï¼Œè¡¨è¾¾å­¦ä¹ æ„æ„¿
- [ ] å‡†å¤‡2-3ä¸ªé—®é¢˜ç»™é¢è¯•å®˜
- [ ] **å¼ºè°ƒé¡¹ç›®å·²å®Œæˆã€ç”Ÿäº§å°±ç»ªã€æ‰€æœ‰æµ‹è¯•é€šè¿‡**

---

**ç¥ä½ é¢è¯•é¡ºåˆ©ï¼è®°ä½ï¼šæŠ€æœ¯å¯ä»¥å­¦ï¼Œæ€åº¦å’Œæ½œåŠ›æ›´é‡è¦ã€‚å±•ç°ä½ çš„çƒ­æƒ…ã€æ€è€ƒèƒ½åŠ›å’Œå­¦ä¹ åŠ¨åŠ›ï¼ğŸ’ª**"