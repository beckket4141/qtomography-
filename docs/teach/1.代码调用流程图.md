# é‡å­æ€å±‚æé‡æ„é¡¹ç›®ä»£ç è°ƒç”¨æµç¨‹å›¾

> **ç›®æ ‡**ï¼šå±•ç¤ºä»£ç çš„å…·ä½“è°ƒç”¨å…³ç³»å’Œæ‰§è¡Œé¡ºåº  
> **æ›´æ–°æ—¥æœŸ**: 2025å¹´11æœˆ  
> **é¡¹ç›®ç‰ˆæœ¬**: v1.0.0

---

## ğŸ¯ **æ•´ä½“è°ƒç”¨é“¾è·¯**

```
main() â†’ _cmd_reconstruct() â†’ run_batch() â†’ controller.run_batch() â†’ reconstruct_with_details()
```

---

## ğŸ“Š **è¯¦ç»†è°ƒç”¨æµç¨‹å›¾**

### **1. CLIå±‚è°ƒç”¨**

```mermaid
graph TD
    A[ç”¨æˆ·å‘½ä»¤] --> B[main()]
    B --> C[build_parser()]
    C --> D[args.func(args)]
    D --> E[_cmd_reconstruct()]
    
    E --> F[å‚æ•°è§£æ]
    F --> G[æ„å»ºReconstructionConfig]
    G --> H[run_batch(config)]
    H --> I[è¾“å‡ºç»“æœä¿¡æ¯]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/cli/main.py
def main(argv=None):
    parser = build_parser()
    args = parser.parse_args(argv)
    return args.func(args)  # è°ƒç”¨å­å‘½ä»¤å‡½æ•°

def _cmd_reconstruct(args):
    config = ReconstructionConfig(...)
    result = run_batch(config)  # è°ƒç”¨åº”ç”¨å±‚
    return 0
```

### **2. åº”ç”¨å±‚è°ƒç”¨**

```mermaid
graph TD
    A[run_batch(config)] --> B[ReconstructionController()]
    B --> C[controller.run_batch(config)]
    
    C --> D[åŠ è½½æ•°æ®]
    D --> E[åˆ›å»ºé‡æ„å™¨]
    E --> F[æ‰¹å¤„ç†å¾ªç¯]
    
    F --> G[çº¿æ€§é‡æ„]
    F --> H[WLSé‡æ„]
    F --> I[RÏR Stricté‡æ„]
    F --> J[MLEé‡æ„]
    
    G --> K[ä¿å­˜ç»“æœ]
    H --> K
    I --> K
    J --> K
    K --> L[ç”Ÿæˆæ±‡æ€»]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/app/controller.py
def run_batch(config):
    controller = ReconstructionController()
    return controller.run_batch(config)

class ReconstructionController:
    def run_batch(self, config):
        # åŠ è½½æ•°æ®
        data = _load_probabilities(config.input_path, config.sheet)
        
        # åˆ›å»ºé‡æ„å™¨ï¼ˆæ ¹æ®methodå‚æ•°ï¼‰
        if "linear" in config.methods:
            linear = LinearReconstructor(dimension, design=config.design, ...)
        if "wls" in config.methods:
            wls = WLSReconstructor(dimension, design=config.design, ...)
        if "rhor_strict" in config.methods:
            rhor = RrhoStrictReconstructor(dimension, design=config.design, ...)
        if "mle" in config.methods:
            mle = MLEReconstructor(dimension, design=config.design, ...)
        
        # æ‰¹å¤„ç†å¾ªç¯
        for idx in range(sample_count):
            probs = data[:, idx]
            
            # æ ¹æ®é…ç½®é€‰æ‹©é‡æ„æ–¹æ³•
            if linear is not None:
                linear_result = linear.reconstruct_with_details(probs)
            if wls is not None:
                wls_result = wls.reconstruct_with_details(probs)
            if rhor is not None:
                rhor_result = rhor.reconstruct_with_details(probs)
            if mle is not None:
                mle_result = mle.reconstruct_with_details(probs)
```

### **3. é¢†åŸŸå±‚è°ƒç”¨**

#### **3.1 çº¿æ€§é‡æ„è°ƒç”¨**

```mermaid
graph TD
    A[linear.reconstruct_with_details(probs)] --> B[_normalize_probabilities_grouped()]
    B --> C[projector_set.measurement_matrix]
    C --> D{æ˜¯å¦æœ‰æ­£åˆ™åŒ–?}
    D -->|å¦| E[np.linalg.lstsq()]
    D -->|æ˜¯| F[å²­å›å½’æ±‚è§£]
    E --> G[_vec_to_density_matrix()]
    F --> G
    G --> H[DensityMatrix()]
    H --> I[LinearReconstructionResult]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/domain/reconstruction/linear.py
def reconstruct_with_details(self, probabilities):
    # 1. å½’ä¸€åŒ–æ¦‚ç‡ï¼ˆæŒ‰ç»„ï¼‰
    probs = self._normalize_probabilities_grouped(probabilities)
    
    # 2. è·å–æµ‹é‡çŸ©é˜µ
    measurement_matrix = self.projector_set.measurement_matrix
    
    # 3. æœ€å°äºŒä¹˜æ±‚è§£æˆ–å²­å›å½’
    if self.regularization is None:
        rho_vec, residuals, rank, singular_values = np.linalg.lstsq(
            measurement_matrix, probs, rcond=None
        )
    else:
        # å²­å›å½’: (M^T M + Î» I) rho_vec = M^T P
        mtm = measurement_matrix.T @ measurement_matrix
        rho_vec = np.linalg.solve(mtm + self.regularization * I, M.T @ probs)
    
    # 4. é‡æ„å¯†åº¦çŸ©é˜µ
    rho_matrix = rho_vec.reshape(self.dimension, self.dimension).conj()
    
    # 5. ç‰©ç†åŒ–å¤„ç†
    density = DensityMatrix(rho_matrix, tolerance=self.tolerance, ...)
    
    return LinearReconstructionResult(...)
```

#### **3.2 WLSé‡æ„è°ƒç”¨**

```mermaid
graph TD
    A[wls.reconstruct_with_details(probs)] --> B[_normalize_probabilities_grouped()]
    B --> C[_prepare_initial_density()]
    C --> D[encode_density_to_params()]
    D --> E[scipy.optimize.minimize()]
    E --> F[_objective_function()]
    F --> G[decode_params_to_density()]
    G --> H[DensityMatrix()]
    H --> I[WLSReconstructionResult]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/domain/reconstruction/wls.py
def reconstruct_with_details(self, probabilities, initial_density=None):
    # 1. å½’ä¸€åŒ–æ¦‚ç‡
    probs = self._normalize_probabilities_grouped(probabilities)
    
    # 2. å‡†å¤‡åˆå§‹å¯†åº¦çŸ©é˜µ
    if initial_density is None:
        initial_density = self._prepare_initial_density(probs)
    
    # 3. å‚æ•°åŒ–
    params0 = self.encode_density_to_params(initial_density)
    
    # 4. ä¼˜åŒ–æ±‚è§£
    res = minimize(
        fun=self._objective_function,
        x0=params0,
        args=(probs, self.projector_set.projectors, self.regularization),
        method=self.optimizer,  # L-BFGS-B
        options={"maxiter": self.max_iterations, "ftol": self.optimizer_ftol}
    )
    
    # 5. é‡æ„å¯†åº¦çŸ©é˜µ
    rho_opt = self.decode_params_to_density(res.x)
    density = DensityMatrix(rho_opt, tolerance=self.tolerance, ...)
    
    return WLSReconstructionResult(...)
```

#### **3.3 RÏR Stricté‡æ„è°ƒç”¨**

```mermaid
graph TD
    A[rhor.reconstruct_with_details(counts_or_probs)] --> B[_normalize_per_group()]
    B --> C[_prepare_support_operators()]
    C --> D[_build_normalized_povm()]
    D --> E[_iterate_rrr_sigma()]
    E --> F[æ˜ å°„å›Ïç©ºé—´]
    F --> G[DensityMatrix()]
    G --> H[RrhoStrictReconstructionResult]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/domain/reconstruction/rhor_strict.py
def reconstruct_with_details(self, counts_or_probs):
    # 1. æŒ‰ç»„å½’ä¸€åŒ–
    f = self._normalize_per_group(counts_or_probs)
    
    # 2. å‡†å¤‡æ”¯æ’‘ç®—ç¬¦
    projectors = self.projector_set.projectors
    H = np.sum(projectors, axis=0)
    (Pi, H_sqrt, H_sqrt_inv, H_inv, support_dim, ...) = self._prepare_support_operators(H)
    
    # 3. æ„å»ºå½’ä¸€åŒ–POVM
    E_tilde, diagnostics = self._build_normalized_povm(projectors, US, H_sqrt_inv, support_dim)
    
    # 4. åœ¨Ïƒç©ºé—´ä¸­æ‰§è¡ŒRÏRè¿­ä»£
    sigma0 = np.eye(support_dim, dtype=complex) / float(support_dim)
    sigma, q, iters, converged, ll, iter_diagnostics = self._iterate_rrr_sigma(E_tilde, f, sigma0)
    
    # 5. æ˜ å°„å›Ïç©ºé—´
    sigma_full = US @ sigma @ US.conj().T
    rho_raw = H_sqrt_inv @ sigma_full @ H_sqrt_inv
    rho_raw = rho_raw / np.real(np.trace(H_inv @ sigma_full))
    
    # 6. ç‰©ç†åŒ–å¤„ç†
    density = DensityMatrix(rho_raw, tolerance=self.tolerance, ...)
    
    return RrhoStrictReconstructionResult(...)
```

#### **3.4 MLEé‡æ„è°ƒç”¨**

```mermaid
graph TD
    A[mle.reconstruct_with_details(probs)] --> B[_normalize_probabilities()]
    B --> C[_get_initial_density()]
    C --> D[_encode_density_to_params()]
    D --> E[scipy.optimize.minimize()]
    E --> F[_negative_log_likelihood()]
    F --> G[_decode_params_to_density()]
    G --> H[DensityMatrix()]
    H --> I[MLEReconstructionResult]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/domain/reconstruction/mle.py
def reconstruct_with_details(self, probabilities, initial_density=None):
    # 1. å½’ä¸€åŒ–æ¦‚ç‡
    probs = self._normalize_probabilities(probabilities)
    
    # 2. è·å–åˆå§‹å¯†åº¦çŸ©é˜µ
    if initial_density is None:
        initial_density = self._get_initial_density(probs)
    
    # 3. Choleskyå‚æ•°åŒ–
    params = self._encode_density_to_params(initial_density)
    
    # 4. ä¼˜åŒ–æ±‚è§£
    result = minimize(
        self._negative_log_likelihood,
        params,
        method='L-BFGS-B',
        jac=self._gradient
    )
    
    # 5. é‡æ„å¯†åº¦çŸ©é˜µ
    rho = self._decode_params_to_density(result.x)
    
    # 6. ç‰©ç†åŒ–å¤„ç†
    density = DensityMatrix(rho, tolerance=self.tolerance, ...)
    
    return MLEReconstructionResult(...)
```

### **4. åŸºç¡€è®¾æ–½å±‚è°ƒç”¨**

```mermaid
graph TD
    A[ä¿å­˜ç»“æœ] --> B[ResultRepository.save()]
    B --> C[record.to_serializable()]
    C --> D[JSONæ–‡ä»¶ä¿å­˜]
    D --> E[CSVæ±‡æ€»æ›´æ–°]
    
    A --> F[è°±åˆ†è§£åˆ†æ] --> G[SpectralReporter.save()]
    G --> H[ç”Ÿæˆè°±åˆ†è§£æŠ¥å‘Š]
    
    A --> I[å¯è§†åŒ–] --> J[ReconstructionVisualizer]
    J --> K[ç”Ÿæˆå›¾è¡¨]
    K --> L[ä¿å­˜PNGæ–‡ä»¶]
    
    A --> M[è°±åˆ†è§£å¯è§†åŒ–] --> N[SpectralVisualizer]
    N --> O[ç”Ÿæˆç‰¹å¾å€¼å›¾è¡¨]
    O --> P[ä¿å­˜å›¾åƒ]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/infrastructure/persistence/result_repository.py
def save(self, record: ReconstructionRecord):
    payload = record.to_serializable()
    
    # ä¿å­˜JSON
    with path.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, ensure_ascii=False, indent=2)
    
    # æ›´æ–°CSV
    self._append_to_csv(payload)

# qtomography/infrastructure/persistence/spectral_reporter.py
def save(self, spectral_result: SpectralResult, output_path: Path):
    # ç”Ÿæˆè°±åˆ†è§£æŠ¥å‘Š
    report = self._generate_report(spectral_result)
    report.to_csv(output_path)
```

---

## ğŸ”„ **å®Œæ•´æ‰§è¡Œæ—¶åº**

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant CLI as CLIå±‚
    participant APP as åº”ç”¨å±‚
    participant LIN as çº¿æ€§é‡æ„å™¨
    participant WLS as WLSé‡æ„å™¨
    participant RHO as RÏRé‡æ„å™¨
    participant MLE as MLEé‡æ„å™¨
    participant REPO as ç»“æœä»“åº“
    participant SPEC as è°±åˆ†è§£
    
    U->>CLI: qtomography reconstruct data.csv
    CLI->>CLI: è§£æå‚æ•°
    CLI->>APP: run_batch(config)
    
    APP->>APP: åŠ è½½CSVæ•°æ®
    APP->>APP: åˆ›å»ºé‡æ„å™¨å®ä¾‹
    
    loop æ¯ä¸ªæ ·æœ¬
        alt çº¿æ€§é‡æ„
            APP->>LIN: reconstruct_with_details(probs)
            LIN->>LIN: æœ€å°äºŒä¹˜æ±‚è§£
            LIN->>APP: LinearReconstructionResult
        end
        
        alt WLSé‡æ„
            APP->>WLS: reconstruct_with_details(probs)
            WLS->>WLS: ä¼˜åŒ–æ±‚è§£
            WLS->>APP: WLSReconstructionResult
        end
        
        alt RÏR Stricté‡æ„
            APP->>RHO: reconstruct_with_details(probs)
            RHO->>RHO: RÏRè¿­ä»£
            RHO->>APP: RrhoStrictReconstructionResult
        end
        
        alt MLEé‡æ„
            APP->>MLE: reconstruct_with_details(probs)
            MLE->>MLE: ä¼˜åŒ–æ±‚è§£
            MLE->>APP: MLEReconstructionResult
        end
        
        APP->>REPO: ä¿å­˜ç»“æœ
        REPO->>REPO: å†™å…¥JSONå’ŒCSV
        
        opt è°±åˆ†è§£åˆ†æ
            APP->>SPEC: decompose(density)
            SPEC->>APP: SpectralResult
            APP->>REPO: ä¿å­˜è°±åˆ†è§£æŠ¥å‘Š
        end
    end
    
    APP->>CLI: SummaryResult
    CLI->>U: è¾“å‡ºç»“æœè·¯å¾„
```

---

## ğŸ“ **æ–‡ä»¶è°ƒç”¨å…³ç³»**

```
qtomography/
â”œâ”€â”€ cli/
â”‚   â””â”€â”€ main.py                    # å…¥å£ç‚¹
â”‚       â”œâ”€â”€ main()                 # ä¸»å‡½æ•°
â”‚       â”œâ”€â”€ _cmd_reconstruct()     # é‡æ„å‘½ä»¤
â”‚       â””â”€â”€ build_parser()         # å‚æ•°è§£æ
â”œâ”€â”€ app/
â”‚   â””â”€â”€ controller.py              # åº”ç”¨å±‚æ§åˆ¶å™¨
â”‚       â”œâ”€â”€ run_batch()            # æ‰¹å¤„ç†å…¥å£
â”‚       â””â”€â”€ ReconstructionController.run_batch()  # æ ¸å¿ƒé€»è¾‘
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ reconstruction/
â”‚   â”‚   â”œâ”€â”€ linear.py              # çº¿æ€§é‡æ„
â”‚   â”‚   â”‚   â””â”€â”€ reconstruct_with_details()  # è®¡ç®—å…¥å£
â”‚   â”‚   â”œâ”€â”€ wls.py                 # WLSé‡æ„
â”‚   â”‚   â”‚   â””â”€â”€ reconstruct_with_details()  # è®¡ç®—å…¥å£
â”‚   â”‚   â”œâ”€â”€ rhor_strict.py         # RÏR Stricté‡æ„
â”‚   â”‚   â”‚   â””â”€â”€ reconstruct_with_details()  # è®¡ç®—å…¥å£
â”‚   â”‚   â””â”€â”€ mle.py                 # MLEé‡æ„
â”‚   â”‚       â””â”€â”€ reconstruct_with_details()  # è®¡ç®—å…¥å£
â”‚   â”œâ”€â”€ measurement/               # æµ‹é‡åŸºè®¾è®¡
â”‚   â”‚   â”œâ”€â”€ mub.py                 # MUBæµ‹é‡åŸº
â”‚   â”‚   â”œâ”€â”€ sic.py                 # SIC-POVMæµ‹é‡åŸº
â”‚   â”‚   â””â”€â”€ nopovm.py              # NoPOVMæµ‹é‡åŸº
â”‚   â””â”€â”€ spectral_decomposition.py  # è°±åˆ†è§£
â”‚       â””â”€â”€ decompose()            # è°±åˆ†è§£å…¥å£
â””â”€â”€ infrastructure/
    â”œâ”€â”€ persistence/
    â”‚   â”œâ”€â”€ result_repository.py   # ç»“æœæŒä¹…åŒ–
    â”‚   â”‚   â””â”€â”€ save()             # ä¿å­˜ç»“æœ
    â”‚   â””â”€â”€ spectral_reporter.py   # è°±åˆ†è§£æŠ¥å‘Š
    â”‚       â””â”€â”€ save()             # ä¿å­˜æŠ¥å‘Š
    â””â”€â”€ visualization/
        â”œâ”€â”€ reconstruction_visualizer.py  # é‡æ„å¯è§†åŒ–
        â””â”€â”€ spectral_visualizer.py         # è°±åˆ†è§£å¯è§†åŒ–
```

---

## ğŸ¯ **å…³é”®è°ƒç”¨ç‚¹æ€»ç»“**

### **1. ç¨‹åºå…¥å£**
```python
# æ–‡ä»¶ï¼šqtomography/cli/main.py
def main(argv=None):
    # è§£æå‘½ä»¤è¡Œå‚æ•°
    # è°ƒç”¨å¯¹åº”çš„å­å‘½ä»¤å‡½æ•°
```

### **2. é…ç½®æ„å»º**
```python
# æ–‡ä»¶ï¼šqtomography/cli/main.py
def _cmd_reconstruct(args):
    # æ„å»ºReconstructionConfigå¯¹è±¡
    # æ”¯æŒmethodå‚æ•°ï¼šlinear, wls, rhor_strict, mle
    # æ”¯æŒdesignå‚æ•°ï¼šmub, sic, nopovm
    # è°ƒç”¨run_batch(config)
```

### **3. æ‰¹å¤„ç†æ§åˆ¶**
```python
# æ–‡ä»¶ï¼šqtomography/app/controller.py
def run_batch(config):
    # åŠ è½½æ•°æ®
    # æ ¹æ®config.methodsåˆ›å»ºå¯¹åº”çš„é‡æ„å™¨
    # æ‰¹å¤„ç†å¾ªç¯
    # è°ƒç”¨é‡æ„å™¨è®¡ç®—
    # å¯é€‰ï¼šæ‰§è¡Œè°±åˆ†è§£åˆ†æ
```

### **4. è®¡ç®—æ‰§è¡Œ**
```python
# æ–‡ä»¶ï¼šqtomography/domain/reconstruction/linear.py
def reconstruct_with_details(self, probabilities):
    # æ‰§è¡Œçº¿æ€§é‡æ„ç®—æ³•ï¼ˆæ”¯æŒå²­å›å½’ï¼‰
    # è¿”å›é‡æ„ç»“æœ

# æ–‡ä»¶ï¼šqtomography/domain/reconstruction/wls.py
def reconstruct_with_details(self, probabilities):
    # æ‰§è¡ŒWLSé‡æ„ç®—æ³•
    # è¿”å›é‡æ„ç»“æœ

# æ–‡ä»¶ï¼šqtomography/domain/reconstruction/rhor_strict.py
def reconstruct_with_details(self, counts_or_probs):
    # æ‰§è¡ŒRÏR Stricté‡æ„ç®—æ³•
    # è¿”å›é‡æ„ç»“æœ

# æ–‡ä»¶ï¼šqtomography/domain/reconstruction/mle.py  
def reconstruct_with_details(self, probabilities):
    # æ‰§è¡ŒMLEé‡æ„ç®—æ³•
    # è¿”å›é‡æ„ç»“æœ
```

### **5. ç»“æœä¿å­˜**
```python
# æ–‡ä»¶ï¼šqtomography/infrastructure/persistence/result_repository.py
def save(self, record):
    # ä¿å­˜JSONè®°å½•
    # æ›´æ–°CSVæ±‡æ€»

# æ–‡ä»¶ï¼šqtomography/infrastructure/persistence/spectral_reporter.py
def save(self, spectral_result, output_path):
    # ä¿å­˜è°±åˆ†è§£æŠ¥å‘Š
```

---

## ğŸ’¡ **è°ƒç”¨å…³ç³»å…³é”®ç‚¹**

### **1. åˆ†å±‚è°ƒç”¨**
```
CLIå±‚ â†’ åº”ç”¨å±‚ â†’ é¢†åŸŸå±‚ â†’ åŸºç¡€è®¾æ–½å±‚
```

### **2. æ•°æ®ä¼ é€’**
```
é…ç½®å¯¹è±¡ â†’ æ¦‚ç‡å‘é‡ â†’ é‡æ„ç»“æœ â†’ è®°å½•å¯¹è±¡ â†’ æ–‡ä»¶
```

### **3. æ§åˆ¶æµ**
```
ä¸»å‡½æ•° â†’ å­å‘½ä»¤ â†’ æ‰¹å¤„ç† â†’ é‡æ„è®¡ç®— â†’ ç»“æœä¿å­˜
```

### **4. å¤šç®—æ³•æ”¯æŒ**
```
æ ¹æ®config.methodsåŠ¨æ€åˆ›å»ºé‡æ„å™¨ï¼š
- linear: LinearReconstructor
- wls: WLSReconstructor
- rhor_strict: RrhoStrictReconstructor
- mle: MLEReconstructor
```

### **5. æµ‹é‡åŸºè®¾è®¡**
```
æ ¹æ®config.designé€‰æ‹©æµ‹é‡åŸºï¼š
- mub: MUBæµ‹é‡åŸº
- sic: SIC-POVMæµ‹é‡åŸº
- nopovm: NoPOVMæµ‹é‡åŸº
```

### **6. å¼‚å¸¸å¤„ç†**
```
æ¯å±‚éƒ½æœ‰å¼‚å¸¸å¤„ç†ï¼Œç¡®ä¿é”™è¯¯ä¸ä¼šå‘ä¸Šä¼ æ’­
```

---

## ğŸš€ **è°ƒè¯•å»ºè®®**

### **1. è®¾ç½®æ–­ç‚¹ä½ç½®**
```python
# 1. CLIå…¥å£
qtomography/cli/main.py:main()  # main()å‡½æ•°

# 2. åº”ç”¨å±‚æ§åˆ¶
qtomography/app/controller.py  # é‡æ„å™¨åˆ›å»ºå’Œè°ƒç”¨

# 3. é¢†åŸŸå±‚è®¡ç®—
qtomography/domain/reconstruction/linear.py  # æœ€å°äºŒä¹˜æ±‚è§£
qtomography/domain/reconstruction/wls.py     # WLSä¼˜åŒ–æ±‚è§£
qtomography/domain/reconstruction/rhor_strict.py  # RÏRè¿­ä»£
qtomography/domain/reconstruction/mle.py     # MLEä¼˜åŒ–æ±‚è§£
```

### **2. æ—¥å¿—è¾“å‡º**
```python
# åœ¨å…³é”®ä½ç½®æ·»åŠ æ—¥å¿—
import logging
logger = logging.getLogger(__name__)

logger.info(f"å¼€å§‹å¤„ç†æ ·æœ¬ {idx}")
logger.info(f"ä½¿ç”¨é‡æ„æ–¹æ³•: {method}")
logger.info(f"ä½¿ç”¨æµ‹é‡åŸºè®¾è®¡: {design}")
logger.info(f"æ¦‚ç‡å‘é‡: {probs}")
logger.info(f"é‡æ„ç»“æœ: {result.density.purity}")
```

### **3. æ€§èƒ½ç›‘æ§**
```python
import time

start_time = time.time()
result = reconstructor.reconstruct_with_details(probs)
elapsed = time.time() - start_time
print(f"é‡æ„è€—æ—¶: {elapsed:.2f}ç§’")
print(f"è¿­ä»£æ¬¡æ•°: {result.n_iterations if hasattr(result, 'n_iterations') else 'N/A'}")
```

---

**è®°ä½**ï¼šæ•´ä¸ªè°ƒç”¨æµç¨‹æ˜¯**åˆ†å±‚é€’è¿›**çš„ï¼Œæ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ã€‚çœŸæ­£çš„è®¡ç®—å‘ç”Ÿåœ¨é¢†åŸŸå±‚çš„`reconstruct_with_details()`æ–¹æ³•ä¸­ï¼ç°åœ¨æ”¯æŒå››ç§é‡æ„ç®—æ³•ï¼ˆLinearã€WLSã€RÏR Strictã€MLEï¼‰å’Œä¸‰ç§æµ‹é‡åŸºè®¾è®¡ï¼ˆMUBã€SICã€NoPOVMï¼‰ï¼
