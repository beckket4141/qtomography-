# é‡å­æ€å±‚æé‡æ„é¡¹ç›®ä»£ç è°ƒç”¨æµç¨‹å›¾

> **ç›®æ ‡**ï¼šå±•ç¤ºä»£ç çš„å…·ä½“è°ƒç”¨å…³ç³»å’Œæ‰§è¡Œé¡ºåº

---

## ğŸ¯ **æ•´ä½“è°ƒç”¨é“¾è·¯**

```
main() â†’ _cmd_reconstruct() â†’ run_batch() â†’ controller.run_batch() â†’ reconstruct_with_details()
```

---

## ğŸ“Š **è¯¦ç»†è°ƒç”¨æµç¨‹å›¾**

### **1. CLIå±‚è°ƒç”¨**

```mermaid
graph TD
    A[ç”¨æˆ·å‘½ä»¤] --> B[main()]
    B --> C[build_parser()]
    C --> D[args.func(args)]
    D --> E[_cmd_reconstruct()]
    
    E --> F[å‚æ•°è§£æ]
    F --> G[æ„å»ºReconstructionConfig]
    G --> H[run_batch(config)]
    H --> I[è¾“å‡ºç»“æœä¿¡æ¯]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/cli/main.py
def main(argv=None):
    parser = build_parser()
    args = parser.parse_args(argv)
    return args.func(args)  # è°ƒç”¨å­å‘½ä»¤å‡½æ•°

def _cmd_reconstruct(args):
    config = ReconstructionConfig(...)
    result = run_batch(config)  # è°ƒç”¨åº”ç”¨å±‚
    return 0
```

### **2. åº”ç”¨å±‚è°ƒç”¨**

```mermaid
graph TD
    A[run_batch(config)] --> B[ReconstructionController()]
    B --> C[controller.run_batch(config)]
    
    C --> D[åŠ è½½æ•°æ®]
    D --> E[åˆ›å»ºé‡æ„å™¨]
    E --> F[æ‰¹å¤„ç†å¾ªç¯]
    
    F --> G[çº¿æ€§é‡æ„]
    F --> H[MLEé‡æ„]
    
    G --> I[ä¿å­˜ç»“æœ]
    H --> I
    I --> J[ç”Ÿæˆæ±‡æ€»]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/app/controller.py
def run_batch(config):
    controller = ReconstructionController()
    return controller.run_batch(config)

class ReconstructionController:
    def run_batch(self, config):
        # åŠ è½½æ•°æ®
        data = _load_probabilities(config.input_path, config.sheet)
        
        # åˆ›å»ºé‡æ„å™¨
        linear = LinearReconstructor(dimension, ...)
        mle = MLEReconstructor(dimension, ...)
        
        # æ‰¹å¤„ç†å¾ªç¯
        for idx in range(sample_count):
            probs = data[:, idx]
            
            # çº¿æ€§é‡æ„
            if linear is not None:
                linear_result = linear.reconstruct_with_details(probs)
            
            # MLEé‡æ„
            if mle is not None:
                mle_result = mle.reconstruct_with_details(probs)
```

### **3. é¢†åŸŸå±‚è°ƒç”¨**

#### **3.1 çº¿æ€§é‡æ„è°ƒç”¨**

```mermaid
graph TD
    A[linear.reconstruct_with_details(probs)] --> B[_normalize_probabilities()]
    B --> C[projector_set.measurement_matrix]
    C --> D[np.linalg.lstsq()]
    D --> E[_vec_to_density_matrix()]
    E --> F[density.sanitize_within_tol()]
    F --> G[LinearReconstructionResult]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/domain/reconstruction/linear.py
def reconstruct_with_details(self, probabilities):
    # 1. å½’ä¸€åŒ–æ¦‚ç‡
    probs = self._normalize_probabilities(probabilities)
    
    # 2. è·å–æµ‹é‡çŸ©é˜µ
    measurement_matrix = self.projector_set.measurement_matrix
    
    # 3. æœ€å°äºŒä¹˜æ±‚è§£
    rho_vec, residuals, rank, singular_values = np.linalg.lstsq(
        measurement_matrix, probs, rcond=None
    )
    
    # 4. é‡æ„å¯†åº¦çŸ©é˜µ
    rho = self._vec_to_density_matrix(rho_vec)
    
    # 5. ç‰©ç†åŒ–å¤„ç†
    rho_physical = rho.sanitize_within_tol()
    
    return LinearReconstructionResult(...)
```

#### **3.2 MLEé‡æ„è°ƒç”¨**

```mermaid
graph TD
    A[mle.reconstruct_with_details(probs)] --> B[_normalize_probabilities()]
    B --> C[_get_initial_density()]
    C --> D[_encode_density_to_params()]
    D --> E[scipy.optimize.minimize()]
    E --> F[_decode_params_to_density()]
    F --> G[density.sanitize_within_tol()]
    G --> H[MLEReconstructionResult]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/domain/reconstruction/mle.py
def reconstruct_with_details(self, probabilities, initial_density=None):
    # 1. å½’ä¸€åŒ–æ¦‚ç‡
    probs = self._normalize_probabilities(probabilities)
    
    # 2. è·å–åˆå§‹å¯†åº¦çŸ©é˜µ
    if initial_density is None:
        initial_density = self._get_initial_density(probs)
    
    # 3. å‚æ•°åŒ–
    params = self._encode_density_to_params(initial_density)
    
    # 4. ä¼˜åŒ–æ±‚è§£
    result = minimize(
        self._negative_log_likelihood,
        params,
        method='L-BFGS-B',
        jac=self._gradient
    )
    
    # 5. é‡æ„å¯†åº¦çŸ©é˜µ
    rho = self._decode_params_to_density(result.x)
    
    # 6. ç‰©ç†åŒ–å¤„ç†
    rho_physical = rho.sanitize_within_tol()
    
    return MLEReconstructionResult(...)
```

### **4. åŸºç¡€è®¾æ–½å±‚è°ƒç”¨**

```mermaid
graph TD
    A[ä¿å­˜ç»“æœ] --> B[ResultRepository.save()]
    B --> C[record.to_serializable()]
    C --> D[JSONæ–‡ä»¶ä¿å­˜]
    D --> E[CSVæ±‡æ€»æ›´æ–°]
    
    A --> F[å¯è§†åŒ–] --> G[ReconstructionVisualizer]
    G --> H[ç”Ÿæˆå›¾è¡¨]
    H --> I[ä¿å­˜PNGæ–‡ä»¶]
```

**å…³é”®ä»£ç **ï¼š
```python
# qtomography/infrastructure/persistence/result_repository.py
def save(self, record: ReconstructionRecord):
    payload = record.to_serializable()
    
    # ä¿å­˜JSON
    with path.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, ensure_ascii=False, indent=2)
    
    # æ›´æ–°CSV
    self._append_to_csv(payload)
```

---

## ğŸ”„ **å®Œæ•´æ‰§è¡Œæ—¶åº**

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant CLI as CLIå±‚
    participant APP as åº”ç”¨å±‚
    participant LIN as çº¿æ€§é‡æ„å™¨
    participant MLE as MLEé‡æ„å™¨
    participant REPO as ç»“æœä»“åº“
    
    U->>CLI: qtomography reconstruct data.csv
    CLI->>CLI: è§£æå‚æ•°
    CLI->>APP: run_batch(config)
    
    APP->>APP: åŠ è½½CSVæ•°æ®
    APP->>APP: åˆ›å»ºé‡æ„å™¨å®ä¾‹
    
    loop æ¯ä¸ªæ ·æœ¬
        APP->>LIN: reconstruct_with_details(probs)
        LIN->>LIN: æœ€å°äºŒä¹˜æ±‚è§£
        LIN->>APP: LinearReconstructionResult
        
        APP->>MLE: reconstruct_with_details(probs)
        MLE->>MLE: ä¼˜åŒ–æ±‚è§£
        MLE->>APP: MLEReconstructionResult
        
        APP->>REPO: ä¿å­˜ç»“æœ
        REPO->>REPO: å†™å…¥JSONå’ŒCSV
    end
    
    APP->>CLI: SummaryResult
    CLI->>U: è¾“å‡ºç»“æœè·¯å¾„
```

---

## ğŸ“ **æ–‡ä»¶è°ƒç”¨å…³ç³»**

```
qtomography/
â”œâ”€â”€ cli/
â”‚   â””â”€â”€ main.py                    # å…¥å£ç‚¹
â”‚       â”œâ”€â”€ main()                 # ä¸»å‡½æ•°
â”‚       â”œâ”€â”€ _cmd_reconstruct()     # é‡æ„å‘½ä»¤
â”‚       â””â”€â”€ build_parser()         # å‚æ•°è§£æ
â”œâ”€â”€ app/
â”‚   â””â”€â”€ controller.py              # åº”ç”¨å±‚æ§åˆ¶å™¨
â”‚       â”œâ”€â”€ run_batch()            # æ‰¹å¤„ç†å…¥å£
â”‚       â””â”€â”€ ReconstructionController.run_batch()  # æ ¸å¿ƒé€»è¾‘
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ reconstruction/
â”‚       â”œâ”€â”€ linear.py              # çº¿æ€§é‡æ„
â”‚       â”‚   â””â”€â”€ reconstruct_with_details()  # è®¡ç®—å…¥å£
â”‚       â””â”€â”€ mle.py                 # MLEé‡æ„
â”‚           â””â”€â”€ reconstruct_with_details()  # è®¡ç®—å…¥å£
â””â”€â”€ infrastructure/
    â””â”€â”€ persistence/
        â””â”€â”€ result_repository.py   # ç»“æœæŒä¹…åŒ–
            â””â”€â”€ save()             # ä¿å­˜ç»“æœ
```

---

## ğŸ¯ **å…³é”®è°ƒç”¨ç‚¹æ€»ç»“**

### **1. ç¨‹åºå…¥å£**
```python
# æ–‡ä»¶ï¼šqtomography/cli/main.py
def main(argv=None):
    # è§£æå‘½ä»¤è¡Œå‚æ•°
    # è°ƒç”¨å¯¹åº”çš„å­å‘½ä»¤å‡½æ•°
```

### **2. é…ç½®æ„å»º**
```python
# æ–‡ä»¶ï¼šqtomography/cli/main.py
def _cmd_reconstruct(args):
    # æ„å»ºReconstructionConfigå¯¹è±¡
    # è°ƒç”¨run_batch(config)
```

### **3. æ‰¹å¤„ç†æ§åˆ¶**
```python
# æ–‡ä»¶ï¼šqtomography/app/controller.py
def run_batch(config):
    # åŠ è½½æ•°æ®
    # åˆ›å»ºé‡æ„å™¨
    # æ‰¹å¤„ç†å¾ªç¯
    # è°ƒç”¨é‡æ„å™¨è®¡ç®—
```

### **4. è®¡ç®—æ‰§è¡Œ**
```python
# æ–‡ä»¶ï¼šqtomography/domain/reconstruction/linear.py
def reconstruct_with_details(self, probabilities):
    # æ‰§è¡Œçº¿æ€§é‡æ„ç®—æ³•
    # è¿”å›é‡æ„ç»“æœ

# æ–‡ä»¶ï¼šqtomography/domain/reconstruction/mle.py  
def reconstruct_with_details(self, probabilities):
    # æ‰§è¡ŒMLEé‡æ„ç®—æ³•
    # è¿”å›é‡æ„ç»“æœ
```

### **5. ç»“æœä¿å­˜**
```python
# æ–‡ä»¶ï¼šqtomography/infrastructure/persistence/result_repository.py
def save(self, record):
    # ä¿å­˜JSONè®°å½•
    # æ›´æ–°CSVæ±‡æ€»
```

---

## ğŸ’¡ **è°ƒç”¨å…³ç³»å…³é”®ç‚¹**

### **1. åˆ†å±‚è°ƒç”¨**
```
CLIå±‚ â†’ åº”ç”¨å±‚ â†’ é¢†åŸŸå±‚ â†’ åŸºç¡€è®¾æ–½å±‚
```

### **2. æ•°æ®ä¼ é€’**
```
é…ç½®å¯¹è±¡ â†’ æ¦‚ç‡å‘é‡ â†’ é‡æ„ç»“æœ â†’ è®°å½•å¯¹è±¡ â†’ æ–‡ä»¶
```

### **3. æ§åˆ¶æµ**
```
ä¸»å‡½æ•° â†’ å­å‘½ä»¤ â†’ æ‰¹å¤„ç† â†’ é‡æ„è®¡ç®— â†’ ç»“æœä¿å­˜
```

### **4. å¼‚å¸¸å¤„ç†**
```
æ¯å±‚éƒ½æœ‰å¼‚å¸¸å¤„ç†ï¼Œç¡®ä¿é”™è¯¯ä¸ä¼šå‘ä¸Šä¼ æ’­
```

---

## ğŸš€ **è°ƒè¯•å»ºè®®**

### **1. è®¾ç½®æ–­ç‚¹ä½ç½®**
```python
# 1. CLIå…¥å£
qtomography/cli/main.py:196  # main()å‡½æ•°

# 2. åº”ç”¨å±‚æ§åˆ¶
qtomography/app/controller.py:700  # çº¿æ€§é‡æ„è°ƒç”¨
qtomography/app/controller.py:849  # MLEé‡æ„è°ƒç”¨

# 3. é¢†åŸŸå±‚è®¡ç®—
qtomography/domain/reconstruction/linear.py:86  # æœ€å°äºŒä¹˜æ±‚è§£
qtomography/domain/reconstruction/mle.py:120   # ä¼˜åŒ–æ±‚è§£
```

### **2. æ—¥å¿—è¾“å‡º**
```python
# åœ¨å…³é”®ä½ç½®æ·»åŠ æ—¥å¿—
import logging
logger = logging.getLogger(__name__)

logger.info(f"å¼€å§‹å¤„ç†æ ·æœ¬ {idx}")
logger.info(f"æ¦‚ç‡å‘é‡: {probs}")
logger.info(f"é‡æ„ç»“æœ: {result.density.purity}")
```

### **3. æ€§èƒ½ç›‘æ§**
```python
import time

start_time = time.time()
result = reconstructor.reconstruct_with_details(probs)
elapsed = time.time() - start_time
print(f"é‡æ„è€—æ—¶: {elapsed:.2f}ç§’")
```

---

**è®°ä½**ï¼šæ•´ä¸ªè°ƒç”¨æµç¨‹æ˜¯**åˆ†å±‚é€’è¿›**çš„ï¼Œæ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ã€‚çœŸæ­£çš„è®¡ç®—å‘ç”Ÿåœ¨é¢†åŸŸå±‚çš„`reconstruct_with_details()`æ–¹æ³•ä¸­ï¼
