# é‡å­æ€å±‚æé‡æ„é¡¹ç›®è¿è¡Œæµç¨‹è¯¦è§£

> **ç›®æ ‡**ï¼šç†æ¸…é¡¹ç›®çš„æ•°æ®æµå’Œè¿è¡Œæµç¨‹ï¼Œä»ç”¨æˆ·è¾“å…¥åˆ°æœ€ç»ˆç»“æœè¾“å‡º

---

## ğŸ¯ **æ•´ä½“æ¶æ„æµç¨‹**

```mermaid
graph TB
    A[ç”¨æˆ·è¾“å…¥] --> B[CLIå±‚]
    B --> C[åº”ç”¨å±‚Controller]
    C --> D[é¢†åŸŸå±‚Reconstructor]
    D --> E[åŸºç¡€è®¾æ–½å±‚Repository]
    E --> F[ç»“æœè¾“å‡º]
    
    subgraph "ç”¨æˆ·å±‚"
        A1[å‘½ä»¤è¡Œè¾“å…¥]
        A2[é…ç½®æ–‡ä»¶]
    end
    
    subgraph "CLIå±‚ (qtomography/cli/)"
        B1[å‚æ•°è§£æ]
        B2[é…ç½®æ„å»º]
        B3[å‘½ä»¤åˆ†å‘]
    end
    
    subgraph "åº”ç”¨å±‚ (qtomography/app/)"
        C1[ReconstructionController]
        C2[æ•°æ®åŠ è½½]
        C3[æ‰¹å¤„ç†å¾ªç¯]
    end
    
    subgraph "é¢†åŸŸå±‚ (qtomography/domain/)"
        D1[LinearReconstructor]
        D2[MLEReconstructor]
        D3[DensityMatrix]
        D4[ProjectorSet]
    end
    
    subgraph "åŸºç¡€è®¾æ–½å±‚ (qtomography/infrastructure/)"
        E1[ResultRepository]
        E2[ReconstructionVisualizer]
    end
    
    subgraph "è¾“å‡ºå±‚"
        F1[JSONè®°å½•]
        F2[CSVæ±‡æ€»]
        F3[å¯è§†åŒ–å›¾è¡¨]
    end
```

---

## ğŸ“Š **è¯¦ç»†æ•°æ®æµç¨‹å›¾**

### **1. ç”¨æˆ·è¾“å…¥é˜¶æ®µ**

```bash
# ç”¨æˆ·å‘½ä»¤ç¤ºä¾‹
qtomography reconstruct data.csv --method both --dimension 4 --bell
```

**è¾“å…¥æ•°æ®æ ¼å¼**ï¼š
```csv
# data.csv ç¤ºä¾‹
0.5,0.5,0.25,0.25
0.6,0.4,0.3,0.2
0.7,0.3,0.35,0.15
```

**æ•°æ®å«ä¹‰**ï¼š
- æ¯è¡Œï¼šä¸€ä¸ªé‡å­æ€çš„æµ‹é‡æ¦‚ç‡
- æ¯åˆ—ï¼šä¸åŒæµ‹é‡åŸºä¸‹çš„æ¦‚ç‡
- ç»´åº¦ï¼š4ç»´ â†’ 2Ã—2å¯†åº¦çŸ©é˜µ

---

### **2. CLIå±‚å¤„ç†æµç¨‹**

```python
# qtomography/cli/main.py
def _cmd_reconstruct(args):
    # [1] å‚æ•°è§£æå’ŒéªŒè¯
    input_path = Path(args.input)
    methods = _resolve_methods(args.method)  # "both" â†’ ["linear", "mle"]
    dimension = args.dimension
    
    # [2] æ„å»ºé…ç½®å¯¹è±¡
    config = ReconstructionConfig(
        input_path=input_path,
        output_dir=Path("demo_output"),
        methods=methods,
        dimension=dimension,
        analyze_bell=args.bell,
        # ... å…¶ä»–å‚æ•°
    )
    
    # [3] è°ƒç”¨åº”ç”¨å±‚
    result = run_batch(config)
    
    # [4] è¾“å‡ºç»“æœä¿¡æ¯
    print(f"æ±‡æ€»æŠ¥å‘Š: {result.summary_path}")
    print(f"è¯¦ç»†è®°å½•: {result.records_dir}")
```

**æ•°æ®è½¬æ¢**ï¼š
```
å‘½ä»¤è¡Œå‚æ•° â†’ ReconstructionConfigå¯¹è±¡
```

---

### **3. åº”ç”¨å±‚æ§åˆ¶å™¨æµç¨‹**

```python
# qtomography/app/controller.py
def run_batch(config: ReconstructionConfig):
    # [1] æ•°æ®åŠ è½½
    data = _load_probabilities(config.input_path, config.sheet)
    # data.shape = (4, 3)  # 4ä¸ªæ¦‚ç‡å€¼ï¼Œ3ä¸ªæ ·æœ¬
    
    # [2] ç»´åº¦æ¨æ–­
    dimension = config.dimension or _infer_dimension(data.shape[0])
    # dimension = 2  # 4ä¸ªæ¦‚ç‡ â†’ 2Ã—2çŸ©é˜µ
    
    # [3] åˆ›å»ºé‡æ„å™¨å®ä¾‹
    linear = LinearReconstructor(dimension, tolerance=1e-9)
    mle = MLEReconstructor(dimension, tolerance=1e-9)
    
    # [4] æ‰¹å¤„ç†å¾ªç¯
    for idx in range(data.shape[1]):  # éå†æ¯ä¸ªæ ·æœ¬
        probs = data[:, idx]  # æå–å½“å‰æ ·æœ¬çš„æ¦‚ç‡å‘é‡
        
        # çº¿æ€§é‡æ„
        if "linear" in config.methods:
            linear_result = linear.reconstruct_with_details(probs)
            # ä¿å­˜ç»“æœåˆ°JSONå’ŒCSV
        
        # MLEé‡æ„
        if "mle" in config.methods:
            mle_result = mle.reconstruct_with_details(probs)
            # ä¿å­˜ç»“æœåˆ°JSONå’ŒCSV
    
    # [5] ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š
    return SummaryResult(...)
```

**æ•°æ®æµ**ï¼š
```
CSVæ–‡ä»¶ â†’ pandas.DataFrame â†’ æ¦‚ç‡å‘é‡ â†’ é‡æ„ç»“æœ â†’ JSON/CSVæ–‡ä»¶
```

---

### **4. é¢†åŸŸå±‚è®¡ç®—æµç¨‹**

#### **4.1 çº¿æ€§é‡æ„è®¡ç®—**

```python
# qtomography/domain/reconstruction/linear.py
def reconstruct_with_details(self, probabilities):
    # [1] æ•°æ®é¢„å¤„ç†
    probs = self._normalize_probabilities(probabilities)
    # probs = [0.5, 0.5, 0.25, 0.25] å½’ä¸€åŒ–å
    
    # [2] è·å–æµ‹é‡çŸ©é˜µ
    measurement_matrix = self.projector_set.measurement_matrix
    # measurement_matrix.shape = (4, 4)  # 4ä¸ªæµ‹é‡åŸºï¼Œ4ä¸ªå¯†åº¦çŸ©é˜µå…ƒç´ 
    
    # [3] æœ€å°äºŒä¹˜æ±‚è§£
    if self.regularization is None:
        rho_vec, residuals, rank, singular_values = np.linalg.lstsq(
            measurement_matrix, probs, rcond=None
        )
    else:
        # å²­å›å½’æ±‚è§£
        rho_vec = np.linalg.solve(mtm + lambda_eye, right_hand)
    
    # [4] é‡æ„å¯†åº¦çŸ©é˜µ
    rho = self._vec_to_density_matrix(rho_vec)
    # rho.shape = (2, 2)  # 2Ã—2å¯†åº¦çŸ©é˜µ
    
    # [5] ç‰©ç†åŒ–å¤„ç†
    rho_physical = rho.sanitize_within_tol()
    
    return LinearReconstructionResult(
        density=rho_physical,
        residuals=residuals,
        rank=rank,
        singular_values=singular_values
    )
```

**æ•°æ®è½¬æ¢**ï¼š
```
æ¦‚ç‡å‘é‡ [0.5,0.5,0.25,0.25] â†’ å¯†åº¦çŸ©é˜µ [[0.5,0.5],[0.5,0.5]]
```

#### **4.2 MLEé‡æ„è®¡ç®—**

```python
# qtomography/domain/reconstruction/mle.py
def reconstruct_with_details(self, probabilities, initial_density=None):
    # [1] æ•°æ®é¢„å¤„ç†
    probs = self._normalize_probabilities(probabilities)
    
    # [2] è·å–åˆå§‹å¯†åº¦çŸ©é˜µ
    if initial_density is None:
        initial_density = self._get_initial_density(probs)
        # é€šå¸¸ä½¿ç”¨çº¿æ€§é‡æ„ç»“æœä½œä¸ºåˆå§‹å€¼
    
    # [3] å‚æ•°åŒ–å¯†åº¦çŸ©é˜µ
    params = self._encode_density_to_params(initial_density)
    
    # [4] ä¼˜åŒ–æ±‚è§£
    result = minimize(
        self._negative_log_likelihood,
        params,
        method='L-BFGS-B',
        jac=self._gradient,
        options={'maxiter': self.max_iterations}
    )
    
    # [5] é‡æ„å¯†åº¦çŸ©é˜µ
    rho = self._decode_params_to_density(result.x)
    
    # [6] ç‰©ç†åŒ–å¤„ç†
    rho_physical = rho.sanitize_within_tol()
    
    return MLEReconstructionResult(
        density=rho_physical,
        iterations=result.nit,
        success=result.success,
        final_objective=result.fun
    )
```

**æ•°æ®è½¬æ¢**ï¼š
```
æ¦‚ç‡å‘é‡ â†’ åˆå§‹å¯†åº¦çŸ©é˜µ â†’ ä¼˜åŒ–å‚æ•° â†’ æœ€ç»ˆå¯†åº¦çŸ©é˜µ
```

---

### **5. åŸºç¡€è®¾æ–½å±‚æŒä¹…åŒ–æµç¨‹**

```python
# qtomography/infrastructure/persistence/result_repository.py
def save(self, record: ReconstructionRecord):
    # [1] åºåˆ—åŒ–è®°å½•
    payload = record.to_serializable()
    
    # [2] ä¿å­˜JSONæ–‡ä»¶
    with path.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, ensure_ascii=False, indent=2)
    
    # [3] æ›´æ–°CSVæ±‡æ€»
    self._append_to_csv(payload)
```

**æ•°æ®æ ¼å¼**ï¼š
```json
// record_2_2025-10-07T14-16-37.json
{
  "method": "linear",
  "dimension": 2,
  "probabilities": [0.5, 0.5, 0.25, 0.25],
  "density_matrix": [[0.5, 0.5], [0.5, 0.5]],
  "metrics": {
    "purity": 0.75,
    "trace": 1.0,
    "rank": 4.0,
    "min_eigenvalue": 0.146,
    "max_eigenvalue": 0.854
  }
}
```

---

## ğŸ”„ **å®Œæ•´è¿è¡Œæµç¨‹æ—¶åºå›¾**

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant CLI as CLIå±‚
    participant APP as åº”ç”¨å±‚
    participant DOM as é¢†åŸŸå±‚
    participant INF as åŸºç¡€è®¾æ–½å±‚
    
    U->>CLI: qtomography reconstruct data.csv
    CLI->>CLI: è§£æå‚æ•°
    CLI->>CLI: æ„å»ºReconstructionConfig
    CLI->>APP: run_batch(config)
    
    APP->>APP: åŠ è½½CSVæ•°æ®
    APP->>APP: åˆ›å»ºé‡æ„å™¨å®ä¾‹
    APP->>APP: å¼€å§‹æ‰¹å¤„ç†å¾ªç¯
    
    loop æ¯ä¸ªæ ·æœ¬
        APP->>DOM: linear.reconstruct_with_details(probs)
        DOM->>DOM: æœ€å°äºŒä¹˜æ±‚è§£
        DOM->>APP: LinearReconstructionResult
        
        APP->>DOM: mle.reconstruct_with_details(probs)
        DOM->>DOM: ä¼˜åŒ–æ±‚è§£
        DOM->>APP: MLEReconstructionResult
        
        APP->>INF: ä¿å­˜ç»“æœåˆ°JSON
        APP->>INF: æ›´æ–°CSVæ±‡æ€»
    end
    
    APP->>CLI: SummaryResult
    CLI->>U: è¾“å‡ºç»“æœè·¯å¾„
```

---

## ğŸ“ **æ–‡ä»¶è¾“å‡ºç»“æ„**

```
demo_output/
â”œâ”€â”€ records/                          # è¯¦ç»†è®°å½•ç›®å½•
â”‚   â”œâ”€â”€ record_2_2025-10-07T14-16-37.json  # çº¿æ€§é‡æ„ç»“æœ
â”‚   â”œâ”€â”€ record_2_2025-10-07T14-16-38.json  # MLEé‡æ„ç»“æœ
â”‚   â””â”€â”€ ...
â”œâ”€â”€ summary.csv                       # æ±‡æ€»æŠ¥å‘Š
â””â”€â”€ plots/                           # å¯è§†åŒ–å›¾è¡¨ï¼ˆå¯é€‰ï¼‰
    â”œâ”€â”€ density_heatmap_0.png
    â”œâ”€â”€ amplitude_phase_0.png
    â””â”€â”€ ...
```

**summary.csvå†…å®¹**ï¼š
```csv
sample,method,purity,trace,rank,min_eigenvalue,max_eigenvalue,...
0,linear,0.75,1.0,4.0,0.146,0.854,...
0,mle,0.75,1.0,4.0,0.146,0.854,...
1,linear,0.80,1.0,4.0,0.150,0.850,...
1,mle,0.81,1.0,4.0,0.151,0.849,...
```

---

## ğŸ¯ **å…³é”®æ•°æ®è½¬æ¢ç‚¹**

### **1. è¾“å…¥æ•°æ®è½¬æ¢**
```
CSVæ–‡ä»¶ â†’ pandas.DataFrame â†’ æ¦‚ç‡å‘é‡æ•°ç»„
```

### **2. é‡æ„è®¡ç®—è½¬æ¢**
```
æ¦‚ç‡å‘é‡ â†’ æµ‹é‡çŸ©é˜µ â†’ å¯†åº¦çŸ©é˜µå‘é‡ â†’ å¯†åº¦çŸ©é˜µ
```

### **3. ç»“æœè¾“å‡ºè½¬æ¢**
```
é‡æ„ç»“æœ â†’ ReconstructionRecord â†’ JSONæ–‡ä»¶ + CSVæ±‡æ€»
```

### **4. å¯è§†åŒ–è½¬æ¢**
```
å¯†åº¦çŸ©é˜µ â†’ çƒ­å›¾/3Då›¾ â†’ PNGæ–‡ä»¶
```

---

## ğŸ’¡ **æµç¨‹å…³é”®ç‚¹æ€»ç»“**

### **1. æ•°æ®æµå‘**
```
ç”¨æˆ·è¾“å…¥ â†’ CLIè§£æ â†’ åº”ç”¨å±‚æ§åˆ¶ â†’ é¢†åŸŸå±‚è®¡ç®— â†’ åŸºç¡€è®¾æ–½å±‚æŒä¹…åŒ– â†’ ç»“æœè¾“å‡º
```

### **2. è®¡ç®—å¯åŠ¨ç‚¹**
- **æ–‡ä»¶**ï¼š`qtomography/app/controller.py`
- **æ–¹æ³•**ï¼š`run_batch()` ä¸­çš„å¾ªç¯
- **å…³é”®è°ƒç”¨**ï¼š`reconstruct_with_details(probs)`

### **3. æ ¸å¿ƒç®—æ³•**
- **çº¿æ€§é‡æ„**ï¼š`np.linalg.lstsq()` æœ€å°äºŒä¹˜æ±‚è§£
- **MLEé‡æ„**ï¼š`scipy.optimize.minimize()` ä¼˜åŒ–æ±‚è§£

### **4. ç»“æœå­˜å‚¨**
- **JSON**ï¼šè¯¦ç»†è®°å½•ï¼ŒåŒ…å«å®Œæ•´ä¿¡æ¯
- **CSV**ï¼šæ±‡æ€»æŠ¥å‘Šï¼Œä¾¿äºåˆ†æ

---

## ğŸš€ **è¿è¡Œç¤ºä¾‹**

### **å‘½ä»¤è¡Œæ‰§è¡Œ**
```bash
# åŸºæœ¬ç”¨æ³•
qtomography reconstruct data.csv --dimension 2

# å®Œæ•´ç”¨æ³•
qtomography reconstruct data.csv \
    --method both \
    --dimension 4 \
    --bell \
    --output-dir results
```

### **Pythonè„šæœ¬æ‰§è¡Œ**
```python
from qtomography.app import ReconstructionConfig, run_batch

config = ReconstructionConfig(
    input_path="data.csv",
    output_dir="results",
    methods=["linear", "mle"],
    dimension=4,
    analyze_bell=True
)

result = run_batch(config)
print(f"å¤„ç†äº† {result.num_samples} ä¸ªæ ·æœ¬")
```

---

**è®°ä½**ï¼šæ•´ä¸ªæµç¨‹çš„æ ¸å¿ƒæ˜¯**æ•°æ®è½¬æ¢**ï¼Œä»æ¦‚ç‡å‘é‡åˆ°å¯†åº¦çŸ©é˜µï¼Œå†åˆ°ç»“æœæ–‡ä»¶ã€‚æ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼Œæ•°æ®åœ¨å±‚é—´ä¼ é€’æ—¶ä¼šå‘ç”Ÿç›¸åº”çš„è½¬æ¢ã€‚
