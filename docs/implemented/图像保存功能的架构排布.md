# 图像保存功能的架构排布决策

> **决策日期**: 2025-10-19  
> **决策背景**: QTomography GUI MVP 开发过程中，发现输出结果缺少图像文件  
> **决策类型**: 架构设计决策  
> **影响范围**: 基础设施层、应用层、表示层  

## 🎯 核心问题

在量子态层析重构系统中，**图像保存功能应该放在哪个架构层次**？

## 📊 问题分析

保存图像这件事要分成两个维度来看：「谁决定什么时候保存」和「谁去真正把图像写到磁盘」。

### 1. 谁来决定"要不要保存"？

**GUI/CLI/UI 层**：最合适由界面层触发，因为它最清楚用户意图（是否勾选"保存图像"之类的选项），也控制保存路径等交互细节。

**应用层（Controller）**：主职责是 orchestrate 重构流程，把数据读进、算法跑完、summary 写出。如果在这里内置"自动保存图像"，会把流程和界面需求耦在一起，不利于 CLI 或别的入口复用。

**建议**：把"是否保存图像、保存到什么位置"的决策留给 UI 层或上层调用者，Controller 仍然专注于生成记录和 CSV。

### 2. 谁来真正把图像写到磁盘？

**基础设施层（infrastructure.visualization）**：已经有 ReconstructionVisualizer 等绘图工具。最自然的做法是在这里提供一个"保存接口"（例如 save_density_heatmap(record, path)），负责把图像渲染并保存到指定路径。这样文件生成的细节仍在基础设施层，符合职责分离，也方便 CLI / GUI / 脚本复用。

**GUI 直接调用 Matplotlib 保存**：虽然能实现，但会让保存逻辑散布在界面代码里，不利于其他入口复用，也不利于未来调整输出格式或风格。

**建议**：在 infrastructure.visualization 新增导出函数（或小服务），把 Matplotlib 保存流程封装好，只暴露"给我一个 ReconstructionRecord 和目标路径"这样的接口。

## 🏗️ 架构设计原则

### SOLID 原则分析

| 原则 | 在Controller中 | 在Infrastructure中 |
|------|----------------|-------------------|
| **SRP (单一职责)** | ❌ Controller职责过重 | ✅ 各司其职 |
| **OCP (开闭原则)** | ❌ 修改影响面大 | ✅ 易于扩展 |
| **DIP (依赖倒置)** | ❌ 违反依赖方向 | ✅ 符合依赖方向 |

### 职责分离

```python
# 决策层：谁决定保存？
GUI/CLI层 → 用户意图 + 交互控制
✅ 用户勾选"保存图像"
✅ 选择保存路径
✅ 控制保存格式/质量

# 执行层：谁真正保存？
Infrastructure层 → 技术实现 + 可复用性
✅ 图像渲染逻辑
✅ 文件写入操作
✅ 格式转换处理
```

## 🔧 实际落地流程建议

### 基础设施层实现

在 `qtomography/infrastructure/visualization` 增加一个导出函数：

```python
def save_density_heatmap(record: ReconstructionRecord, path: Path, *, dpi: int = 120) -> Path:
    fig = ReconstructionVisualizer().plot_density_heatmap(record.density_matrix, title=...)
    fig.savefig(path, dpi=dpi, bbox_inches="tight")
    fig.clf()
    return path
```

### 应用层/Controller

保持不变。若未来有"批量导出图像"这一共性需求，可以考虑在 Controller 里加一个可选参数（例如 export_figures=False），但初期不必强制。

### GUI 层

在绘图完成后，根据用户操作调用上述导出函数，把图像保存到与 JSON/CSV 同一目录或指定子目录。因为 GUI 已经掌握 ResultRepository 返回的记录集合，这里调用基础设施工具非常方便。

## 📈 方案优势

### 复用性极佳
```python
# 同一个保存函数，多个入口复用
def save_density_heatmap(record, path):
    # 可以被GUI调用
    # 可以被CLI调用  
    # 可以被脚本调用
    # 可以被API调用
```

### 架构清晰
- **决策逻辑**（保存与否、保存到哪）放在 GUI/CLI 等入口层，尊重用户意图
- **具体执行**（渲染 + 写文件）放在基础设施层，形成可复用的导出工具
- **应用层 Controller** 保持简单，避免硬编码 GUI 专属的副作用

## 🎯 最终决策

**采用分层架构方案**：
- 决策层：GUI/CLI 等入口层
- 执行层：infrastructure.visualization 层
- 应用层：保持简单，不强制保存图像

这样既保留了架构的清晰分工，又能快速把"保存图像"扩展给任何需要的入口（GUI、CLI、脚本等）。

## 📚 学习要点

1. **架构设计要考虑职责分离**：每个层次都有明确的职责边界
2. **决策和执行要分离**：谁决定 vs 谁执行
3. **复用性优先**：基础设施层的功能应该可以被多个入口复用
4. **SOLID原则指导**：用软件工程原则指导架构决策
5. **用户意图优先**：界面层最了解用户需求，应该由它决定行为

## 🔄 后续行动

1. 在 `infrastructure.visualization` 中实现 `PlotExporter` 类
2. 在 GUI 中添加图像保存选项和调用逻辑
3. 考虑在 CLI 中也添加图像导出功能
4. 编写单元测试验证各层职责