# Density 模块初步问题分析（归档）

> **状态**：已归档。列出的风险均在 2025-09 的重构中修复，最新实现参考 docs/implemented/density-module-overview.md。

# 密度矩阵物理化流程问题分析与解决方案

## 1. 背景
在量子态层析中，重构得到的密度矩阵往往因数值噪声而偏离物理上允许的集合（Hermitian、正半定、迹为 1）。MATLAB 版 `makephysical.m` 通过谱裁剪等操作恢复物理性。当前 Python 版本 `qtomography/qtomography/domain/density.py` 在移植时做了若干简化，使得**特征值处理**与**归一化**环节尚未达到量子层析常用的数值稳定性标准。本文档旨在：

1. 指出现有实现的关键问题；
2. 给出满足物理约束的改进方案；
3. 解释每一步骤背后的数值原因与量子层析需求；
4. 提供验证建议，确保方案在实际实验数据上可复现。

## 2. 现有实现概览
当前 `_make_physical_matrix` 与 `matrix_square_root` 的核心流程可概括为：

1. 通过 `(rho + rho^\dagger) / 2` 做一次 Hermitian 化；
2. 使用 `scipy.linalg.eig`（或 `numpy.linalg.eig`）获取特征值与特征向量；
3. 将负特征值截断为 0；
4. 归一化特征值再重构密度矩阵；
5. 通过三角拼接或再次 Hermitian 化消除非 Hermitian 噪声；
6. 在对角线添加一个固定的 $10^{-9}$ 稳定项。

虽然这些步骤在理想情况下能得到物理矩阵，但在实际浮点环境中会暴露出若干问题：

- **通用特征值分解**：`eig` 对 Hermitian 矩阵不会强制返回实谱和正交本征向量，导致重构后会重新引入虚部或非 Hermitian 误差。
- **复数比较与截断**：直接执行 `eigenvals < 0` 会因为复数与实数比较抛异常，或把存在微小虚部的特征值误判为负值。
- **归一化漂移**：在增加 $10^{-9}$ 对角补偿后未重新归一化，最终迹偏离 1，破坏密度矩阵定义。
- **重复 Hermitian 化**：复杂的下三角拼接步骤容易积累舍入误差，且与正交特征向量并不兼容。
- **平方根函数一致性**：`matrix_square_root` 与 `_make_physical_matrix` 混用了不同的特征值计算逻辑，可能在保真度计算时产生不一致的误差来源。

## 3. 核心问题解析
### 3.1 Hermitian 专用谱分解的重要性
密度矩阵在数学上是 Hermitian，因此完全可以使用专门针对 Hermitian 的特征值分解算法（NumPy/ SciPy 中对应 `eigh` 或 `eigvalsh`）。这些算法保证：

- 所得特征值全部为实数；
- 本征向量构成酉矩阵（即正交且归一）；
- 与输入矩阵的数值误差保持在浮点极限内。

相比之下，`eig` 会返回复数特征值和不正交的特征向量，重构时极易放大原始噪声，甚至导致 Hermitian 性再次被破坏。量子层析社区的主流实现（如 `qutip`, `pyGSTi`, 以及 MATLAB 自身函数）均默认对 Hermitian 输入使用 Hermitian 专用求解器。

### 3.2 数值噪声导致的“负特征值”
实验数据带来的微小负特征值通常只有 $10^{-12}$ 到 $10^{-9}$ 的量级，这些值应视作 0 而非物理上的负概率。处理要点：

1. 先取 `np.real(eigenvals)`，明确丢弃虚部；
2. 设定一个容差（例如 `tol = 1e-10`），只对小于 `-tol` 的特征值报错或重新投影，介于 `[-tol, 0]` 的值直接裁剪为 0；
3. 当全部特征值都被裁剪为 0 时，回退到最大混合态 $I/d$，保持迹为 1。

这类“投影到正半定锥”的做法与量子态层析文献一致，也与 MATLAB 原始实现 `makephysical.m` 的容差裁剪逻辑吻合。

### 3.3 归一化一致性
密度矩阵的迹必须严格等于 1。如果在重构后加入额外的对角补偿，或在 Hermitian 化时引入舍入误差，应立即重新归一化：

$$
\rho \leftarrow \frac{\rho}{\operatorname{Tr}(\rho)}.
$$

否则会导致后续纯度、保真度等指标偏离理论值。数值稳定性建议：

- 只有在数值漂移导致迹接近 0 或负值时才回退到最大混合态；
- 避免固定地加入常数项，改为在裁剪和归一化过程中解决稳定性问题。

### 3.4 Hermitian 化的策略
当使用 `eigh` 时，理论上 $V \Lambda V^\dagger$ 必然 Hermitian。为了对抗浮点误差，可以在重构后补充一次简单的平均：

```python
rho = (rho + rho.conj().T) / 2
```

无需再做三角拼接或额外的手工下三角拷贝，这些自定义操作往往比单纯的矩阵平均误差更大。

### 3.5 与矩阵平方根函数的一致性
保真度计算依赖 `matrix_square_root`。若其中仍使用 `eig` 或未对负谱进行裁剪，会让保真度出现 `nan` 或负值。保持 `_make_physical_matrix` 与 `matrix_square_root` 的特征值处理方式一致，可显著提升稳定性。

## 4. 建议的解决方案
以下步骤可在不改变外部接口的前提下提升算法稳定性：

1. **统一谱分解接口**：对所有需要处理 Hermitian 矩阵的函数使用 `scipy.linalg.eigh` 或 `numpy.linalg.eigh`。
2. **特征值裁剪与容差**：
   - `evals = np.real(evals)`；
   - `evals[evals < tol] = 0`，其中 `tol` 与类初始化的 `tolerance` 参数一致；
   - 若 `evals.sum() <= tol`，使用 `np.ones(d) / d` 作为谱。
3. **矩阵重构与归一化**：
   - `rho = eigenvecs @ np.diag(evals) @ eigenvecs.conj().T`；
   - `rho = (rho + rho.conj().T) / 2`；
   - `trace = float(np.real(np.trace(rho)))`；
   - 当 `trace > tol` 时执行 `rho /= trace`，否则回退到 `np.eye(d) / d`。
4. **去除固定对角补偿**：依靠上述裁剪和归一化即可确保正定性和迹的稳定性，无需额外加常数项。
5. **平方根函数同步调整**：沿用同一套 `eigh` + 容差裁剪 + Hermitian 化流程，以避免保真度计算中的不一致。
6. **对外接口不变**：`DensityMatrix.ensure_physical()`、`make_physical`、`compute_fidelity` 的调用方式保持不变，但内部实现更稳健。

## 5. 方案背后的数值解释
| 步骤 | 目的 | 数值原因 | 量子层析需求 |
| --- | --- | --- | --- |
| Hermitian 化 | 消除噪声导致的非 Hermitian 分量 | `(A + A^†)/2` 最小化 Frobenius 范数误差 | 确保谱分解合法 |
| `eigh` | 返回实谱与正交特征向量 | 专为 Hermitian 设计，避免虚部漂移 | 保证密度矩阵 Hermitian |
| 特征值裁剪 | 去掉噪声引起的负概率 | 避免 `nan`、负值影响正半定性 | 满足物理约束 |
| 归一化 | 恢复迹为 1 | 多次矩阵运算后迹会有微小偏差 | 符合密度矩阵定义 |
| 平方根同步 | 保证保真度计算稳定 | 防止平方根内部出现负谱 | 保证实验指标可靠 |

## 6. 验证建议
1. **单位测试**：针对以下情形构造测试矩阵：
   - 随机 Hermitian 矩阵加噪声；
   - 特征值包含小的负数（如 `-1e-12`）；
   - 跟踪归一化误差（迹偏离 1 的情况）。
2. **物理指标**：验证 `is_hermitian`、`is_positive_semidefinite`、`is_normalized` 都返回 True；
3. **对比 MATLAB 结果**：使用相同输入矩阵，与原始 `makephysical.m` 的输出比较 Frobenius 范数差异；
4. **保真度一致性**：对一对物理密度矩阵，比较 MATLAB 与 Python 的保真度结果，应在 $10^{-9}$ 以内一致；
5. **性能测试**：确认 `eigh` 在目标维度（如 4×4、8×8）上性能满足需求。

## 7. 总结
- 当前实现的主要问题集中在通用特征值分解、缺乏容差裁剪以及归一化步骤上；
- 采用 Hermitian 专用的谱分解、统一的容差裁剪与归一化流程，可以消除负特征值与迹漂移问题；
- 该方案无需改变外部接口，却能显著提升数值稳定性，并与 MATLAB 版逻辑保持一致；
- 按照本文档的验证建议执行测试，可确保修订后的实现满足量子层析的物理与工程需求。

