# 数据列选择功能设计讨论

> 讨论如何改进数据读取功能，允许用户选择处理哪些列（态）

**日期**: 2025年11月  
**状态**: 设计讨论

---

## 📋 需求概述

### 当前行为
- 用户选择 Excel/CSV 文件
- 程序自动处理**所有列**（所有样本/态）
- 用户无法选择只处理部分列

### 期望行为
1. **文件选择后**：程序自动识别文件中有多少个有效列（态）
2. **提供两个选项**：
   - **选项1**：自动处理所有态（默认，保持向后兼容）
   - **选项2**：自定义选择某些态（勾选后显示选择界面）
3. **自定义选择界面**：
   - 显示：从 __ 列（态）到 __ 列（态）
   - 用户输入具体数字
   - 例如：输入都是 1，表示只处理第 1 列

---

## 💭 设计讨论

### 1. 列索引表示方式

#### 问题：1-based 还是 0-based？

**选项 A：1-based（用户友好）** ⭐ **推荐**
- ✅ 符合 Excel 习惯（Excel 列从 1 开始：A=1, B=2, C=3...）
- ✅ 用户更容易理解
- ✅ 与"列1"、"列2"的表述一致

**选项 B：0-based（程序内部）**
- ❌ 用户不熟悉（需要解释"列0"是什么）
- ❌ 容易混淆

**建议**：
- **UI 显示**：使用 1-based（列1, 列2, 列3...）
- **程序内部**：转换为 0-based（索引 0, 1, 2...）
- **转换公式**：`程序索引 = 用户输入 - 1`

#### 示例

用户输入：
- 从列 1 到列 3
- 程序处理：列索引 0, 1, 2（对应 Excel 的 A, B, C 列）

---

### 2. 选择方式设计

#### 方案 A：范围选择（你提出的方案）⭐ **推荐作为 MVP**

**界面**：
```
☑ 自定义选择列
   从 [1] 列到 [3] 列
```

**优点**：
- ✅ 简单直观
- ✅ 适合连续选择
- ✅ 实现简单

**缺点**：
- ⚠️ 无法选择不连续的列（如：列1, 列3, 列5）
- ⚠️ 如果只选一列，需要输入两次相同数字

**改进建议**：
- 如果"从"和"到"相同，自动识别为单列选择
- 添加提示："输入相同数字表示只处理单列"

#### 方案 B：范围选择 + 单列快捷方式

**界面**：
```
☑ 自定义选择列
   选择方式：
   ○ 范围选择：从 [1] 列到 [3] 列
   ○ 单列选择：列 [1]
```

**优点**：
- ✅ 单列选择更直观
- ✅ 范围选择仍然可用

**缺点**：
- ⚠️ UI 稍微复杂

#### 方案 C：灵活选择（高级功能）

**界面**：
```
☑ 自定义选择列
   列选择：1,3,5-7,10
   （支持逗号分隔和范围）
```

**优点**：
- ✅ 非常灵活
- ✅ 可以处理任意组合

**缺点**：
- ⚠️ 实现复杂
- ⚠️ 需要解析和验证输入
- ⚠️ 用户学习成本高

**建议**：
- **MVP 阶段**：使用方案 A（范围选择）
- **未来增强**：可以考虑方案 C（如果用户有需求）

---

### 3. 有效列的判断

#### 问题：如何判断哪些列是"有效列"？

**选项 A：所有非空列** ⭐ **推荐**
- 检查每列是否有数据（不是全 NaN）
- 排除完全为空的列

**选项 B：所有列**
- 简单：直接使用 `data.shape[1]`
- 但可能包含空列

**选项 C：用户可配置**
- 允许用户设置"有效列"的判断标准
- 过于复杂，不推荐

**建议**：
- 使用选项 A：自动排除全空列
- 显示时提示："检测到 X 个有效列（已排除 Y 个空列）"

#### 实现示例

```python
def get_valid_columns(data: np.ndarray) -> list[int]:
    """获取有效列的索引（0-based）。"""
    valid_cols = []
    for col_idx in range(data.shape[1]):
        col_data = data[:, col_idx]
        # 检查是否全为 NaN 或全为空
        if not np.all(np.isnan(col_data)) and not np.all(col_data == 0):
            valid_cols.append(col_idx)
    return valid_cols
```

---

### 4. UI 设计建议

#### 位置：数据面板（DataPanel）

**当前布局**：
```
┌─────────────────────────┐
│ [文件路径输入框] [浏览]  │
│ 文件信息显示             │
└─────────────────────────┘
```

**改进后布局**：
```
┌─────────────────────────┐
│ [文件路径输入框] [浏览]  │
│ 文件信息显示             │
│                          │
│ 📊 数据列信息            │
│ 检测到 10 个有效列       │
│                          │
│ ○ 处理所有列（默认）     │
│ ☑ 自定义选择列           │
│    从 [1] 列到 [10] 列   │
│    （提示：输入相同数字  │
│     表示只处理单列）     │
└─────────────────────────┘
```

#### 交互流程

1. **用户选择文件**：
   - 程序自动读取文件
   - 检测有效列数
   - 显示："检测到 X 个有效列"

2. **默认状态**：
   - "处理所有列" 单选按钮选中
   - 自定义选择区域禁用（灰色）

3. **切换到自定义**：
   - 用户勾选"自定义选择列"
   - 自定义选择区域启用
   - 输入框默认值：从 1 到 X（X 是总列数）

4. **输入验证**：
   - 实时验证输入范围
   - 如果输入超出范围，显示错误提示
   - 如果"从" > "到"，显示错误提示

---

### 5. 数据验证规则

#### 输入验证

1. **范围检查**：
   - "从"列 >= 1
   - "到"列 <= 总列数
   - "从"列 <= "到"列

2. **有效性检查**：
   - 确保选择的列都是有效列（不是空列）
   - 如果选择了空列，给出警告（但不阻止）

3. **边界情况**：
   - 如果只选一列："从" == "到"
   - 如果选择所有列："从" == 1 且 "到" == 总列数

#### 错误提示示例

```
❌ "从列"不能大于"到列"
❌ "从列"必须在 1 到 10 之间
⚠️ 选择的列中包含空列，将跳过空列
```

---

### 6. 向后兼容性

#### 默认行为

- **默认选项**：处理所有列
- **配置文件**：如果不指定列选择，使用默认行为
- **CLI**：添加 `--columns` 参数（可选）

#### 配置保存

在 `ReconstructionConfig` 中添加：
```python
column_range: Optional[Tuple[int, int]] = None
# None 表示处理所有列
# (start, end) 表示从 start 列到 end 列（1-based）
```

---

### 7. 实现细节

#### 数据加载函数改进

```python
def _load_probabilities(
    path: Path, 
    sheet: Optional[Union[str, int]],
    column_range: Optional[Tuple[int, int]] = None  # 新增参数
) -> np.ndarray:
    """加载概率数据，支持列范围选择。
    
    参数:
        column_range: (start, end) 元组，1-based
            - None: 处理所有列
            - (1, 3): 处理列1到列3（对应索引0,1,2）
    """
    # ... 现有加载逻辑 ...
    
    # 如果指定了列范围，只选择对应列
    if column_range is not None:
        start_col, end_col = column_range
        # 转换为 0-based 索引
        start_idx = start_col - 1
        end_idx = end_col  # end 是包含的，所以不需要 -1
        data = data[:, start_idx:end_idx]
    
    return data
```

#### GUI 数据面板改进

```python
class DataPanel(QtWidgets.QWidget):
    # 新增属性
    self.column_info_label = QtWidgets.QLabel("未加载文件")
    self.process_all_radio = QtWidgets.QRadioButton("处理所有列")
    self.custom_select_radio = QtWidgets.QRadioButton("自定义选择列")
    self.from_col_spin = QtWidgets.QSpinBox()
    self.to_col_spin = QtWidgets.QSpinBox()
    
    # 文件选择后，自动检测列数
    def _analyze_file(self, path: Path):
        """分析文件，检测有效列数"""
        try:
            data = _load_probabilities(path, sheet=None)
            num_cols = data.shape[1]
            valid_cols = get_valid_columns(data)
            self.column_info_label.setText(
                f"检测到 {len(valid_cols)} 个有效列（共 {num_cols} 列）"
            )
            # 设置输入框范围
            self.from_col_spin.setRange(1, num_cols)
            self.to_col_spin.setRange(1, num_cols)
            self.to_col_spin.setValue(num_cols)
        except Exception as e:
            # 显示错误
            pass
```

---

## 🎯 推荐方案总结

### MVP 方案（最小可行产品）

1. **列索引**：1-based（用户友好）
2. **选择方式**：范围选择（从 X 列到 Y 列）
3. **有效列判断**：自动排除全空列
4. **UI 位置**：数据面板（DataPanel）
5. **默认行为**：处理所有列（向后兼容）

### UI 设计

```
┌─────────────────────────────────────┐
│ 数据文件选择                         │
├─────────────────────────────────────┤
│ [文件路径] [浏览]                    │
│ 文件大小: XXX KB                     │
│                                      │
│ 📊 数据列信息                        │
│ 检测到 10 个有效列                   │
│                                      │
│ ○ 处理所有列（10列）                 │
│ ☑ 自定义选择列                       │
│    从 [1] 列到 [10] 列               │
│    💡 提示：输入相同数字表示单列     │
└─────────────────────────────────────┘
```

### UI 布局优化建议（1.1 可落实）

- **信息卡 + 操作区**：将“检测结果”与“操作选择”拆成左右两个卡片，左卡只展示有效列/空列统计，右卡放处理模式单选与输入框，减少纵向堆叠。
- **分段控件切换模式**：在自定义区域顶部加入 `全部 / 范围 / 多选（占位）` Segment，切到不同模式再动态展示字段；即便多选尚未实现，也可置灰提示“即将上线”。
- **提示与校验贴近输入**：将“输入相同数字表示单列”改为输入框下方的浅色 Caption（`ⓘ` 图标 + 描述），错误信息用红色文字就地显示，避免额外占位。
- **数据预览样式**：列表采用条纹行 + 固定表头，让预览与设置卡风格统一；必要时在卡片右上角放置轻量图标（📊、⚙️）增强可读性。

### 配置参数

在 `ReconstructionConfig` 中添加：
```python
column_range: Optional[Tuple[int, int]] = None
# None: 处理所有列（默认）
# (start, end): 处理从 start 到 end 的列（1-based，包含两端）
```

---

## ❓ 决策与待确认事项

- **列索引表示**：✅ 使用 1-based，对应逻辑仍是 0-based；Owner：前端（DataPanel）负责显示，核心库负责转换。
- **选择方式**：✅ MVP 只做范围选择；Owner：前端。⏳ `多选/离散列` 进入 Stage-2 Backlog，由产品在 1.2 再评估。
- **空列处理**：✅ 自动排除全空列并在 UI 标红提示；当用户选到空列时弹出 toast 并阻止执行；Owner：算法侧提供 `get_valid_columns`，前端做校验。
- **单列输入**：✅ 同值表示单列，界面加入 Caption 文案；Owner：前端。
- **CSV 支持**：✅ 与 Excel 同步，数据加载层统一入口；Owner：后端/API。
- **错误处理**：⏳ 需要定义提示文案与阻断策略，建议在 1.1 先阻断 + 明确错误，后续才允许“忽略继续”；Owner：产品 + 前端。

---

## 🧭 用户流（1.1）

1. 用户在 DataPanel 选择文件 → 触发异步 `analyze_file`，得出列数与有效列集合。
2. 面板展示“检测结果”卡片，默认高亮“处理所有列”。
3. 用户切换到“自定义”→ 输入起止列 → 就地校验（范围、空列、起止顺序）。
4. 若校验通过，配置写入 `ReconstructionConfig` 并显示摘要（如“处理中：第 3–6 列”）。
5. 点击开始重建时，控制器携带 `column_range` 调用加载函数；失败会回填错误提示并保持用户输入。

---

## 🔄 实现步骤建议

### 阶段 1：核心功能（MVP）

1. **修改数据加载函数**：
   - 添加 `column_range` 参数
   - 实现列选择逻辑

2. **修改数据面板**：
   - 添加列信息显示
   - 添加选择界面
   - 实现文件分析功能

3. **修改配置类**：
   - 在 `ReconstructionConfig` 中添加 `column_range` 字段

4. **修改控制器**：
   - 传递列选择参数到数据加载函数

### 阶段 2：增强功能（Backlog，非 1.1）

1. **数据预览**：
   - 显示每列的基本统计信息
   - 标记空列

2. **灵活选择**：
   - 支持不连续列选择（UI Segment 切到“多选”后启用）
   - 支持列列表输入（如：1,3,5）

3. **批量操作**：
   - 保存列选择配置
   - 快速选择常用范围

---

## 💡 额外建议

### 1. 数据预览功能（可选但推荐）

在文件选择后，可以显示一个简单的数据预览：

```
┌─────────────────────────────────────┐
│ 数据预览（前5行）                   │
│ 列1    列2    列3    ...            │
│ 0.25   0.30   0.20   ...            │
│ 0.25   0.20   0.30   ...            │
│ ...                                 │
└─────────────────────────────────────┘
```

### 2. 列统计信息（可选）

显示每列的基本信息：
- 列索引
- 数据范围（最小值、最大值）
- 是否有缺失值
- 是否为空列

### 3. 智能提示

- 如果检测到空列，提示用户
- 如果选择的列数很多，提示处理时间可能较长
- 如果只选一列，提示可以使用单列模式

---

## 📝 总结

你的方案**非常合理**！主要建议：

1. ✅ **使用 1-based 索引**（更用户友好）
2. ✅ **范围选择作为 MVP**（简单实用）
3. ✅ **自动检测有效列**（提升用户体验）
4. ✅ **保持向后兼容**（默认处理所有列）

**需要完善的地方**：
1. 明确空列的处理策略
2. 考虑单列选择的快捷方式
3. 添加输入验证和错误提示
4. 考虑未来是否需要更灵活的选择方式

你觉得这个方案如何？有什么需要调整的地方吗？

