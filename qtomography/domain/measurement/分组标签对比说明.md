# 测量设计分组标签（groups）对比说明

## 一、分组标签的作用

分组标签 `groups` 用于**按组归一化**测量概率，而不是全局归一化。这在处理多组测量（如 MUB）时非常重要，因为：

1. **物理意义**：每个测量基组构成一个 POVM，组内概率和应为 1
2. **数据解释**：实验数据通常是按组测量的，每组独立归一化
3. **算法兼容**：不同重构算法需要不同的归一化方式

## 二、三种测量设计的对比

### 1. **nopovm.py** - 非 POVM 测量设计

```python
groups_arr = np.zeros(len(projectors_arr), dtype=int)  # 单组模式（全部为 0）
```

**特点**：
- ✅ **单组模式**：所有 n² 个投影算符都在同一组（全部标签为 0）
- ✅ **全局归一化**：所有概率的和为 1
- ✅ **非 POVM**：∑E_i ≠ I，因此不需要按组归一化

**示例**（d=3，共 9 个投影）：
```
groups = [0, 0, 0, 0, 0, 0, 0, 0, 0]
归一化规则：sum(p[0:9]) = 1
```

---

### 2. **mub.py** - 相互无偏基（MUB）测量设计

#### 2.1 variant="full" 模式（完整 MUB）

```python
for g, basis in enumerate(bases_full):  # g = 0, 1, ..., d
    for i in range(d):
        groups_full.append(g)
```

**特点**：
- ✅ **多组模式**：d+1 个基组，每组 d 个投影
- ✅ **按组归一化**：每个基组内的概率和为 1
- ✅ **POVM 结构**：每个基组构成一个 POVM（∑E_i = I）

**示例**（d=3，共 12 个投影，4 个基组）：
```
groups = [0,0,0,  1,1,1,  2,2,2,  3,3,3]
         └基0┘  └基1┘  └基2┘  └基3┘

归一化规则：
  sum(p[0:3]) = 1   # 基组 0
  sum(p[3:6]) = 1   # 基组 1
  sum(p[6:9]) = 1   # 基组 2
  sum(p[9:12]) = 1  # 基组 3
```

#### 2.2 variant="compact" 模式（紧凑 MUB）

```python
# 紧凑模式：选子集后各组不再构成 POVM，改为单组归一化以匹配线性重构流程
groups_arr = np.zeros(len(idx), dtype=int)
```

**特点**：
- ✅ **单组模式**：从 d(d+1) 个投影中选择 d² 个线性无关的投影
- ✅ **全局归一化**：所有概率的和为 1
- ⚠️ **不再构成 POVM**：选子集后，各组不再满足 POVM 条件

**示例**（d=3，从 12 个投影中选择 9 个）：
```
groups = [0, 0, 0, 0, 0, 0, 0, 0, 0]
归一化规则：sum(p[0:9]) = 1
```

**为什么 compact 模式使用单组？**
- 选子集后，各组不再构成完整的 POVM
- 为了匹配线性重构流程，使用全局归一化更合适
- 避免按组归一化导致的数值问题

---

### 3. **sic.py** - 对称信息完备 POVM（SIC-POVM）

```python
groups = np.zeros((m,), dtype=int)  # single-group SIC
```

**特点**：
- ✅ **单组模式**：所有 m 个投影算符都在同一组（全部标签为 0）
- ✅ **全局归一化**：所有概率的和为 1
- ✅ **POVM 结构**：虽然单组，但满足 ∑E_i = I（因为 E_k = (1/d)|ψ_k><ψ_k|）

**示例**（d=2，共 4 个投影）：
```
groups = [0, 0, 0, 0]
归一化规则：sum(p[0:4]) = 1
```

---

## 三、归一化逻辑对比

### 代码实现（以 `rhor_strict.py` 为例）

```python
def _normalize_per_group(self, counts_or_probs: np.ndarray) -> np.ndarray:
    v = np.asarray(counts_or_probs, dtype=float).reshape(-1)
    groups = getattr(self.projector_set, "groups", None)
    
    if groups is None or len(groups) != m:
        # 情况 1：无分组信息 → 全局归一化
        total = float(np.sum(v))
        return v / total
    
    # 情况 2：有分组信息 → 按组归一化
    out = v.astype(float).copy()
    for g in np.unique(groups):
        idx = np.where(groups == g)[0]
        s = float(np.sum(out[idx]))
        out[idx] = out[idx] / s  # 每组独立归一化
    return out
```

### 归一化规则总结

| 测量设计 | groups 模式 | 归一化方式 | 物理意义 |
|---------|------------|-----------|---------|
| **nopovm** | 单组（全 0） | 全局归一化 | 非 POVM，所有概率和为 1 |
| **mub (full)** | 多组（0 到 d） | 按组归一化 | 每组是 POVM，组内概率和为 1 |
| **mub (compact)** | 单组（全 0） | 全局归一化 | 选子集后不再构成 POVM |
| **sic** | 单组（全 0） | 全局归一化 | POVM，所有概率和为 1 |

---

## 四、使用建议

### 1. **选择测量设计时**

- **需要多组测量**：使用 `mub` 的 `variant="full"`
- **需要信息完备但单组归一化**：使用 `mub` 的 `variant="compact"`、`nopovm` 或 `sic`
- **需要标准 POVM**：使用 `sic`（d=2）或 `mub` 的 `variant="full"`

### 2. **处理实验数据时**

- **按组测量**：如果实验是按基组测量的，使用 `variant="full"` 并按组归一化
- **全局测量**：如果实验是全局测量的，使用单组模式（compact/nopovm/sic）

### 3. **算法兼容性**

- **线性重构**：通常使用全局归一化（单组模式）
- **WLS 重构**：支持按组归一化（多组模式）
- **RρR 重构**：支持两种模式，根据 groups 自动选择

---

## 五、总结

分组标签的核心区别：

1. **nopovm**：单组模式，适合非 POVM 测量
2. **mub (full)**：多组模式，每组是 POVM，适合多组测量实验
3. **mub (compact)**：单组模式，适合线性重构等需要全局归一化的场景
4. **sic**：单组模式，标准 POVM，适合单组测量实验

选择哪种模式取决于：
- 实验测量方式（按组 vs 全局）
- 算法需求（按组归一化 vs 全局归一化）
- 物理约束（POVM vs 非 POVM）

